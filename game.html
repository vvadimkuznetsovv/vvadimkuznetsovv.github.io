<!DOCTYPE html>
<!--
    Лицензия на данный код:

    Авторский код разработан и предоставлен:
      - Кузнецов Вадим Алексеевич (ООО НейроБизнес Солюшнс)
      - Басма Нассиф Хуссейн (ООО Интеллектуальные Технологии Будущего Образования)

    Использование, распространение и модификация данного кода допускаются только при соблюдении
    условий лицензионного соглашения. При использовании данного кода, пожалуйста, сохраняйте
    данный блок с указанием авторства.
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Neon Nexus: Ultimate Gauntlet – Levels Edition (Expanded)</title>
  <style>
    :root {
      --ui-scale: 1;
    }
    /* Reset and full‑screen canvas */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
    /* Overlay for menus, transitions, power‑up selection, pause, game over, etc. */
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.85);
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      text-align: center;
      user-select: none;
      font-size: calc(16px * var(--ui-scale));
    }
    #overlay.hidden {
      display: none;
    }
    .button {
      margin: calc(10px * var(--ui-scale));
      padding: calc(10px * var(--ui-scale)) calc(20px * var(--ui-scale));
      background: #222;
      border: calc(2px * var(--ui-scale)) solid #0ff;
      color: #0ff;
      font-size: calc(18px * var(--ui-scale));
      cursor: pointer;
    }
    .button:hover {
      background: #0ff;
      color: #000;
    }
    /* Mobile Joysticks & Pause Button */
    #leftJoystick, #rightJoystick {
      position: absolute;
      bottom: 20px;
      width: calc(200px * var(--ui-scale));;
      height: calc(200px * var(--ui-scale));
      background: rgba(255,255,255,0.1);
      border-radius: 50%;
      z-index: 50;
      touch-action: none;
      display: none;
    }
    #leftJoystick { left: 20px; }
    #rightJoystick { right: 20px; }
    .joystick-thumb {
      position: absolute;
      width: calc(80px * var(--ui-scale));
      height: calc(80px * var(--ui-scale));
      background: rgba(0,255,255,0.4);
      border-radius: 50%;
      top: calc(60px * var(--ui-scale));
      left: calc(60px * var(--ui-scale));
      transition: transform 0.1s ease;
    }
    #mobilePauseButton {
      position: absolute;
      top: calc(110px * var(--ui-scale));
      right: calc(20px * var(--ui-scale));
      z-index: 50;
      padding: calc(15px * var(--ui-scale));
      background: rgba(0,0,0,0.5);
      border: calc(2px * var(--ui-scale)) solid #0ff;
      color: #0ff;
      font-size: calc(20px * var(--ui-scale));
      display: none;
    }
    
    @media only screen and (max-width: 768px) {
      /* Increase overlay font sizes */
      #overlay h1 {
        font-size: calc(2.5em * var(--ui-scale));
      }
      #overlay p {
        font-size: calc(1.8em * var(--ui-scale));
      }
      .button {
        font-size: calc(1.5em * var(--ui-scale));
        padding: calc(15px * var(--ui-scale)) calc(30px * var(--ui-scale));
      }
    }
    
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <!-- Overlay for menus, transitions, power‑up selection, pause, game over -->
  <div id="overlay">
    <h1>Neon Nexus: Ultimate Gauntlet</h1>
    <p id="overlayText">
      Move with WASD, aim with your mouse and auto‑fire.<br>
      Collect glowing orbs to fill your power meter.<br>
      When full, choose one of three temporary power‑ups to help you survive.
    </p>
    <p id="startHint">Press <strong>SPACE</strong> to begin</p>
    <div id="overlayButtons"></div>
  </div>

  <!-- Mobile controls -->
  <div id="leftJoystick">
    <div class="joystick-thumb"></div>
  </div>
  <div id="rightJoystick">
    <div class="joystick-thumb"></div>
  </div>
  <button id="mobilePauseButton">Pause</button>

  <script>
  (function(){
    // =================== Canvas & Initialization ===================
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    window.addEventListener("resize", () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    });

    // =================== Device Detection & UI Setup ===================
    const isMobile = ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);
    const leftJoystickElem = document.getElementById("leftJoystick");
    const rightJoystickElem = document.getElementById("rightJoystick");
    const mobilePauseButton = document.getElementById("mobilePauseButton");
    if(isMobile) {
      leftJoystickElem.style.display = "block";
      rightJoystickElem.style.display = "block";
      mobilePauseButton.style.display = "block";
      document.getElementById("startHint").innerHTML = "Tap anywhere to begin";
    }
    let uiScale = isMobile ? 1.7 : 1; // Increase scale on mobile

    // =================== Update Scale Function ===================
    function updateScale() {
      if (isMobile) {
        // On mobile, use landscape or portrait-specific scales.
        if (window.innerWidth > window.innerHeight) {
          uiScale = 0.8;    // mobile landscape
        } else {
          uiScale = 1.7;  // mobile portrait
        }
      } else {
        // On desktop, always use scale 1.
        uiScale = 1;
      }
      // Update CSS custom property so that DOM elements also scale accordingly.
      document.documentElement.style.setProperty('--ui-scale', uiScale);
    }
    

    // Call updateScale initially
    updateScale();

    // Add resize listener to update canvas dimensions and scale on orientation change
    window.addEventListener("resize", () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      updateScale();
    });

    // =================== Game States & Global Variables ===================
    // States: "menu", "playing", "transition", "powerup", "pause", "gameover"
    let gameState = "menu";
    let score = 0;
    let currentLevel = 1;
    let levelDuration = 30000; // 30 sec per wave
    let levelTimer = levelDuration;
    // Permanent upgrades (affect damage, speed, fire rate)
    const permanentUpgrades = {
      damage: 1,
      speed: 1,
      fireRate: 1,
      health: 0            // *** NEW: добавлено для перманентного увеличения здоровья ***
    };
    // Power meter for temporary power‑ups
    let powerMeter = 0;
    const POWER_METER_MAX = 100;
    // Spawn & firing timers
    let enemySpawnTimer = 0;
    let enemySpawnInterval = 1500;
    let fireCooldown = 0;
    const BASE_FIRE_RATE = 200;

    // =================== Global Arrays for Game Objects ===================
    let player;
    let bullets = [];
    let enemies = [];
    const collectibles = [];
    const particles = [];
    // Вместо одиночного босса используем массив
    let bosses = [];
    // --- Новый массив для отображения урона (плавающие красные числа) ---
    let damageTexts = [];

    // =================== Input Handling ===================
    const keys = {};
    const mouse = { x: width/2, y: height/2, down: false };
    window.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
      if((gameState === "menu" || gameState === "gameover") && (e.key === " " || e.code === "Space")) {
        startGame();
      }
      if(e.key === "Escape") {
        if(gameState === "playing") pauseGame();
        else if(gameState === "pause") resumeGame();
      }
      // ************************************
      // **  BUTTON P: SPAWN 2 BOSSES (LEVEL 7)  **
      // ************************************
      if(e.key.toLowerCase() === "p") {
        givePlayerMagnetEffect()
      }
    });
    window.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener("mousedown", () => { mouse.down = true; });
    canvas.addEventListener("mouseup", () => { mouse.down = false; });
    mobilePauseButton.addEventListener("click", () => {
      if(gameState === "playing") pauseGame();
    });
    document.addEventListener("pointerdown", (e) => {
      if (gameState === "menu" || gameState === "gameover") {
        startGame();
      }
    });
    

    // =================== Virtual Joysticks (Mobile) ===================
    const leftJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
    const rightJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0, angle: 0 };
    function setupJoystick(joystickElem, joystickObj) {
      // Get the thumb element from the joystick container
      const thumb = joystickElem.querySelector('.joystick-thumb');
    
      // Touch Start: store the active touch and reset offsets
      joystickElem.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (!joystickObj.active) {
          const touch = e.changedTouches[0];
          joystickObj.active = true;
          joystickObj.activeTouchId = touch.identifier; // Save the unique touch id
          const rect = joystickElem.getBoundingClientRect();
          joystickObj.startX = touch.clientX - rect.left;
          joystickObj.startY = touch.clientY - rect.top;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          // Ensure the thumb starts centered
          thumb.style.transform = 'translate(0px, 0px)';
        }
      });
    
      // Touch Move: update the joystick offset and move the thumb visually
      joystickElem.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if (!joystickObj.active) return;
    
        // Find the touch that corresponds to this joystick
        let relevantTouch = null;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joystickObj.activeTouchId) {
            relevantTouch = e.changedTouches[i];
            break;
          }
        }
        if (!relevantTouch) return; // No matching touch
    
        const rect = joystickElem.getBoundingClientRect();
        const x = relevantTouch.clientX - rect.left;
        const y = relevantTouch.clientY - rect.top;
        let dx = x - joystickObj.startX;
        let dy = y - joystickObj.startY;
        const maxDist = 80 * uiScale; // Adjust according to your new joystick size
        const dist = Math.hypot(dx, dy);
        if (dist > maxDist) {
          dx = (dx / dist) * maxDist;
          dy = (dy / dist) * maxDist;
        }
        joystickObj.dx = dx;
        joystickObj.dy = dy;
        
        // Update the thumb's position for visual feedback:
        thumb.style.transform = 'translate(' + dx + 'px, ' + dy + 'px)';
    
        // If this is the right joystick, update the aiming angle as well
        if (joystickObj === rightJoystick) {
          joystickObj.angle = Math.atan2(dy, dx);
        }
      });
    
      // Touch End: reset the joystick state and thumb position
      joystickElem.addEventListener("touchend", (e) => {
        let touchEnded = false;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joystickObj.activeTouchId) {
            touchEnded = true;
            break;
          }
        }
        if (touchEnded) {
          joystickObj.active = false;
          joystickObj.activeTouchId = null;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          // Reset thumb to center
          thumb.style.transform = 'translate(0px, 0px)';
        }
      });
    
      // Handle touch cancel events similarly to touch end
      joystickElem.addEventListener("touchcancel", (e) => {
        let touchCanceled = false;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joystickObj.activeTouchId) {
            touchCanceled = true;
            break;
          }
        }
        if (touchCanceled) {
          joystickObj.active = false;
          joystickObj.activeTouchId = null;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          thumb.style.transform = 'translate(0px, 0px)';
        }
      });
    }
    
    
    if(isMobile) {
      setupJoystick(leftJoystickElem, leftJoystick);
      setupJoystick(rightJoystickElem, rightJoystick);
    }

    // =================== Biomes / Backgrounds ===================
    const biomes = [
      {
        name: "Neon Arena",
        drawBackground: function() {
          ctx.fillStyle = "#111";
          ctx.fillRect(0,0,width,height);
          const gridSize = 50;
          ctx.strokeStyle = "#222";
          ctx.lineWidth = 1;
          for(let x = 0; x < width; x += gridSize){
            ctx.beginPath();
            ctx.moveTo(x,0);
            ctx.lineTo(x,height);
            ctx.stroke();
          }
          for(let y = 0; y < height; y += gridSize){
            ctx.beginPath();
            ctx.moveTo(0,y);
            ctx.lineTo(width,y);
            ctx.stroke();
          }
        }
      },
      {
        name: "Cyber Grid",
        drawBackground: function() {
          const grad = ctx.createLinearGradient(0,0,width,height);
          grad.addColorStop(0, "#001a00");
          grad.addColorStop(1, "#000");
          ctx.fillStyle = grad;
          ctx.fillRect(0,0,width,height);
          const gridSize = 60;
          ctx.strokeStyle = "rgba(0,255,100,0.2)";
          ctx.lineWidth = 1;
          for(let x = 0; x < width; x += gridSize){
            ctx.beginPath();
            ctx.moveTo(x,0);
            ctx.lineTo(x,height);
            ctx.stroke();
          }
          for(let y = 0; y < height; y += gridSize){
            ctx.beginPath();
            ctx.moveTo(0,y);
            ctx.lineTo(width,y);
            ctx.stroke();
          }
        }
      },
      {
        name: "Digital Void",
        drawBackground: function() {
          ctx.fillStyle = "#000";
          ctx.fillRect(0,0,width,height);
          for(let i=0;i<150;i++){
            const x = Math.random()*width;
            const y = Math.random()*height;
            ctx.fillStyle = "#fff";
            ctx.fillRect(x,y,2,2);
          }
        }
      }
    ];
    function getCurrentBiome() {
      return biomes[(currentLevel - 1) % biomes.length];
    }

    // =================== Classes ===================
    // --- Player ---
    class Player {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.maxHP = 100;
        this.currentHP = 100;
        this.baseSpeed = 3;
        this.speed = this.baseSpeed;
        // Temporary power‑ups (duration in ms)
        this.activePowerUps = {
          // Double Shot – позволяет одновременно выпускать две пули с небольшим угловым отклонением.
          doubleShot: { duration: 0, stacks: 0 },
          // Triple Shot – позволяет стрелять тремя пулями одновременно, повышая шанс попадания.
          tripleShot: { duration: 0, stacks: 0 },
          // Rapid Fire – ускоряет стрельбу, уменьшая интервал между выстрелами.
          rapidFire: { duration: 0, stacks: 0 },
          // Shield – создает временный защитный щит вокруг игрока, уменьшая получаемый урон
          // от боссов (только половина урона) и полностью блокируя урон от обычных врагов.
          shield: { duration: 0, stacks: 0 },
          // Speed Boost – временно увеличивает скорость передвижения игрока (×2).
          speedBoost: { duration: 0, stacks: 0 },
          // Damage Boost – повышает наносимый урон за счет увеличения силы выстрелов.
          damageBoost: { duration: 0, stacks: 0 },
          // Piercing – пули с этим эффектом могут пробивать нескольких врагов подряд.
          piercing: { duration: 0, stacks: 0 },
          // Homing – пули с автонаведением, корректирующие траекторию в сторону ближайшего врага.
          homing: { duration: 0, stacks: 0 },
          // Bomb – пули, взрывающиеся при попадании и наносящие урон в области взрыва.
          bomb: { duration: 0, stacks: 0 },
          // Freeze Blast – замораживает врагов, снижая их скорость или полностью останавливая их на время.
          freezeBlast: { duration: 0, stacks: 0 },
          // Reflective – пули, которые отскакивают от границ экрана, увеличивая вероятность попадания.
          reflective: { duration: 0, stacks: 0 },
          // Life Steal – при попадании пули возвращают часть здоровья игроку.
          lifeSteal: { duration: 0, stacks: 0 },
          // EMP Blast – пули, которые могут временно оглушать или замедлять врагов, воздействуя на их электронику.
          empBlast: { duration: 0, stacks: 0 },
          // Critical Strike – увеличивает шанс нанести критический урон (например, двойной урон).
          criticalStrike: { duration: 0, stacks: 0 },
          // Overcharge – увеличивает скорость пуль.
          overcharge: { duration: 0, stacks: 0 },
          // Scatter Shot – добавляет +4 пули за каждый стэк.
          scatterShot: { duration: 0, stacks: 0 },
          // *** NEW: временное увеличение здоровья (увеличивает maxHP на +20) ***
          healthBoost: { duration: 0, stacks: 0, bonus: 0 },
          // *** NEW: магнит очков (притягивает коллекционные объекты) ***
          scoreMagnet: { duration: 0, stacks: 0 }
        };
        // Additional status effects (негативные эффекты)
        this.frozenTime = 0;
        this.shootingDisabled = 0;
        this.empSlowed = 0;
        this.angle = 0;
      }
      update(deltaTime) {
        // Обновление таймеров усилений: уменьшаем время и сбрасываем стеки, когда время истекает
        for (let key in this.activePowerUps) {
          if (this.activePowerUps[key].duration > 0) {
            this.activePowerUps[key].duration -= deltaTime;
            if (this.activePowerUps[key].duration <= 0) {
              // Если истёк эффект Health Boost – снимаем бонус с maxHP
              if(key === "healthBoost" && this.activePowerUps[key].bonus) {
                 this.maxHP -= this.activePowerUps[key].bonus;
                 if(this.currentHP > this.maxHP) this.currentHP = this.maxHP;
                 this.activePowerUps[key].bonus = 0;
              }
              this.activePowerUps[key].stacks = 0;
              this.activePowerUps[key].duration = 0;
            }
          }
        }
        // Если игрок заморожен, полностью блокируем движение
        if (this.frozenTime > 0) {
          this.frozenTime -= deltaTime;
          return;  // ранний выход — никаких изменений позиции
        }
        // Вычисляем базовую скорость с учётом постоянного апгрейда и временного ускорения
        let effectiveSpeed = this.baseSpeed * permanentUpgrades.speed;
        if (this.activePowerUps.speedBoost.duration > 0) {
          effectiveSpeed *= 1.8;
        }
        // Если действует EMP замедление, скорость уменьшается (в 2 раза)
        if (this.empSlowed > 0) {
          effectiveSpeed *= 0.5;
          this.empSlowed -= deltaTime;
        }
        let dx = 0, dy = 0;
        if(!isMobile) {
          if(keys["w"]) dy -= 1;
          if(keys["s"]) dy += 1;
          if(keys["a"]) dx -= 1;
          if(keys["d"]) dx += 1;
        } else {
          dx = leftJoystick.dx/(80 * uiScale);
          dy = leftJoystick.dy/(80 * uiScale);
        }
        if(dx || dy) {
          const mag = Math.hypot(dx, dy);
          dx /= mag;
          dy /= mag;
          this.x += dx * effectiveSpeed;
          this.y += dy * effectiveSpeed;
        }
        // Constrain to canvas
        this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(height - this.radius, this.y));
        // Aiming: desktop uses mouse; mobile uses right joystick if active
        if(isMobile && rightJoystick.active && (rightJoystick.dx || rightJoystick.dy)) {
          this.angle = rightJoystick.angle;
        } else {
          this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
        }
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        // Если активирован магнит, отрисовываем область его действия
        if (this.activePowerUps.scoreMagnet && this.activePowerUps.scoreMagnet.duration > 0) {
          let baseAttractionRange = 200; // базовая дистанция (в пикселях)
          let additionalRangePerStack = 100; // прибавка за каждый дополнительный стэк
          let magnetRange = baseAttractionRange + additionalRangePerStack * (this.activePowerUps.scoreMagnet.stacks - 1);

          ctx.beginPath();
          ctx.arc(0, 0, magnetRange, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)'; // полупрозрачный зелёный цвет
          ctx.shadowColor = 'rgba(0, 255, 0, 0.5)';
          ctx.shadowBlur = 5;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        // Используем проверку длительности для щита:
        if(this.activePowerUps.shield.duration > 0) {
          ctx.beginPath();
          ctx.arc(0,0,this.radius+8,0,Math.PI*2);
          ctx.fillStyle = "rgba(0,200,255,0.3)";
          ctx.fill();
        }
        ctx.fillStyle = "#0ff";
        ctx.shadowColor = "#0ff";
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.moveTo(20,0);
        ctx.lineTo(-10,10);
        ctx.lineTo(-10,-10);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    // --- Bullet ---
    class Bullet {
      constructor(x, y, angle, dmgFactor = 1) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 6;
        this.radius = 4;
        this.damage = 1 * permanentUpgrades.damage * dmgFactor;
        // Special properties (default off)
        this.piercing = false;
        this.piercingCount = 0;
        this.homing = false;
        this.bomb = false;
        this.freezeBlast = false;
        this.empBlast = false;
        this.reflective = false;
        this.critical = false;
        this.lifeSteal = false;
        this.fromBoss = false;
        this.dead = false;
        // --- Добавлен счётчик отскоков для reflective пуль ---
        this.bounceCount = 0;
      }
      update(deltaTime) {
        // Homing effect: adjust angle toward nearest enemy
        if(this.homing && enemies.length > 0) {
          let nearest = null, minDist = Infinity;
          for(let enemy of enemies) {
            const dx = enemy.x - this.x, dy = enemy.y - this.y;
            const d = Math.hypot(dx, dy);
            if(d < minDist) { minDist = d; nearest = enemy; }
          }
          if(nearest) {
            const desired = Math.atan2(nearest.y - this.y, nearest.x - this.x);
            this.angle += 0.1 * (desired - this.angle);
          }
        }
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        // --- Обработка отражения reflective пуль ---
        if(this.reflective) {
          let bounced = false;
          if(this.x < this.radius) {
            this.x = this.radius;
            this.angle = Math.PI - this.angle;
            bounced = true;
          } else if(this.x > width - this.radius) {
            this.x = width - this.radius;
            this.angle = Math.PI - this.angle;
            bounced = true;
          }
          if(this.y < this.radius) {
            this.y = this.radius;
            this.angle = -this.angle;
            bounced = true;
          } else if(this.y > height - this.radius) {
            this.y = height - this.radius;
            this.angle = -this.angle;
            bounced = true;
          }
          if(bounced) {
            this.bounceCount++;
            if(this.bounceCount >= 4) { // после 3 отскоков (на 4-ом исчезает)
              this.dead = true;
            }
          }
        }
      }
      draw() {
        ctx.save();
        ctx.fillStyle = (this.fromBoss || this.fromEnemy) ? "#f00" : "#ff0";
        ctx.shadowColor = (this.fromBoss || this.fromEnemy) ? "#f00" : "#ff0";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    // --- Enemy ---
    class Enemy {
      constructor(x, y, type="basic") {
        this.x = x;
        this.y = y;
        this.type = type;
        this.frozenTime = 0;
        this.empTime = 0;
        this.dead = false;
        // Set properties based on type
        switch(type) {
          case "basic":
            this.radius = 15;
            this.speed = 1.5;
            this.hp = 1;
            this.color = "#ff4444";
            break;
          case "elite":  // Танк
            this.radius = 20;
            this.speed = 0.5; // fixed slower speed
            this.hp = 5;
            this.color = "#ff8000";
            break;
          case "freeze":  //Замораживает
            this.radius = 15;
            this.speed = 2.0;
            this.hp = 1;
            this.color = "#00f";
            break;
          case "shooter": // Должен стрелять (исправлено)
            this.radius = 15;
            this.speed = 1.2;
            this.hp = 2;
            this.color = "#f0f";
            this.shootCooldown = 2000;
            this.bulletDamage = 15;  // Новый параметр: урон от пули врага
            break;
          case "parasite":  // Забирает возможность стрелять
            this.radius = 12;
            this.speed = 3.0;
            this.hp = 1;
            this.color = "#0f0";
            break;
          case "emp":
            this.radius = 18;
            this.speed = 1.5;
            this.hp = 2;
            this.color = "#ff0";
            this.shootCooldown = 2500;
            this.bulletDamage = 10;  // Урон от пули emp-врага
            break;
          case "shielded":
            this.radius = 20;
            this.speed = 1.5;
            this.hp = 3;
            this.color = "#0ff";
            this.shield = true;
            this.shieldHP = 5;
            break;
          case "sharpshooter":
            this.radius = 15;
            this.speed = 0.8;
            this.hp = 2;
            this.color = "#608"; // purple tone
            this.shootCooldown = 3000;
            this.bulletDamage = 35;  // Урон от пули sharpshooter
            break;
          case "exploder":
            this.radius = 15;
            this.speed = 1.2;
            this.hp = 1;
            this.color = "#fa0"; // orange
            break;
          case "splitter":
            this.radius = 18;
            this.speed = 1.0;
            this.hp = 3;
            this.color = "#0a0"; // dark green            
            break;
          default:
            this.radius = 15;
            this.speed = 1.5;
            this.hp = 1;
            this.color = "#ff4444";
        }
        // Добавляем усложнение: каждые 3 уровня враги получают +1 к HP
        this.hp += Math.floor(currentLevel / 3);
      }
      update(deltaTime) {
        // If frozen, do not move
        if(this.frozenTime > 0) {
          this.frozenTime -= deltaTime;
          return;
        }
        // Slow down if under EMP effect
        let effSpeed = this.speed;
        if(this.empTime > 0) {
          effSpeed *= 0.5;
          this.empTime -= deltaTime;
        }
        if(this.type === "shooter") {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.hypot(dx, dy);
          const preferredDistance = 250;
          if(dist > preferredDistance) {
            this.shootCooldown -= deltaTime;
            this.x += (dx/dist) * this.speed * (deltaTime/16);
            this.y += (dy/dist) * this.speed * (deltaTime/16);
          } else {
            this.shootCooldown -= deltaTime;
            if(this.shootCooldown <= 0) {
              const angle = Math.atan2(dy, dx);
              let spawnX = this.x + Math.cos(angle) * (this.radius + 5);
              let spawnY = this.y + Math.sin(angle) * (this.radius + 5);
              let b = new Bullet(spawnX, spawnY, angle);
              b.fromEnemy = true;         // Помечаем как пуля врага
              b.speed = 6;
              b.damage = this.bulletDamage; // Урон берётся из врага
              bullets.push(b);
              this.shootCooldown = 2000;
            }
          }
        }
        if(this.type === "emp") {
          this.shootCooldown -= deltaTime;
          if(this.shootCooldown <= 0) {
             let angle = Math.atan2(player.y - this.y, player.x - this.x);
             let b = new Bullet(this.x, this.y, angle);
             b.empBlast = true;
             b.speed = 4;
             b.damage = this.bulletDamage;
             b.fromEnemy = true;  // Помечаем как пуля врага
             bullets.push(b);
             this.shootCooldown = 2500;
          }
        }
        if(this.type === "sharpshooter") {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.hypot(dx, dy);
          const preferredDistance = 550;
          if(dist > preferredDistance) {
            this.shootCooldown -= deltaTime;
            this.x += (dx/dist) * this.speed * (deltaTime/16);
            this.y += (dy/dist) * this.speed * (deltaTime/16);
          } else {
            this.shootCooldown -= deltaTime;
            if(this.shootCooldown <= 0) {
              const angle = Math.atan2(dy, dx);
              let spawnX = this.x + Math.cos(angle) * this.radius;
              let spawnY = this.y + Math.sin(angle) * this.radius;
              let b = new Bullet(spawnX, spawnY, angle);
              b.fromEnemy = true;        // Помечаем как пуля врага
              b.radius = 8;
              b.speed = 7;
              b.damage = this.bulletDamage;
              bullets.push(b);
              this.shootCooldown = 3000;
            }
          }
        }
        // Для остальных врагов – стандартное движение (как было)
        if(this.type !== "shooter" && this.type !== "sharpshooter") {
          const dx = player.x - this.x, dy = player.y - this.y;
          const dist = Math.hypot(dx,dy);
          if(dist !== 0) {
            this.x += (dx/dist) * effSpeed;
            this.y += (dy/dist) * effSpeed;
          }
        }
      }
      draw() {
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fillStyle = this.color;
        ctx.fill();
        // If frozen, overlay with a semi‑transparent blue tint
        if(this.frozenTime > 0) {
          ctx.fillStyle = "rgba(0,200,255,0.5)";
          ctx.fill();
        }
        if(this.type === "shielded" && this.shield) {
           // Draw a white outline to indicate the protective shield.
           ctx.strokeStyle = "#fff";
           ctx.lineWidth = 3;
           ctx.beginPath();
           ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI*2);
           ctx.stroke();
        }
        ctx.restore();
      }
    }

    // --- Boss ---
    class Boss {
      // Добавляем параметры x и y, чтобы можно было задавать позицию спавна
      constructor(x, y) {
        // Если координаты заданы, используем их, иначе стандартно центр по горизонтали и y = 100
        this.x = (typeof x === 'number') ? x : width / 2;
        this.y = (typeof y === 'number') ? y : 100;
        
        // Базовый размер босса
        this.baseRadius = 60 / Math.pow(2, Math.floor((currentLevel - 1) / 5));
        this.radius = this.baseRadius;
        
        // Базовые HP и скорость
        this.bossBaseHP = 50;
        let bossDifficulty = currentLevel < 4 ? 0.6 : 1;
        this.maxHP = Math.floor((this.bossBaseHP + currentLevel * 25) * bossDifficulty);
        this.hp = this.maxHP;
        this.speed = (1 + currentLevel * 0.1) * bossDifficulty;
        
        // Определяем титул босса
        if (currentLevel % 15 === 0) this.tier = "Emperor";
        else if (currentLevel % 10 === 0) this.tier = "Champion";
        else if (currentLevel % 5 === 0) this.tier = "Elite";
        else this.tier = "Easy";
        
        // Вместо одного shootCooldown используем массив для всех 5 паттернов
        this.shootCooldown = 3000;
        // --- Добавлен параметр для замедления от Freeze Blast ---
        this.freezeSlow = 0;
      }

      update(deltaTime) {
        // Определяем максимальную стадию, доступную на текущем уровне:
        const maxStage = ((currentLevel - 1) % 5) + 1;
        // Вычисляем соотношение оставшегося здоровья:
        const hpRatio = this.hp / this.maxHP;
        // По умолчанию boss находится на самой "низкой" стадии (максимальное число)
        let stage = maxStage;
        // Для maxStage=5 пороговые значения: >0.8 → stage 1, >0.6 → stage 2, >0.4 → stage 3, >0.2 → stage 4, иначе 5.
        // Для меньшего maxStage масштабируем пороги пропорционально.
        for (let s = 1; s < maxStage; s++) {
          if (hpRatio > (maxStage - s) / maxStage) {
            stage = s;
            break;
          }
        }
        // Теперь stage изменяется от 1 (при почти полном HP) до maxStage (при критически малом HP).
      
        // --- Шаг 1: Определяем эффективную скорость с учётом эффекта Freeze Blast ---
        let effectiveSpeed = this.speed;
        if(this.freezeSlow > 0) {
          effectiveSpeed *= 0.5;
          this.freezeSlow -= deltaTime;
        }
      
        // --- Движение босса ---
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist !== 0) {
          let currentSpeed = effectiveSpeed;
          if (stage >= 4) currentSpeed *= 1.2;
          this.x += (dx / dist) * currentSpeed;
          this.y += (dy / dist) * currentSpeed;
        }
        // Добавляем небольшое колебание: если достигнута максимальная (самая "низкая") стадия и она равна 5,
        // добавляем дрожание, иначе — небольшое косинусоидальное смещение.
        if (stage === 5) {
          this.x += (Math.random() - 0.5) * 5;
          this.y += (Math.random() - 0.5) * 5;
        } else {
          this.x += Math.cos(performance.now() / 500) * 0.5;
        }
      
        // --- Шаблоны стрельбы в зависимости от стадии ---
        this.shootCooldown -= deltaTime;
        if (this.shootCooldown <= 0) {
          if (stage === 1) {
            const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
            for (let offset of [-0.1, 0, 0.1]) {
              let b = new Bullet(this.x, this.y, baseAngle + offset);
              b.fromBoss = true;
              b.speed = 5;
              b.damage = 20;
              bullets.push(b);
            }
            this.shootCooldown = 3000;
          } else if (stage === 2) {
            const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
            for (let offset of [-0.2, -0.1, 0, 0.1, 0.2]) {
              let b = new Bullet(this.x, this.y, baseAngle + offset);
              b.fromBoss = true;
              b.speed = 6;
              b.damage = 25;
              bullets.push(b);
            }
            this.shootCooldown = 2000;
          } else if (stage === 3) {
            const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
            for (let offset of [-0.1, 0, 0.1]) {
              let b = new Bullet(this.x, this.y, baseAngle + offset);
              b.fromBoss = true;
              b.speed = 6;
              b.damage = 30;
              b.homing = true;
              bullets.push(b);
            }
            this.shootCooldown = 1000;
          } else if (stage === 4) {
            for (let i = 0; i < 8; i++) {
              let angle = i * (Math.PI * 2 / 8);
              let b = new Bullet(this.x, this.y, angle);
              b.fromBoss = true;
              b.speed = 7;
              b.damage = 20;
              bullets.push(b);
            }
            this.shootCooldown = 500;
          } else if (stage === 5) {
            const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
            for (let offset of [-0.3, -0.15, 0, 0.15, 0.3]) {
              let b = new Bullet(this.x, this.y, baseAngle + offset);
              b.fromBoss = true;
              b.speed = 8;
              b.damage = 35;
              bullets.push(b);
            }
            this.shootCooldown = 150;
          }
        }
      }
      
      draw() {
        ctx.save();
        // Цвет босса в зависимости от оставшегося HP
        let bossColor = "#ff0";
        if (this.hp < this.maxHP * 0.7) bossColor = "#ff6600";
        if (this.hp < this.maxHP * 0.4) bossColor = "#f00";
        
        ctx.fillStyle = bossColor;
        ctx.shadowColor = bossColor;
        ctx.shadowBlur = 30;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Отрисовка полосы HP босса.
        // Если босс один – стандартное положение (y = 20).
        // Если боссов несколько – для босса с индексом i полоса смещается на i*30 пикселей вниз.
        let index = bosses.indexOf(this);
        const barWidth = 300, barHeight = 20;
        let barY = 20 + index * 47;
        ctx.fillStyle = "#222";
        ctx.fillRect(width / 2 - (barWidth * uiScale) / 2, barY * uiScale, barWidth * uiScale, barHeight * uiScale);
        ctx.fillStyle = bossColor;
        const hpWidth = barWidth * (this.hp / this.maxHP);
        ctx.fillRect(width / 2 - (barWidth * uiScale) / 2, barY * uiScale, hpWidth * uiScale, barHeight * uiScale);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(width / 2 - (barWidth * uiScale) / 2, barY * uiScale, barWidth * uiScale, barHeight * uiScale);
        
        ctx.fillStyle = "#fff";
        ctx.font = (18 * uiScale) + "px Arial";
        ctx.fillText(this.tier + " Boss", (width / 2 - 40) * uiScale, (barY - 5) * uiScale);
      }
    }

    // --- Collectible ---
    class Collectible {
      constructor(x,y) {
        this.x = x;
        this.y = y;
        this.radius = 8;
        this.angle = Math.random()*Math.PI*2;
      }
      update(deltaTime) {
        this.angle += 0.005 * deltaTime;
        // *** Измененный механизм притягивания коллекционных предметов ***
        if (
          player &&
          player.activePowerUps.scoreMagnet &&
          player.activePowerUps.scoreMagnet.duration > 0
        ) {
          let dx = player.x - this.x;
          let dy = player.y - this.y;
          let dist = Math.hypot(dx, dy);
    
          // Параметры притяжения: базовая дистанция и прирост дистанции с каждым стэком
          let baseAttractionRange = 200; // базовая дистанция притяжения (в пикселях)
          let additionalRangePerStack = 100; // прибавка к дистанции за каждый дополнительный стэк
          // Вычисляем общую дистанцию притяжения в зависимости от количества стэков
          let attractionRange =
            baseAttractionRange +
            additionalRangePerStack * (player.activePowerUps.scoreMagnet.stacks - 1);
    
          // Если объект находится в пределах дистанции притяжения, притягиваем его
          if (dist < attractionRange) {
            let baseAttractSpeed = 1; // базовая скорость притяжения
            // Увеличиваем скорость притяжения пропорционально количеству стэков
            let attractSpeed = baseAttractSpeed * player.activePowerUps.scoreMagnet.stacks * deltaTime;
            this.x += (dx / dist) * attractSpeed;
            this.y += (dy / dist) * attractSpeed;
          }
        }
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = "#0f0";
        ctx.shadowColor = "#0f0";
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(0,0,this.radius,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    // --- Particle ---
    class Particle {
      constructor(x,y,color) {
        this.x = x;
        this.y = y;
        this.radius = Math.random()*3 + 2;
        this.angle = Math.random()*Math.PI*2;
        this.speed = Math.random()*2 + 1;
        this.life = 100;
        this.color = color;
      }
      update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life -= 2;
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = Math.max(this.life/100,0);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    // =================== Global Objects & Arrays ===================
    // (Массивы и переменные уже объявлены выше)

    // =================== Utility Function ===================
    function circleCollision(a, b) {
      if (!a || !b) return false;
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx, dy) < a.radius + b.radius;
    }

    // =================== Spawning Functions ===================
    function spawnEnemy() {
      let x, y;
      const edge = Math.floor(Math.random() * 4);
      if (edge === 0) { x = Math.random() * width; y = -30; }
      else if (edge === 1) { x = width + 30; y = Math.random() * height; }
      else if (edge === 2) { x = Math.random() * width; y = height + 30; }
      else { x = -30; y = Math.random() * height; }
      let r = Math.random();
      let type = "basic";
      if(r < 0.35)          type = "basic";
      else if(r < 0.50)     type = "elite";
      else if(r < 0.60)     type = "freeze";
      else if(r < 0.70)     type = "shooter";
      else if(r < 0.75)     type = "sharpshooter";
      else if(r < 0.80)     type = "parasite";
      else if(r < 0.85)     type = "emp";
      else if(r < 0.92)     type = "exploder";
      else                   type = "splitter";
      enemies.push(new Enemy(x, y, type));
    }
    function spawnCollectible(x,y) {
      if(Math.random()<0.5) {
        collectibles.push(new Collectible(x,y));
      }
    }
    /******************************************
     **  BUTTON P: SPAWN 2 BOSSES (LEVEL 7)    **
     ******************************************/
    function spawnTwoBosses() {
      if(gameState !== "playing") return;
      let bossCount = 2;  // как для 7 уровня
      let baseRadius = 60;
      if(currentLevel > 5) baseRadius *= 0.5;
      let spawnCircleRadius = baseRadius / Math.sin(Math.PI / bossCount);
      let centerX = width / 2;
      let centerY = 100;
      for (let i = 0; i < bossCount; i++) {
         let angle = (2 * Math.PI * i) / bossCount;
         let bossX = centerX + spawnCircleRadius * Math.cos(angle);
         let bossY = centerY + spawnCircleRadius * Math.sin(angle);
         bosses.push(new Boss(bossX, bossY));
      }
    }
    function givePlayerMagnetEffect() {
      if (player) {
    
        let bonusHealth = 50;
          if (player.activePowerUps.healthBoost.duration <= 0) {
              player.activePowerUps.healthBoost.duration = powerUpDurations["Health Boost"] || 25000;
              player.activePowerUps.healthBoost.stacks = 1;
              player.activePowerUps.healthBoost.bonus = bonusHealth;
          } else {
              player.activePowerUps.healthBoost.duration += powerUpDurations["Health Boost"] || 25000;
              player.activePowerUps.healthBoost.stacks += 1;
              player.activePowerUps.healthBoost.bonus += bonusHealth;
          }
          player.maxHP += bonusHealth;
          player.currentHP += bonusHealth;
      }
    }

    // =================== Power‑Up Mapping ===================
    // This mapping ensures that "Double Shot" becomes the property "doubleShot" etc.
    const powerUpMap = {
      "Double Shot": "doubleShot",
      "Triple Shot": "tripleShot",
      "Rapid Fire": "rapidFire",
      "Shield": "shield",
      "Speed Boost": "speedBoost",
      "Damage Boost": "damageBoost",
      "Piercing": "piercing",
      "Homing": "homing",
      "Bomb": "bomb",
      "Freeze Blast": "freezeBlast",
      "Reflective": "reflective",
      "Life Steal": "lifeSteal",
      "EMP Blast": "empBlast",
      "Critical Strike": "criticalStrike",
      "Overcharge": "overcharge",
      "Scatter Shot": "scatterShot",
      "Health Boost": "healthBoost",          // *** NEW: временное увеличение здоровья (увеличивает maxHP на +20) ***
      "Restore Health": "healthRestore",       // *** NEW: мгновенное Restore Health
      "Magnet": "scoreMagnet"            // *** NEW: притягивает коллекционные объекты (25с)
    };

    // =================== Temporary Power‑Up Pool & Durations ===================
    const powerUpPool = [
      "Double Shot", "Triple Shot", "Rapid Fire", "Shield", "Speed Boost",
      "Damage Boost", "Piercing", "Homing", "Bomb", "Freeze Blast",
      "Reflective", "Life Steal", "EMP Blast", "Critical Strike", "Overcharge",
      "Scatter Shot",
      "Health Boost", "Restore Health", "Magnet"  // *** NEW: добавленные варианты
    ];
    const powerUpDurations = {
      "Reflective": 10000, // 10 секунд для Reflective
      "Triple Shot": 28000,
      "Double Shot": 35000,
      "Shield": 25000,
      "EMP Blast": 40000,
      "Health Boost": 25000,         // *** NEW: 25 секунд
      "Magnet": 25000          // *** NEW: 25 секунд
      // Для "Restore Health" временная длительность не нужна (эффект мгновенный)
    };

    // =================== Temporary Power‑Up Selection ===================
    function showPowerUpMenu() {
      gameState = "powerup";
      const overlay = document.getElementById("overlay");
      const case_to_much_bullets = (player.activePowerUps.tripleShot.stacks >= 2 || player.activePowerUps.doubleShot.stacks >= 3 || player.activePowerUps.scatterShot.stacks >= 3);
      const case_to_much_magnet = (player.activePowerUps.scoreMagnet.stacks >= 3)
      // Фильтруем pool: исключаем усиления, у которых игрок уже достиг максимума стаков
      const availablePool = powerUpPool.filter(choice => {
        if (!player) return true; // на всякий случай
        if (choice === "Triple Shot" && case_to_much_bullets) return false;
        if (choice === "Double Shot" && case_to_much_bullets) return false;
        if (choice === "Scatter Shot" && case_to_much_bullets) return false;
        if (choice === "Magnet" && case_to_much_magnet) return false;
        return true;
      });

      let options = [];
      while (options.length < 3 && availablePool.length > 0) {
        let randomIndex = Math.floor(Math.random() * availablePool.length);
        let choice = availablePool[randomIndex];
        if (!options.includes(choice)) {
          options.push(choice);
        }
      }

      // Если по каким-то причинам список пустой – можно сразу возобновить игру
      if(options.length === 0) {
        resumeGame();
        return;
      }

      overlay.innerHTML = `<h1>Power-Up Ready!</h1>
        <p>Choose one temporary power-up:</p>
        <div>
          ${options.map((option, index) => `<button class="button" id="pu${index+1}">${option}</button>`).join("")}
        </div>`;
      overlay.classList.remove("hidden");
      options.forEach((option, index) => {
        document.getElementById("pu" + (index + 1))
          .addEventListener("click", () => applyPowerUp(option));
      });
    }
    // =================== Функция применения усиления ===================
    function applyPowerUp(choice) {
      // *** NEW: При выборе "Restore Health" – мгновенное восстановление 30 HP (учитывая текущий maxHP) ***
      if (choice === "Restore Health") {
          player.currentHP = Math.min(player.maxHP, player.currentHP + 30);
      } else if (choice === "Health Boost") {
          // Изменено: теперь Health Boost даёт бонус +50 к maxHP и +50 к текущему здоровью
          let bonusHealth = 50;
          if (player.activePowerUps.healthBoost.duration <= 0) {
              player.activePowerUps.healthBoost.duration = powerUpDurations["Health Boost"] || 25000;
              player.activePowerUps.healthBoost.stacks = 1;
              player.activePowerUps.healthBoost.bonus = bonusHealth;
          } else {
              player.activePowerUps.healthBoost.duration += powerUpDurations["Health Boost"] || 25000;
              player.activePowerUps.healthBoost.stacks += 1;
              player.activePowerUps.healthBoost.bonus += bonusHealth;
          }
          player.maxHP += bonusHealth;
          player.currentHP += bonusHealth;
      } else {
        const key = powerUpMap[choice];
        if (key && player) {
          const durationToAdd = powerUpDurations[choice] || 30000;
          if (player.activePowerUps[key].duration <= 0) {
            player.activePowerUps[key] = { duration: durationToAdd, stacks: 1 };
          } else {
            player.activePowerUps[key].duration += durationToAdd;
            player.activePowerUps[key].stacks += 1;
          }
        }
      }
      powerMeter = 0;
      resumeGame();
    }

    // =================== Permanent Upgrade (Level Transition) ===================
    function showTransitionMenu() {
      gameState = "transition";
      const overlay = document.getElementById("overlay");
    
      // Определяем список возможных перманентных улучшений с их весами (относительные вероятности)
      const upgrades = [
        { id: "upgDamage", name: "Damage Up", weight: 40 },
        { id: "upgSpeed", name: "Speed Up", weight: 30 },
        { id: "upgFireRate", name: "Fire Rate Up", weight: 20 },
        { id: "upgHealth", name: "Health Up", weight: 10 }
      ];
    
      // Выбираем 3 уникальных улучшения с учётом их весов
      const chosenUpgrades = [];
      const availableUpgrades = [...upgrades]; // создаём копию массива, чтобы не менять исходный список
      for (let i = 0; i < 3; i++) {
        // Вычисляем суммарный вес для оставшихся улучшений
        const totalWeight = availableUpgrades.reduce((sum, upg) => sum + upg.weight, 0);
        let random = Math.random() * totalWeight;
        let selectedIndex = 0;
        // Ищем случайное улучшение согласно весам
        for (let j = 0; j < availableUpgrades.length; j++) {
          random -= availableUpgrades[j].weight;
          if (random < 0) {
            selectedIndex = j;
            break;
          }
        }
        chosenUpgrades.push(availableUpgrades[selectedIndex]);
        availableUpgrades.splice(selectedIndex, 1); // удаляем выбранное, чтобы избежать повторения
      }
    
      // Формируем HTML с кнопками для выбранных улучшений
      const buttonsHTML = chosenUpgrades
        .map(upg => `<button class="button" id="${upg.id}">${upg.name}</button>`)
        .join("");
      overlay.innerHTML = `<h1>Level ${currentLevel} Complete!</h1>
        <p>Choose your permanent upgrade:</p>
        <div>${buttonsHTML}</div>`;
      overlay.classList.remove("hidden");
    
      // Назначаем обработчики событий для каждой кнопки
      chosenUpgrades.forEach(upg => {
        document.getElementById(upg.id).addEventListener("click", () => {
          switch (upg.name) {
            case "Damage Up":
              permanentUpgrades.damage += 0.5;
              break;
            case "Speed Up":
              permanentUpgrades.speed += 0.2;
              break;
            case "Fire Rate Up":
              permanentUpgrades.fireRate += 0.5;
              break;
            case "Health Up":
              permanentUpgrades.health += 15;
              if (player) {
                player.maxHP += 15;
                player.currentHP += 15;
              }
              break;
          }
          nextLevel();
        });
      });
    }
    function nextLevel() {
      currentLevel++;
      levelTimer = levelDuration;
      enemySpawnTimer = 0;
      // Очищаем массивы
      enemies.length = 0;
      bullets.length = 0;
      collectibles.length = 0;
      particles.length = 0;
      bosses.length = 0;
      resumeGame();
    }

    // =================== Pause & Game Over ===================
    function pauseGame() {
      if(gameState === "playing") {
        gameState = "pause";
        const overlay = document.getElementById("overlay");
        overlay.innerHTML = `<h1>Paused</h1>
          <div>
            <button class="button" id="resumeBtn">Resume</button>
            <button class="button" id="restartBtn">Restart</button>
            <button class="button" id="menuBtn">Main Menu</button>
          </div>`;
        overlay.classList.remove("hidden");
        document.getElementById("resumeBtn").addEventListener("click", resumeGame);
        document.getElementById("restartBtn").addEventListener("click", restartGame);
        document.getElementById("menuBtn").addEventListener("click", mainMenu);
      }
    }
    function resumeGame() {
      if(gameState !== "playing") {
        gameState = "playing";
        document.getElementById("overlay").classList.add("hidden");
      }
    }
    function restartGame() {
      score = 0;
      currentLevel = 1;
      levelTimer = levelDuration;
      permanentUpgrades.damage = 1;
      permanentUpgrades.speed = 1;
      permanentUpgrades.fireRate = 1;
      permanentUpgrades.health = 0;   // *** NEW: сброс здоровья ***
      powerMeter = 0;
      enemySpawnTimer = 0;
      fireCooldown = 0;
      enemies.length = 0;
      bullets.length = 0;
      collectibles.length = 0;
      particles.length = 0;
      bosses.length = 0;
      player = new Player(width/2, height/2);
      player.maxHP = 100 + permanentUpgrades.health;  // *** NEW: учитываем перманентное здоровье
      player.currentHP = player.maxHP;
      resumeGame();
    }
    function mainMenu() {
      gameState = "menu";
      document.getElementById("overlay").innerHTML = `<h1>Neon Nexus: Ultimate Gauntlet</h1>
      <p id="overlayText">Move with WASD, aim with your mouse (or use on‑screen joysticks on mobile), and auto‑fire is enabled.<br>
         Fill your power meter by defeating enemies and choose temporary power‑ups.<br>
         Survive waves and defeat bosses to earn permanent upgrades!</p>
      <p id="startHint">${isMobile ? "Tap anywhere" : "Press SPACE"} to begin</p>`;
      document.getElementById("overlay").classList.remove("hidden");
    }
    function showGameOver() {
      gameState = "gameover";
      const overlay = document.getElementById("overlay");
      overlay.innerHTML = `<h1>Game Over</h1>
        <p>Your Score: ${Math.floor(score)}</p>
        <p>${isMobile ? "Tap anywhere" : "Press SPACE"} to restart</p>`;
      overlay.classList.remove("hidden");
    }

    // =================== Main Game Loop ===================
    let lastTime = performance.now();
    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      update(deltaTime);
      draw();
      requestAnimationFrame(gameLoop);
    }

    // =================== Update Function ===================
    function update(deltaTime) {
      if(gameState !== "playing") return;
      score += deltaTime * 0.05;
      // Спавн босса (или боссов) после истечения таймера
      if (bosses.length === 0) {
        levelTimer -= deltaTime;
        if (levelTimer <= 0) {
          // Определяем количество боссов:
          // Если уровень <= 5 – один босс, а дальше удачи
          let bossCount = Math.pow(2, Math.floor((currentLevel - 1) / 5));
          
          // Если один босс – стандартный спавн
          if (bossCount === 1) {
            bosses.push(new Boss());
          } else {
            // Вычисляем базовый радиус, который уже учитывает уменьшение при currentLevel > 5
            let baseRadius = 60;
            if (currentLevel > 5) baseRadius *= 0.5;
            // Для равномерного расположения вычисляем радиус окружности так,
            // чтобы расстояние между центрами соседних боссов было равно 2 * baseRadius.
            let spawnCircleRadius = baseRadius / Math.sin(Math.PI / bossCount);
            
            // Центр спавна (можно изменить по желанию)
            let centerX = width / 2;
            let centerY = 100;
            
            for (let i = 0; i < bossCount; i++) {
              let angle = (2 * Math.PI * i) / bossCount;
              let bossX = centerX + spawnCircleRadius * Math.cos(angle);
              let bossY = centerY + spawnCircleRadius * Math.sin(angle);
              bosses.push(new Boss(bossX, bossY));
            }
          }
        }
      }
      if(player) {
        if(player.shootingDisabled > 0) player.shootingDisabled -= deltaTime;
        player.update(deltaTime);
      }
      // Adjust fire rate (rapid fire and EMP effects)
      let effectiveFireRate = BASE_FIRE_RATE / permanentUpgrades.fireRate;
      if(player.activePowerUps.rapidFire.duration > 0) effectiveFireRate /= 2;
      if(player.empSlowed > 0) {
        effectiveFireRate *= 1.5;
        player.empSlowed -= deltaTime;
      }
      // Изменённая логика автострельбы с учётом стэков усилений
      if (player && player.shootingDisabled <= 0) {
        fireCooldown -= deltaTime;
        if (fireCooldown <= 0) {
          fireCooldown = effectiveFireRate;
          const bx = player.x + Math.cos(player.angle) * 20;
          const by = player.y + Math.sin(player.angle) * 20;
          // Вычисляем коэффициент урона: damageBoost увеличивает урон на +1 за каждый стэк
          let dmgFactor = 1;
          if (player.activePowerUps.damageBoost.duration > 0) {
            dmgFactor = 1 + player.activePowerUps.damageBoost.stacks;
          }
          // Новая логика для подсчёта количества пуль:
          // Базово 1 пуля, но если активны усиления Double Shot и/или Triple Shot – применяем мультипликативный эффект
          let bulletCount = 1;
          let totalSpread = 0;
          // Если Double Shot активен, умножаем количество пуль на 2 для каждого стэка
          if (player.activePowerUps.doubleShot.duration > 0) {
            bulletCount *= Math.pow(2, player.activePowerUps.doubleShot.stacks);
            totalSpread += 0.1 * player.activePowerUps.doubleShot.stacks;
          }
          // Если Triple Shot активен, умножаем количество пуль на 3 для каждого стэка
          if (player.activePowerUps.tripleShot.duration > 0) {
            bulletCount *= Math.pow(3, player.activePowerUps.tripleShot.stacks);
            totalSpread += 0.15 * player.activePowerUps.tripleShot.stacks;
          }
          // Scatter Shot теперь добавляет +4 пули за каждый стэк
          if (player.activePowerUps.scatterShot.duration > 0) {
            bulletCount += 4 * player.activePowerUps.scatterShot.stacks;
            totalSpread += 0.3 * player.activePowerUps.scatterShot.stacks;
          }
          // Overcharge теперь не влияет на число пуль, а ускоряет их – поэтому здесь не модифицируем bulletCount
          let newBullets = [];
          if (bulletCount > 1) {
            let startAngle = player.angle - totalSpread / 2;
            let angleStep = bulletCount > 1 ? totalSpread / (bulletCount - 1) : 0;
            for (let i = 0; i < bulletCount; i++) {
              let angle = startAngle + i * angleStep;
              let b = new Bullet(bx, by, angle, dmgFactor);
              // Применяем остальные свойства пули в зависимости от активных усилений
              if (player.activePowerUps.piercing.duration > 0) {
                b.piercing = true;
                b.piercingCount = 3 * player.activePowerUps.piercing.stacks;
              }
              if (player.activePowerUps.homing.duration > 0) {
                b.homing = true;
              }
              if (player.activePowerUps.bomb.duration > 0) {
                b.bomb = true;
              }
              if (player.activePowerUps.freezeBlast.duration > 0) {
                b.freezeBlast = true;
              }
              if (player.activePowerUps.empBlast.duration > 0) {
                b.empBlast = true;
              }
              if (player.activePowerUps.reflective.duration > 0) {
                b.reflective = true;
              }
              if (player.activePowerUps.criticalStrike.duration > 0) {
                b.critical = true;
                if (Math.random() < 0.2 * player.activePowerUps.criticalStrike.stacks) {
                  b.damage *= 3;
                }
              }
              if (player.activePowerUps.lifeSteal.duration > 0) {
                b.lifeSteal = true;
              }
              if (player.activePowerUps.overcharge.duration > 0) {
                  b.speed *= (1 + 0.5 * player.activePowerUps.overcharge.stacks);
              }
              newBullets.push(b);
            }
          } else {
            let b = new Bullet(bx, by, player.angle, dmgFactor);
            if (player.activePowerUps.piercing.duration > 0) {
              b.piercing = true;
              b.piercingCount = 3 * player.activePowerUps.piercing.stacks;
            }
            if (player.activePowerUps.homing.duration > 0) {
              b.homing = true;
            }
            if (player.activePowerUps.bomb.duration > 0) {
              b.bomb = true;
            }
            if (player.activePowerUps.freezeBlast.duration > 0) {
              b.freezeBlast = true;
            }
            if (player.activePowerUps.empBlast.duration > 0) {
              b.empBlast = true;
            }
            if (player.activePowerUps.reflective.duration > 0) {
              b.reflective = true;
            }
            if (player.activePowerUps.criticalStrike.duration > 0) {
              b.critical = true;
              if (Math.random() < 0.2 * player.activePowerUps.criticalStrike.stacks) {
                b.damage *= 2;
              }
            }
            if (player.activePowerUps.lifeSteal.duration > 0) {
              b.lifeSteal = true;
            }
            if (player.activePowerUps.overcharge.duration > 0) {
                b.speed *= (1 + 0.5 * player.activePowerUps.overcharge.stacks);
            }
            newBullets.push(b);
          }
          newBullets.forEach(b => bullets.push(b));
        }
      }

      // Обновляем пули
      for(let i = bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        b.update(deltaTime);
        if(!b.reflective && (b.x < -10 || b.x > width+10 || b.y < -10 || b.y > height+10)) {
          b.dead = true;
        }
      }
      // Спавн врагов (если не идёт бой с боссом)
      if(bosses.length === 0) {
        enemySpawnTimer += deltaTime;
        if(enemySpawnTimer > enemySpawnInterval) {
          enemySpawnTimer = 0;
          spawnEnemy();
        }
        enemySpawnInterval = Math.max(500,1500 - score/10);
      }
      // Обновляем врагов
      for(let i = enemies.length-1; i>=0; i--) {
        enemies[i].update(deltaTime);
        if(circleCollision(enemies[i], player)) {
          // --- Изменено: если щит активен, урон от обычных врагов блокируется полностью ---
          if(player.activePowerUps.shield.duration > 0) {
            enemies[i].dead = true;
          } else {
            let damage = 20;
            if(enemies[i].type === "freeze") { player.frozenTime = 2000; damage = 10; }
            else if(enemies[i].type === "parasite") { player.shootingDisabled = 2000; damage = 10; }
            else if(enemies[i].type === "emp") { player.empSlowed = 2000; damage = 15; }
            player.currentHP -= damage;
            // --- Добавлено: отображение полученного урона красным цветом ---
            damageTexts.push({ x: player.x, y: player.y, damage: damage, alpha: 1, lifetime: 1000 });
            if(player.currentHP <= 0) { gameState = "gameover"; showGameOver(); }
            enemies[i].dead = true;
          }
        }
      }
      // Обновляем боссов
      for(let i = bosses.length - 1; i >= 0; i--) {
        bosses[i].update(deltaTime);
        // --- Изменено: при столкновении с боссом проверяем наличие щита.
        if(circleCollision(bosses[i], player)) {
          if (player.activePowerUps.shield.duration > 0) {
            // Если щит активен – уменьшаем его оставшееся время на 1 секунду (1000 мс)
            player.activePowerUps.shield.duration = Math.max(0, player.activePowerUps.shield.duration - 100);
            // Можно отобразить специальное сообщение об уменьшении времени щита:
            damageTexts.push({ x: player.x, y: player.y, damage: "Shield -0.1s", alpha: 1, lifetime: 1000 });
          } else {
            // Если щита нет – наносим обычный урон от босса (30 единиц)
            let bossDamage = 30;
            player.currentHP -= bossDamage;
            damageTexts.push({ x: player.x, y: player.y, damage: bossDamage, alpha: 1, lifetime: 1000 });
            if (player.currentHP <= 0) {
              gameState = "gameover";
              showGameOver();
            }
          }
        }
        if(bosses[i].hp <= 0) {
          score += 1000;
          bosses.splice(i, 1);
          if(bosses.length === 0) {
            showTransitionMenu();
          }
        }
      }
      // Обновляем коллекционные предметы
      for(let i = collectibles.length-1; i>=0; i--) {
        collectibles[i].update(deltaTime);
        if(circleCollision(collectibles[i], player)) {
          powerMeter = Math.min(POWER_METER_MAX, powerMeter+20);
          collectibles.splice(i,1);
        }
      }
      // Обновляем частицы
      for(let i = particles.length-1; i>=0; i--) {
        particles[i].update();
        if(particles[i].life <= 0) { particles.splice(i,1); }
      }
      // Обработка столкновений пуль с врагами
      for(let i = enemies.length-1; i>=0; i--) {
        for(let j = bullets.length-1; j>=0; j--) {
          let b = bullets[j];
          if(b.fromEnemy || b.fromBoss) continue;  // только пули игрока
          if(circleCollision(enemies[i], b)) {
            // Если пуля с бомбой – наносим урон всем врагам в радиусе
            if(b.bomb) {
              const bombRadius = 80;
              for(let k = enemies.length - 1; k >= 0; k--){
                const dx = enemies[k].x - b.x;
                const dy = enemies[k].y - b.y;
                if(Math.hypot(dx,dy) < bombRadius) {
                  enemies[k].hp -= b.damage;
                  const pushStrength = 8;
                  const impactAngle = Math.atan2(enemies[k].y - b.y, enemies[k].x - b.x);
                  enemies[k].x += Math.cos(impactAngle) * pushStrength;
                  enemies[k].y += Math.sin(impactAngle) * pushStrength;
                  if(enemies[k].hp <= 0) {
                    if(enemies[k].type === "exploder") {
                      for(let m = enemies.length - 1; m >= 0; m--){
                        const dx2 = enemies[m].x - enemies[k].x;
                        const dy2 = enemies[m].y - enemies[k].y;
                        if(Math.hypot(dx2,dy2) < 50) {
                           enemies[m].hp -= 5;
                        }
                      }
                      for(let m = 0; m < 20; m++){
                        particles.push(new Particle(enemies[k].x, enemies[k].y, "#fa0"));
                      }
                    }
                    if(enemies[k].type === "splitter") {
                      enemies.push(new Enemy(enemies[k].x, enemies[k].y, "basic"));
                      enemies.push(new Enemy(enemies[k].x, enemies[k].y, "basic"));
                    }
                    spawnCollectible(enemies[k].x, enemies[k].y);
                    score += (enemies[k].type==="elite")?200:100;
                    enemies.splice(k,1);
                  }
                }
              }
              for(let k = 0; k < 20; k++){
                particles.push(new Particle(b.x, b.y, "#f00"));
              }
              b.dead = true;
              continue;
            }
            if(enemies[i].type === "shielded" && enemies[i].shield && enemies[i].shieldHP > 0) {
                // Shielded enemy: subtract damage from shield first.
                enemies[i].shieldHP -= b.damage;
            } else {
                enemies[i].hp -= b.damage;
            }
            // Push enemy away from impact
             let pushStrength = 10; // adjust as needed
             let impactAngle = Math.atan2(enemies[i].y - b.y, enemies[i].x - b.x);
             enemies[i].x += Math.cos(impactAngle) * pushStrength;
             enemies[i].y += Math.sin(impactAngle) * pushStrength;
             // Spawn blood particles effect for enemy hit
             for (let blood = 0; blood < 8; blood++) {
               particles.push(new Particle(b.x, b.y, enemies[i].color));
             }
            if(b.freezeBlast) { 
                enemies[i].frozenTime = Math.max(enemies[i].frozenTime, 3000);
            }
            if(b.empBlast) { enemies[i].empTime = Math.max(enemies[i].empTime, 3000); }
            if(b.lifeSteal) { player.currentHP = Math.min(player.maxHP, player.currentHP + b.damage); }
            if(b.piercing) {
              b.piercingCount--;
              if(b.piercingCount <= 0) { b.dead = true; }
            } else { b.dead = true; }
            if(enemies[i].hp <= 0) {
              if(enemies[i].type === "exploder") {
                // When an exploder dies, it explodes—damaging nearby enemies.
                for(let k=0; k<enemies.length; k++){
                  const dx = enemies[k].x - enemies[i].x;
                  const dy = enemies[k].y - enemies[i].y;
                  if(Math.hypot(dx,dy) < 50) {
                     enemies[k].hp -= 5;
                  }
                }
                for(let k=0; k<20; k++){
                  particles.push(new Particle(enemies[i].x, enemies[i].y, "#fa0"));
                }
              }
              if(enemies[i].type === "splitter") {
                // Splitter splits into two basic enemies when killed.
                enemies.push(new Enemy(enemies[i].x, enemies[i].y, "basic"));
                enemies.push(new Enemy(enemies[i].x, enemies[i].y, "basic"));
              }
              spawnCollectible(enemies[i].x, enemies[i].y);
              score += (enemies[i].type==="elite")?200:100;
              enemies[i].dead = true;
              break;
            }
          }
        }
      }
      // Столкновение пуль боссов с игроком
      for(let i = bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        if((b.fromBoss || b.fromEnemy) && circleCollision(b, player)) {
          if (player.activePowerUps.shield.duration > 0) {
            // Если щит активен, пуля просто уничтожается (можно добавить визуальный эффект)
            b.dead = true;
            // Дополнительно: создаём несколько частиц для эффекта удара по щиту
            for (let k = 0; k < 3; k++) {
              particles.push(new Particle(b.x, b.y, "rgba(0,200,255,0.5)"));
            }
          } else {
            player.currentHP -= b.damage;
            // Отображение нанесённого урона
            damageTexts.push({ x: player.x, y: player.y, damage: b.damage, alpha: 1, lifetime: 1000 });
            for (let k = 0; k < 5; k++) {
              particles.push(new Particle(b.x, b.y, "#f00"));
            }
            b.dead = true;
            if (player.currentHP <= 0) { gameState = "gameover"; showGameOver(); }
          }
        }
      }
      // Столкновение пуль игрока с пулями врагов
      for (let i = 0; i < bullets.length; i++) {
        let playerBullet = bullets[i];
        if(playerBullet.fromEnemy || playerBullet.fromBoss) continue; // рассматриваем только пули игрока
        for (let j = 0; j < bullets.length; j++) {
          let enemyBullet = bullets[j];
          if(!(enemyBullet.fromEnemy || enemyBullet.fromBoss)) continue; // рассматриваем только пули врагов
          if(circleCollision(playerBullet, enemyBullet)) {
            playerBullet.dead = true;
            enemyBullet.dead = true;
          }
        }
      }

      // Столкновение пуль с боссами (не боссовых пуль)
      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        if (!b.fromBoss) {
          for(let j = bosses.length - 1; j >= 0; j--) {
            if(circleCollision(b, bosses[j])) {
              bosses[j].hp -= b.damage;
              // --- Если пуля имеет Freeze Blast, то замедляем босса ---
              if(b.freezeBlast) {
                bosses[j].freezeSlow = Math.max(bosses[j].freezeSlow, 3000);
              }
              for(let blood = 0; blood < 5; blood++){
                particles.push(new Particle(b.x, b.y, "#800000"));
              }
              b.dead = true;
              break;
            }
          }
        }
      }
      if(powerMeter >= POWER_METER_MAX && gameState==="playing") {
        showPowerUpMenu();
      }

      // --- Обновление массива damageTexts (плавающие красные числа урона) ---
      for (let i = damageTexts.length - 1; i >= 0; i--) {
        let dt = damageTexts[i];
        dt.lifetime -= deltaTime;
        dt.y -= 0.05 * deltaTime; // поднимаемся вверх
        dt.alpha = dt.lifetime / 1000;
        if (dt.lifetime <= 0) {
          damageTexts.splice(i, 1);
        }
      }
      enemies = enemies.filter(enemy => !enemy.dead);
      bullets = bullets.filter(bullet => !bullet.dead);
    }

    // progress bar
    // progress bar
    function drawLevelProgressBar() {
      ctx.save();

      if (isMobile) {
        if (window.innerWidth > window.innerHeight) {
          // Mobile Landscape → horizontal progress bar at the bottom
          const barWidth = 300 * uiScale;
          const barHeight = 25 * uiScale;
          const x = (width - barWidth) / 2;
          const y = height - barHeight - (20 * uiScale);
          
          // Draw background
          ctx.fillStyle = "#333";
          ctx.fillRect(x, y, barWidth, barHeight);
          
          if (bosses.length === 0) {
            let progress = (levelDuration - levelTimer) / levelDuration;
            progress = Math.max(0, Math.min(1, progress));
            const grad = ctx.createLinearGradient(x, y, x + barWidth, y);
            grad.addColorStop(0, "#0f0");
            grad.addColorStop(1, "#ff0");
            ctx.fillStyle = grad;
            ctx.fillRect(x, y, barWidth * progress, barHeight);
            
            ctx.fillStyle = "#fff";
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.fillText("Boss fight in " + Math.ceil(levelTimer / 1000) + "s!!", 
                         x + barWidth / 2, 
                         y + barHeight - (5 * uiScale));
          } else {
            ctx.fillStyle = "#f00";
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.fillText("FIGHT!", x + barWidth / 2, y + barHeight - (5 * uiScale));
          }
          
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, barWidth, barHeight);
        } else {
          // Mobile Portrait → vertical progress bar on the right
          const barWidth = 25 * uiScale;
          const barHeight = 300 * uiScale;
          const x = width - barWidth - (20 * uiScale);
          const y = (height - barHeight) / 2;
          
          // Draw background
          ctx.fillStyle = "#333";
          ctx.fillRect(x, y, barWidth, barHeight);

          if (bosses.length === 0) {
            let progress = (levelDuration - levelTimer) / levelDuration;
            progress = Math.max(0, Math.min(1, progress));
            const grad = ctx.createLinearGradient(x, y + barHeight, x, y);
            grad.addColorStop(0, "#0f0");
            grad.addColorStop(1, "#ff0");
            ctx.fillStyle = grad;
            ctx.fillRect(x, y + barHeight - (barHeight * progress), barWidth, barHeight * progress);
            
            ctx.fillStyle = "#fff";
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.translate(x + barWidth / 2, y + barHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText("Boss fight in " + Math.ceil(levelTimer / 1000) + "s!!", 0, 0);
          } else {
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.translate(x + barWidth / 2, y + barHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText("FIGHT!", 0, 0);
          }          
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, barWidth, barHeight);
        }
      } else {
        // --- Horizontal Progress Bar for Desktop ---
        const barWidth = 300 * uiScale;
        const barHeight = 25 * uiScale;
        const x = (width - barWidth) / 2;
        const y = height - barHeight - (20 * uiScale);
        
        // Draw background
        ctx.fillStyle = "#333";
        ctx.fillRect(x, y, barWidth, barHeight);
        
        if (bosses.length === 0) {
          let progress = (levelDuration - levelTimer) / levelDuration;
          progress = Math.max(0, Math.min(1, progress));
          const grad = ctx.createLinearGradient(x, y, x + barWidth, y);
          grad.addColorStop(0, "#0f0");
          grad.addColorStop(1, "#ff0");
          ctx.fillStyle = grad;
          ctx.fillRect(x, y, barWidth * progress, barHeight);
          
          ctx.fillStyle = "#fff";
          ctx.font = (18 * uiScale) + "px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Boss fight in " + Math.ceil(levelTimer / 1000) + "s!!", x + barWidth / 2, y + barHeight - (5 * uiScale));
        } else {
          ctx.fillStyle = "#f00";
          ctx.font = (18 * uiScale) + "px Arial";
          ctx.textAlign = "center";
          ctx.fillText("FIGHT!", x + barWidth / 2, y + barHeight - (5 * uiScale));
        }
        
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, barWidth, barHeight);
      }
      
      ctx.restore();
    }
    // Функция, которая по ключу из activePowerUps ищет читаемое название в powerUpMap
    function getPowerUpDisplayName(key) {
      for (let displayName in powerUpMap) {
        if (powerUpMap[displayName] === key) {
          return displayName;
        }
      }
      return key; // если не найдено, возвращаем исходное значение
    }

    // =================== Draw Function ===================
    function draw() {
      getCurrentBiome().drawBackground();
      collectibles.forEach(c => c.draw());
      if(player) player.draw();
      bullets.forEach(b => b.draw());
      enemies.forEach(e => e.draw());
      // Отрисовка босса (или боссов)
      bosses.forEach(b => b.draw());
      particles.forEach(p => p.draw());
      // HUD
      ctx.fillStyle = "#fff";
      ctx.font = (20 * uiScale) + "px Arial";
      ctx.fillText("Score: " + Math.floor(score), 10, 30 * uiScale);
      ctx.fillText("Level: " + currentLevel, 10, 55 * uiScale);
      // Power Meter Bar
      ctx.fillStyle = "#222";
      ctx.fillRect(10 * uiScale,65 * uiScale,120 * uiScale,15 * uiScale);
      ctx.fillStyle = "#0f0";
      ctx.fillRect(10 * uiScale,65 * uiScale,(120*(powerMeter/POWER_METER_MAX)) * uiScale,15 * uiScale);
      ctx.strokeStyle = "#fff";
      ctx.strokeRect(10 * uiScale,65 * uiScale,120 * uiScale,15 * uiScale);
      // Health Bar
      if(player) {
        const grad = ctx.createLinearGradient(10 * uiScale,80 * uiScale,130 * uiScale,80 * uiScale);
        grad.addColorStop(0, "#f00");
        grad.addColorStop(1, "#0f0");
        ctx.fillStyle = "#222";
        ctx.fillRect(10 * uiScale,80 * uiScale,120 * uiScale,15 * uiScale);
        ctx.fillStyle = grad;
        ctx.fillRect(10 * uiScale,80 * uiScale,(120*(player.currentHP/player.maxHP)) * uiScale,15 * uiScale);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(10 * uiScale,80 * uiScale,120 * uiScale,15 * uiScale);
      }
      // Отрисовка перманентных бонусов в правом верхнем углу
      ctx.textAlign = "right";  // Выравнивание текста по правому краю
      ctx.fillStyle = "#fff";
      ctx.font = (20 * uiScale) + "px Arial";
      ctx.fillText("Damage: " + permanentUpgrades.damage, (width - 10), 30 * uiScale);
      ctx.fillText("Speed: " + permanentUpgrades.speed, (width - 10), 55 * uiScale);
      ctx.fillText("Fire Rate: " + permanentUpgrades.fireRate, (width - 10), 80 * uiScale);
      ctx.fillText("Health: " + (100 + permanentUpgrades.health), (width - 10), 105 * uiScale);  // *** NEW: отображение здоровья
      ctx.textAlign = "left";  // Сброс выравнивания для дальнейшей отрисовки
      // =================== Отрисовка активных усилений и негативных эффектов (HUD) ===================
      if (player) {
        let yOffset = 120;
        // Сначала выводим активные (положительные) усиления белым цветом
        if (player.activePowerUps) {
          for (let key in player.activePowerUps) {
            if (player.activePowerUps[key].duration > 0) {
              const displayName = getPowerUpDisplayName(key);
              ctx.fillStyle = "#fff";
              ctx.fillText(displayName + " (" + Math.ceil(player.activePowerUps[key].duration / 1000) + "s, stacks: " + player.activePowerUps[key].stacks + ")", 10 * uiScale, yOffset * uiScale);
              yOffset += 25;
            }
          }
        }
        // Затем выводим негативные эффекты красным цветом
        if (player.frozenTime > 0) {
           ctx.fillStyle = "#f00";
           ctx.fillText("Frozen (" + Math.ceil(player.frozenTime / 1000) + "s)", 10 * uiScale, yOffset * uiScale);
           yOffset += 25;
        }
        if (player.shootingDisabled > 0) {
           ctx.fillStyle = "#f00";
           ctx.fillText("Shooting Disabled (" + Math.ceil(player.shootingDisabled / 1000) + "s)", 10 * uiScale, yOffset * uiScale);
           yOffset += 25;
        }
        if (player.empSlowed > 0) {
           ctx.fillStyle = "#f00";
           ctx.fillText("EMP Slowed (" + Math.ceil(player.empSlowed / 1000) + "s)", 10 * uiScale, yOffset * uiScale);
           yOffset += 25;
        }
      }
      // Отрисовка плавающих красных чисел урона
      damageTexts.forEach(dt => {
        ctx.save();
        ctx.globalAlpha = dt.alpha;
        ctx.fillStyle = "#f00";
        ctx.font = (24 * uiScale) + "px Arial";
        // Если dt.damage является числом – добавляем минус, иначе выводим как есть
        const text = (typeof dt.damage === "number") ? "-" + dt.damage : dt.damage;
        ctx.fillText(text, dt.x, dt.y);
        ctx.restore();
      });
      drawLevelProgressBar();
    }

    // =================== Game Start ===================
    function startGame() {
      gameState = "playing";
      score = 0;
      currentLevel = 1;
      levelTimer = levelDuration;
      permanentUpgrades.damage = 1;
      permanentUpgrades.speed = 1;
      permanentUpgrades.fireRate = 1;
      // permanentUpgrades.health оставляем как есть (может быть уже > 0)
      enemySpawnTimer = 0;
      fireCooldown = 0;
      powerMeter = 0;
      bosses.length = 0;
      enemies.length = 0;
      bullets.length = 0;
      collectibles.length = 0;
      particles.length = 0;
      damageTexts = []; // сброс отображаемых чисел урона
      player = new Player(width/2, height/2);
      player.maxHP = 100 + permanentUpgrades.health;  // *** NEW: учитываем перманентное здоровье
      player.currentHP = player.maxHP;
      document.getElementById("overlay").classList.add("hidden");
    }
    

    mainMenu();
    requestAnimationFrame(gameLoop);
  })();
  </script>
</body>
</html>
