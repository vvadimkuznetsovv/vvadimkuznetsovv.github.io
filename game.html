<!DOCTYPE html>
<!--
    Лицензия на данный код:

    Авторский код разработан и предоставлен:
      - Кузнецов Вадим Алексеевич (ООО НейроБизнес Солюшнс)
      - Басма Нассиф Хуссейн (ООО Интеллектуальные Технологии Будущего Образования)

    Использование, распространение и модификация данного кода допускаются только при соблюдении
    условий лицензионного соглашения. При использовании данного кода, пожалуйста, сохраняйте
    данный блок с указанием авторства.
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Neon Nexus: Ultimate Gauntlet – Levels Edition (Expanded)</title>
  <style>
    :root {
      --ui-scale: 1;
    }
    /* Reset and full‑screen canvas */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
    /* Overlay for menus, transitions, power‑up selection, pause, game over, etc. */
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.85);
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      text-align: center;
      user-select: none;
      font-size: calc(16px * var(--ui-scale));
      /* Let the overlay itself scroll if it’s taller than the screen */
      overflow-y: auto;
      /* a padding or margin so that the content doesn't butt up against edges */
      box-sizing: border-box; 
      padding: calc(20px * var(--ui-scale));
    }
    #overlay.hidden {
      display: none;
    }
    .button {
      margin: calc(10px * var(--ui-scale));
      padding: calc(10px * var(--ui-scale)) calc(20px * var(--ui-scale));
      background: #222;
      border: calc(2px * var(--ui-scale)) solid #0ff;
      color: #0ff;
      font-size: calc(18px * var(--ui-scale));
      box-shadow: 0px 0px 10px 2px #0ff;
      border-radius: 10px;
      cursor: pointer;
    }
    .cyan_color {
      color: #0ff;
      text-shadow: 0px 0px 10px #0ff;
    }
    .button:hover {
      background: #0ff;
      color: #000;
    }
    /* Mobile Joysticks & Pause Button */
    #leftJoystick, #rightJoystick {
      position: absolute;
      bottom: 20px;
      width: calc(200px * var(--ui-scale));;
      height: calc(200px * var(--ui-scale));
      background: rgba(255,255,255,0.1);
      border-radius: 50%;
      z-index: 50;
      touch-action: none;
      display: none;
    }
    #leftJoystick { left: 20px; }
    #rightJoystick { right: 20px; }
    .joystick-thumb {
      position: absolute;
      width: calc(80px * var(--ui-scale));
      height: calc(80px * var(--ui-scale));
      background: rgba(0,255,255,0.4);
      border-radius: 50%;
      top: calc(60px * var(--ui-scale));
      left: calc(60px * var(--ui-scale));
      transition: transform 0.1s ease;
    }
    #mobilePauseButton {
      position: absolute;
      top: calc(135px * var(--ui-scale));
      right: calc(20px * var(--ui-scale));
      z-index: 50;
      margin: calc(10px * var(--ui-scale));
      padding: calc(10px * var(--ui-scale)) calc(20px * var(--ui-scale));
      background: rgba(0,0,0,0.5);
      border: calc(2px * var(--ui-scale)) solid #0ff;
      color: #0ff;
      box-shadow: 0px 0px 10px 2px #0ff;
      border-radius: 10px;
      font-size: calc(20px * var(--ui-scale));
      display: none;
    }
    
    @media only screen and (max-width: 768px) {
      /* Increase overlay font sizes */
      #overlay h1 {
        font-size: calc(42px * var(--ui-scale));
      }
      #overlay p {
        font-size: calc(24px * var(--ui-scale));
      }
      .button {
        font-size: calc(24px * var(--ui-scale));
        padding: calc(15px * var(--ui-scale)) calc(30px * var(--ui-scale));
      }
    }
    

    /* The container for all audio settings */
    /* The container for all audio settings */
    .audio-settings {
      margin-top: calc(20px * var(--ui-scale));
      color: #0ff;
      font-family: Arial, sans-serif;
      text-align: center;
    }

    /* The mute checkbox + label styling */
    .mute-label {
      display: inline-flex;
      align-items: center;
      margin: calc(10px * var(--ui-scale));
      padding: calc(6px * var(--ui-scale)) calc(12px * var(--ui-scale));
      border: calc(2px * var(--ui-scale)) solid #0ff;
      border-radius: calc(8px * var(--ui-scale));
      background: #222;
      box-shadow: 0 0 calc(10px * var(--ui-scale)) calc(2px * var(--ui-scale)) rgba(0, 255, 255, 0.5);
      cursor: pointer;
    }
    .mute-checkbox {
      margin-right: calc(8px * var(--ui-scale));
      width: calc(18px * var(--ui-scale));
      height: calc(18px * var(--ui-scale));
      accent-color: #0ff; /* for browsers that support accent-color */
    }

    /* Each volume slider block */
    .slider-container {
      margin: calc(15px * var(--ui-scale)) 0;
    }

    .slider-label {
      display: block;
      margin-bottom: calc(6px * var(--ui-scale));
    }

    /* Base slider styling */
    .slider {
      -webkit-appearance: none; /* Remove default styling */
      width: calc(220px * var(--ui-scale));
      height: calc(6px * var(--ui-scale));
      background: #333;
      border-radius: calc(6px * var(--ui-scale));
      outline: none;
      margin: 0 auto;
      cursor: pointer;
    }

    /* Neon glow effect */
    .neon-slider {
      box-shadow: 0 0 calc(10px * var(--ui-scale)) rgba(0,255,255,0.3);
    }

    /* Chrome / Safari thumb */
    .neon-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: calc(20px * var(--ui-scale));
      height: calc(20px * var(--ui-scale));
      background: #0ff;
      border-radius: 50%;
      box-shadow: 0 0 calc(5px * var(--ui-scale)) #0ff,
                  0 0 calc(10px * var(--ui-scale)) #0ff;
      cursor: pointer;
    }

    /* Firefox thumb */
    .neon-slider::-moz-range-thumb {
      width: calc(20px * var(--ui-scale));
      height: calc(20px * var(--ui-scale));
      background: #0ff;
      border-radius: 50%;
      box-shadow: 0 0 calc(5px * var(--ui-scale)) #0ff,
                  0 0 calc(10px * var(--ui-scale)) #0ff;
      cursor: pointer;
    }

    .collapsible-container {
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.4s ease;
      width: 100%; 
      margin: 0 auto;
    }
    
    .collapsible-container.open {
      max-height: 180vh;
    }

    .pause-menu::-webkit-scrollbar,
    #customTracksUL::-webkit-scrollbar {
      width: calc(8px * var(--ui-scale)); /* slightly bigger on high DPI */
      height: calc(8px * var(--ui-scale));/* for horizontal scroll, if any */
    }

    .pause-menu::-webkit-scrollbar-track,
    #customTracksUL::-webkit-scrollbar-track {
      background: #333; /* track background */
    }

    .pause-menu::-webkit-scrollbar-thumb,
    #customTracksUL::-webkit-scrollbar-thumb {
      background: #0ff; /* “thumb” color (the draggable part) */
      border-radius: calc(4px * var(--ui-scale));
      /* a subtle glow (optional) */
      box-shadow: 0 0 calc(5px * var(--ui-scale)) rgba(0,255,255,0.5);
    }

    .pause-menu::-webkit-scrollbar-thumb:hover,
    #customTracksUL::-webkit-scrollbar-thumb:hover {
      background: #0cc; /* a slightly different color on hover */
    }
    
    

    /* Neon-style dropdown */
    .neon-select {
      background: #222;
      color: #0ff;
      border: calc(2px * var(--ui-scale)) solid #0ff;
      border-radius: calc(8px * var(--ui-scale));
      padding: calc(6px * var(--ui-scale)) calc(12px * var(--ui-scale));
      box-shadow: 0 0 calc(10px * var(--ui-scale)) calc(2px * var(--ui-scale)) rgba(0,255,255,0.3);
      outline: none;
      cursor: pointer;
      margin: 0 auto;
      text-align: center; 
    }

    /* Focus/hover states for dropdown */
    .neon-select:hover,
    .neon-select:focus {
      box-shadow: 0 0 calc(10px * var(--ui-scale)) calc(2px * var(--ui-scale)) #0ff;
      border-color: #0ff;
      background: #111;
    }

    /* Example specialized style for #pauseMusicToggleBtn */
    #pauseMusicToggleBtn {
      margin: calc(10px * var(--ui-scale));
      padding: calc(8px * var(--ui-scale)) calc(16px * var(--ui-scale));
      border: calc(2px * var(--ui-scale)) solid #0ff;
      color: #0ff;
      background: #222;
      border-radius: calc(10px * var(--ui-scale));
      cursor: pointer;
      box-shadow: 0 0 calc(10px * var(--ui-scale)) calc(2px * var(--ui-scale)) #0ff;
      font-size: calc(18px * var(--ui-scale));
    }

    #pauseMusicToggleBtn:hover {
      background: #0ff;
      color: #000;
    }

    #customTracksContainer {
      margin-top: calc(20px * var(--ui-scale));
    }
    
    #customTrackURL {
      background: #222;
      border: calc(2px * var(--ui-scale)) solid #0ff;
      color: #0ff;
      border-radius: 8px;
      padding: 6px 12px;
      width: 60%;
      box-shadow: 0 0 calc(5px * var(--ui-scale)) rgba(0,255,255,0.5);
    }
    #customTrackURL:focus {
      outline: none;
      box-shadow: 0 0 calc(10px * var(--ui-scale)) #0ff;
    }
    
    .file-choose-btn {
      display: inline-block;
      background: #222;
      color: #0ff;
      padding: calc(10px * var(--ui-scale)) calc(20px * var(--ui-scale));
      border: calc(2px * var(--ui-scale)) solid #0ff;
      border-radius: calc(10px * var(--ui-scale));
      cursor: pointer;
      box-shadow: 0 0 calc(10px * var(--ui-scale)) calc(2px * var(--ui-scale)) #0ff;
      margin-right: calc(10px * var(--ui-scale));
      text-align: center;
    }
    
    .file-choose-btn:hover {
      background: #0ff;
      color: #000;
    }
    
    .file-chosen-label {
      margin-right: calc(10px * var(--ui-scale));
      color: #ccc;
      font-family: Arial, sans-serif;
    
    }
    

    .pause-menu {
      background: rgba(0,0,0,0.85);
      border: calc(2px * var(--ui-scale)) solid #0ff;
      border-radius: calc(10px * var(--ui-scale));
      box-shadow: 0 0 calc(10px * var(--ui-scale)) #0ff;
      padding: calc(20px * var(--ui-scale));
      max-width: calc(400px * var(--ui-scale));
      width: 90%;
      box-sizing: border-box;
      text-align: center;
      max-height: calc(100vh * var(--ui-scale) - 20px);
      overflow-y: auto;
    }

    .pause-menu h2 {
      margin-top: 0;
      color: #0ff;
      font-size: calc(24px * var(--ui-scale));
    }
    
    .pause-menu-buttons {
      margin: calc(10px * var(--ui-scale)) 0;
    
      /* Make them align side by side with spacing */
      display: flex;
      justify-content: center;       /* center horizontally */
      flex-wrap: wrap;              /* if there's no room, wrap onto next line */
      gap: calc(10px * var(--ui-scale)); /* spacing between the buttons */
    }
    
    
    .pause-menu-buttons .button {
      margin: 0 calc(5px * var(--ui-scale));
    }

    #customTracksUL {
      list-style-type: none;
      padding-left: 0;
    
      /* Scale vertical margin */
      margin: calc(10px * var(--ui-scale)) 0;
    
      /* Scale max-height so it can display ~3 items when ui-scale=1 
         (adjust if you'd like a different base size). */
      max-height: calc(200px * var(--ui-scale));
    
      overflow-y: auto;
    }
    
    #customTracksUL li {
      /* Scale margin-bottom for each list item */
      margin-bottom: calc(6px * var(--ui-scale));
    }
    
    

    /* Keep or reuse your neon styles from earlier, e.g.: */
    
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <!-- Overlay for menus, transitions, power‑up selection, pause, game over -->
  <div id="overlay">
    <h1>Neon Nexus: Ultimate Gauntlet</h1>
    <p id="overlayText">
      Move with WASD, aim with your mouse and auto‑fire.<br>
      Collect glowing orbs to fill your power meter.<br>
      When full, choose one of three temporary power‑ups to help you survive.
    </p>
    <p id="startHint">Press <strong>SPACE</strong> to begin</p>
    <div id="overlayButtons"></div>
  </div>

  <!-- Mobile controls -->
  <div id="leftJoystick">
    <div class="joystick-thumb"></div>
  </div>
  <div id="rightJoystick">
    <div class="joystick-thumb"></div>
  </div>
  <button id="mobilePauseButton">Pause</button>

  <script src="./assets/libs/howler.min.js"></script>
  <script>
  (function(){

     // =================== AUDIO GLOBALS ===================
    let soundEnabled = true;           // Master on/off
    let musicVolume = 0.05;            // 0.0 to 1.0
    let sfxVolume = 0.05;              // 0.0 to 1.0
    let currentMusicTrack = "phonk";

    const calmTracks = [
      new Howl({ src: ["assets/music/calm/fragments-of-love-by-sascha-ende-from-filmmusic-io.mp3"], volume: musicVolume, loop: false, html5: false }),
      new Howl({ src: ["assets/music/calm/relaxing-lofi-tessera-by-sascha-ende-from-filmmusic-io.mp3"], volume: musicVolume, loop: false, html5: false }),
      new Howl({ src: ["assets/music/calm/childhood-by-sascha-ende-from-filmmusic-io.mp3"], volume: musicVolume, loop: false, html5: false }),
      new Howl({ src: ["assets/music/calm/the-children-of-mh17-by-sascha-ende-from-filmmusic-io.mp3"], volume: musicVolume, loop: false, html5: false }),
      // Add more tracks as needed.
    ];

    const phonkTracks = [
      new Howl({ src: ["assets/music/phonk/phonk (1).mp3"], volume: musicVolume, loop: false, html5: false }),
      new Howl({ src: ["assets/music/phonk/phonk (2).mp3"], volume: musicVolume, loop: false, html5: false }),
      new Howl({ src: ["assets/music/phonk/phonk (3).mp3"], volume: musicVolume, loop: false, html5: false }),
      new Howl({ src: ["assets/music/phonk/phonk (4).mp3"], volume: musicVolume, loop: false, html5: false }),
      new Howl({ src: ["assets/music/phonk/phonk (5).mp3"], volume: musicVolume, loop: false, html5: false }),
      new Howl({ src: ["assets/music/phonk/phonk (6).mp3"], volume: musicVolume, loop: false, html5: false }),
      new Howl({ src: ["assets/music/phonk/phonk (7).mp3"], volume: musicVolume, loop: false, html5: false }),
      new Howl({ src: ["assets/music/phonk/phonk (8).mp3"], volume: musicVolume, loop: false, html5: false }),
      new Howl({ src: ["assets/music/phonk/phonk (9).mp3"], volume: musicVolume, loop: false, html5: false }),
    ];

    const customTracks = []; 

    // Initially we start at track index 0 for each array
    let calmIndex = 0;
    let phonkIndex = 0;
    let customIndex = 0;

    // Also a boolean for looping the *current* track endlessly
    let loopSingleTrack = false;

    // Make sure each track’s volume is set (and not set to loop)
    calmTracks.forEach(track => {
      track.volume(musicVolume);
      track.loop = false;  // We'll handle looping ourselves
    });
    phonkTracks.forEach(track => {
      track.volume(musicVolume);
      track.loop = false;
    });

    /****************************************************
    * 2) Adjust getActiveMusic() to return
    *    the *current track* from the correct array:
    ****************************************************/
    function getActiveMusic() {
      if (currentMusicTrack === "phonk") {
        return phonkTracks[phonkIndex];
      } else if (currentMusicTrack === "custom") {
        // If no custom tracks exist, return null so we don't crash
        if (customTracks.length > 0) {
          return customTracks[customIndex];
        } else {
          return null;
        }
      } else {
        // default calm
        return calmTracks[calmIndex];
      }
    }

    function getClosestTargetWithoutBullet() {
      let closest = null;
      let minDist = Infinity;
      // Фильтруем пули, выпущенные врагами/боссами:
      //let enemyBullets = bullets.filter(b => b.fromEnemy || b.fromBoss);
      // Объединяем массивы врагов и боссов (если оба используются)
      let targets = enemies.concat(bosses);
      for (let target of targets) {
        let d = Math.hypot(target.x - player.x, target.y - player.y);
        if (d < minDist) {
          minDist = d;
          closest = target;
        }
      }
      return closest;
    }
    let baseBombRadius = 0;
    let bombRadius = 0;
    function calculateRadiusAndDamageBomb(bullet){
      // Расчёт радиуса взрыва с учётом количества стэков bomb:
      baseBombRadius = 110 * scaleFactor;
      const bombStacks = player.activePowerUps.bomb.stacks || 1;
      // Например, радиус увеличивается на 50% за каждый дополнительный стэк:
      bombRadius = baseBombRadius * (1 + (bombStacks - 1) * 0.5);
      addMiniWave(bullet.x, bullet.y);
      // Вычисляем множитель от damage boost:
      const damageBoostMultiplier = (player.activePowerUps.damageBoost.duration > 0
      ? (1 + player.activePowerUps.damageBoost.stacks)
      : 1);
      // Расчет итогового урона взрыва:
      // Базовое значение урона (1) умножается на постоянный бонус игрока, затем на damage boost и затем увеличивается за счёт bomb стэков.
      const explosionDamage = 1 * permanentUpgrades.damage * damageBoostMultiplier * (1 + bombStacks);
      return explosionDamage
    }

    // ========== Ninja Spirit Start ============
    function getClosestTarget() {
      let closest = null;
      let minDist = Infinity;
      // Фильтруем пули, выпущенные врагами/боссами:
      let enemyBullets = bullets.filter(b => b.fromEnemy || b.fromBoss);
      // Объединяем массивы врагов и боссов (если оба используются)
      let targets = enemies.concat(bosses, enemyBullets);
      for (let target of targets) {
        let d = Math.hypot(target.x - player.x, target.y - player.y);
        if (d < minDist) {
          minDist = d;
          closest = target;
        }
      }
      return closest;
    }
    function computeInterceptAngle(shooter, bulletSpeed, target, targetVelocity) {
      // Вектор от стрелка к цели:
      let r = { x: target.x - shooter.x, y: target.y - shooter.y };
      
      // Коэффициенты квадратного уравнения:
      let A = targetVelocity.x * targetVelocity.x + targetVelocity.y * targetVelocity.y - bulletSpeed * bulletSpeed;
      let B = 2 * (r.x * targetVelocity.x + r.y * targetVelocity.y);
      let C = r.x * r.x + r.y * r.y;
      
      let t = 0;
      if (Math.abs(A) < 0.001) {
        // Если A очень маленькое – линейное приближение
        t = -C / B;
      } else {
        let discriminant = B * B - 4 * A * C;
        if (discriminant < 0) {
          // Нет действительного решения – просто стреляем по текущей позиции
          t = 0;
        } else {
          let t1 = (-B + Math.sqrt(discriminant)) / (2 * A);
          let t2 = (-B - Math.sqrt(discriminant)) / (2 * A);
          // Выбираем минимальное положительное время
          t = Math.min(t1, t2);
          if (t < 0) {
            t = Math.max(t1, t2);
          }
          if (t < 0) t = 0;
        }
      }
      
      // Предсказанная позиция цели:
      let aimX = target.x + targetVelocity.x * t;
      let aimY = target.y + targetVelocity.y * t;
      
      return Math.atan2(aimY - shooter.y, aimX - shooter.x);
    }
    function getTargetVelocity(target) {
      // Если это пуля (предполагаем, что у объектов класса Bullet есть свойства speed и angle)
      if (target instanceof Bullet) {
        return { 
          x: Math.cos(target.angle) * target.speed, 
          y: Math.sin(target.angle) * target.speed 
        };
      } else {
        // Для врагов/боссов: можно предположить, что они движутся в направлении игрока
        let dx = player.x - target.x;
        let dy = player.y - target.y;
        let d = Math.hypot(dx, dy);
        if (d === 0) return { x: 0, y: 0 };
        return { 
          x: (dx / d) * target.speed, 
          y: (dy / d) * target.speed 
        };
      }
    }
    
    // ========== Ninja Spirit End ============


    /****************************************************
    * 3) Modify playCurrentMusic() to pause *all* tracks,
    *    then attach an 'ended' listener that either
    *    goes to next track or replays the same track.
    ****************************************************/
    function playCurrentMusic() {
      const music = getActiveMusic();
      if (!music) {
        // If null (e.g. custom is empty), just return
        console.warn("No track to play (maybe custom list is empty)");
        return;
      }
      if (!soundEnabled) return;
      if (music.playing()) {
        console.log("Песня уже воспроизводится – не перезапускаем её");
        return;
      }
      

      console.log("Now playing:", music._src);
      music.stop();
      music.volume(musicVolume);
      music.play();

      // Use Howler's event system to detect when the track ends:
      music.once('end', function() {
        if (loopSingleTrack) {
          console.log("✅ Музыка закончилась! Пытаемся переключить трек...");
          playCurrentMusic();
        } else {
          console.log("Track ended, switching...");
          nextTrack();
        }
      });
    }


    /***************************************************
    * 4) Add helper function: nextTrack() to skip ahead
    ***************************************************/
    function nextTrack() {
      console.log("Switching track...");
      if (currentMusicTrack === "phonk") {
        phonkIndex = (phonkIndex + 1) % phonkTracks.length;
      } else if (currentMusicTrack === "custom") {
        if (customTracks.length > 0) {
          customIndex = (customIndex + 1) % customTracks.length;
        }
      } else {
        // calm
        calmIndex = (calmIndex + 1) % calmTracks.length;
      }
      playCurrentMusic();
    }

    // (Assuming you have a global variable `sfxVolume` already defined.)
    const sfxMap = {
      shot: new Howl({ src: ["assets/sfx/shot.mp3"], volume: sfxVolume, pool: 20 }),
      freeze: new Howl({ src: ["assets/sfx/freeze.mp3"], volume: sfxVolume, pool: 20 }),
      powerup: new Howl({ src: ["assets/sfx/powerup.mp3"], volume: sfxVolume, pool: 10 }),
      bossDeath: new Howl({ src: ["assets/sfx/boss_death.mp3"], volume: sfxVolume, pool: 10 }),
      click: new Howl({ src: ["assets/sfx/click.mp3"], volume: sfxVolume, pool: 10 }),
      neonoverdrive: new Howl({ src: ["assets/sfx/neonoverdrive.mp3"], volume: sfxVolume, pool: 20 }),
      deadenemy: new Howl({ src: ["assets/sfx/deadenemy.mp3"], volume: sfxVolume, pool: 20 })
    };
    const reflectedShots = [
      new Howl({ src: ["assets/sfx/reflectedShot_1.mp3"], volume: sfxVolume, pool: 10 }),
      new Howl({ src: ["assets/sfx/reflectedShot_2.mp3"], volume: sfxVolume, pool: 10 }),
      new Howl({ src: ["assets/sfx/reflectedShot_3.mp3"], volume: sfxVolume, pool: 10 }),
      new Howl({ src: ["assets/sfx/reflectedShot_4.mp3"], volume: sfxVolume, pool: 10 }),
      new Howl({ src: ["assets/sfx/reflectedShot_5.mp3"], volume: sfxVolume, pool: 10 })
    ];

    let lastNeonOverdriveTime = 0;

    function playNeonOverdriveSound() {
      const now = Date.now();
      if (now - lastNeonOverdriveTime >= 100) {
        lastNeonOverdriveTime = now;
        playSfx("neonoverdrive")
      }
    }
    function playReflectedSound() {
      if (!soundEnabled) return;
      const index = Math.floor(Math.random() * reflectedShots.length);
      let minVolume = Math.max(0, sfxVolume - 0.01);
      let maxVolume = Math.min(1, sfxVolume + 0.01);
      reflectedShots[index].volume(minVolume + Math.random() * (maxVolume - minVolume));
      reflectedShots[index].play();
    }

    // Ensure SFX volumes are set
    for (let key in sfxMap) {
      sfxMap[key].volume(sfxVolume);
    }

    console.log("Howl type:", typeof Howl);  // Should print "function"
    console.log("sfxMap.shot:", sfxMap.shot);

    // Helper to play SFX (checks mute, sets volume, etc.)
    function playSfx(name) {
      if (!soundEnabled) return;
      const sfx = sfxMap[name];
      if (!sfx) return;
      // Вычисляем допустимый диапазон громкости, не отклоняющийся более чем на 0.02
      let minVolume = Math.max(0, sfxVolume - 0.01);
      let maxVolume = Math.min(1, sfxVolume + 0.01);
      // Howler handles concurrent playback internally.
      sfx.volume(minVolume + Math.random() * (maxVolume - minVolume)); //// Выбираем случайное значение громкости из допустимого диапазона
      sfx.play();
    }    

    // =================== Canvas & Initialization ===================
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
      
    // Обработчик нажатия клавиш
    document.addEventListener("keydown", function(e) {
      // ************************************
      // **  BUTTONS for Cheats  **
      // ************************************
      /**/
      if(e.key.toLowerCase() === "p") {
        spawnTwoBosses();
      }
      if(e.key.toLowerCase() === "n") {
        nextLevel();
      }
      if(e.key.toLowerCase() === "m") {
        showPowerUpMenu();
      }
      if(e.key.toLowerCase() === "k") {
        givePlayerMagnetEffect();
      }
      // Если нажата клавиша "X" (без учета регистра)
      if (e.key.toLowerCase() === "x") {
        revivePlayer()
      }
      if (e.key.toLowerCase() === "l") {
        applyPowerUp("Light Saber",true);
      }
    });
    canvas.addEventListener("click", function(e) {
      console.log("Canvas click event");
    
      if (!player || gameState !== "playing") {
        console.log("Клик не обрабатывается: player =", player, "gameState =", gameState);
        return;
      }
      
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      console.log("Координаты клика:", clickX, clickY);
    
      const barX = 10 * uiScale;
      const barY = 80 * uiScale;
      const barWidth = 120 * uiScale;
      const barHeight = 15 * uiScale;
      console.log("Область здоровья:", barX, barY, barWidth, barHeight);
    
      if (clickX >= barX && clickX <= barX + barWidth &&
          clickY >= barY && clickY <= barY + barHeight) {
        applyPowerUp("Ninja Spirit");
      }
    });

    let cursorVisible = true; // изначально курсор видим

    // ======== Обрезка для портретного режима
    function getBottomCropHeight() {
      // Получаем высоту джойстика (например, левый джойстик)
      const joystick = document.getElementById("leftJoystick");
      // Если по какой-то причине элемент ещё не измерен, задаём значение по умолчанию
      const joystickHeight = joystick ? joystick.offsetHeight : 200;
      const margin = 30; // отступ сверху джойстика (как в CSS: bottom: 20px)
      return joystickHeight + margin;
    }

    // We will store width/height in these, but NOT assign them to canvas yet.
    let width, height;
    let dpr = window.devicePixelRatio || 1;
    const isMobile = ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);
    if (!isMobile) {
      canvas.style.cursor = "none";
    }
    
    let cssGridSize = (isMobile) ? (50 * (1 / dpr)) : 50;
    let cssGridSize2 = (isMobile) ? (60 * (1 / dpr)) : 60;
    let cssGridSize40 = (isMobile) ? (40 * (1 / dpr)) : 40;
    let actualGridSize = cssGridSize;
    let actualGridSize2 = cssGridSize2;
    let actualGridSize40 = cssGridSize40; 

    let mainCollectibleLifeTime = 40000;

    // Задаём интервалы обновления (в мс)
    const BIOME_STATIC_UPDATE_INTERVAL = 50; // статическая часть обновляется каждые   

    let lastBiomeStaticUpdate = 0;

    // Создаем два offscreen canvas для статического фона и для моргающего оверлея
    const cachedBiomeStaticCanvas = document.createElement('canvas');
    const cachedBiomeStaticCtx = cachedBiomeStaticCanvas.getContext('2d');

    // Не забудьте при ресайзе обновлять размеры этих canvas:
    // Например, внутри вашей функции onResize:
    function updateCachedCanvasSizes() {
      cachedBiomeStaticCanvas.width = width;
      cachedBiomeStaticCanvas.height = height;
    }
    window.addEventListener("resize", () => {
      onResize();
      updateCachedCanvasSizes();
      // Можно также сбросить время обновления, чтобы фон сразу перерисовался
      lastBiomeStaticUpdate = 0;
    });

    // Функция обновления кэша биома; вызываем ее в каждом кадре, перед отрисовкой
    function updateBiomeCache(timestamp) {
      // Обновляем статический фон, если прошло больше BIOME_STATIC_UPDATE_INTERVAL
      if (timestamp - lastBiomeStaticUpdate > BIOME_STATIC_UPDATE_INTERVAL) {
        // Очищаем кэш и отрисовываем текущий биом (используйте вашу функцию, например,     getCurrentBiome().drawBackground)
        cachedBiomeStaticCtx.clearRect(0, 0, width, height);

        cachedBiomeStaticCtx.fillStyle = "red"; // замените на яркий цвет
        cachedBiomeStaticCtx.fillRect(0, 0, width, height);
        const currentBiome = getCurrentBiome();
        currentBiome.drawBackground(cachedBiomeStaticCtx);
        lastBiomeStaticUpdate = timestamp;
      }
    }

    
    // ***************************************
    // ---------------------------------------
    // =========  Drawing methods ============
    // ---------------------------------------
    // ***************************************
    function drawRoundedRect(ctx, x, y, width, height, radius) {
        // Если размеры не положительные — не рисуем ничего.
      if (width <= 0 || height <= 0) return;
      // Гарантируем, что радиус не превышает половину ширины или высоты.
      radius = Math.min(radius, width / 2, height / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }

    // ========== Scope Drawing Start ============
    function drawMouseIndicator() {
      // Если игрок ещё не создан – ничего не рисуем
      if (!player) return;
      
      // Можно взять угол из игрока, так как для десктопа он обновляется как:
      // this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
      let angle = player.angle;
      
      // --- Первая стрелка на позиции курсора ---
      ctx.save();
      ctx.translate(mouse.x, mouse.y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0, -15 * uiScale);
      ctx.lineTo(0, 15 * uiScale);
      ctx.lineTo(50 * uiScale, 0);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.fill();
      ctx.restore();

      // --- Вторая стрелка в середине между игроком и курсором ---
      const midX = (player.x + mouse.x) / 2;
      const midY = (player.y + mouse.y) / 2;
      
      ctx.save();
      ctx.translate(midX, midY);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0, -15 * uiScale);
      ctx.lineTo(0, 15 * uiScale);
      ctx.lineTo(50 * uiScale, 0);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,0.4)";
      ctx.fill();
      ctx.restore();
    }
    function drawMobileCursor() {
      if (!player) return;
      
      // Задаём базовое расстояние от игрока
      const offset = 50 * uiScale; // можно регулировать это значение
      // Вычисляем второе расстояние как удвоенное
      const offset2 = offset * 2;
      
      // Рисуем первую стрелку на расстоянии offset
      const cursorX1 = player.x + Math.cos(player.angle) * offset;
      const cursorY1 = player.y + Math.sin(player.angle) * offset;
      
      ctx.save();
      ctx.translate(cursorX1, cursorY1);
      ctx.rotate(player.angle);
      ctx.beginPath();
      ctx.moveTo(0, -5 * uiScale);
      ctx.lineTo(0, 5 * uiScale);
      ctx.lineTo(20 * uiScale, 0);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.fill();
      ctx.restore();
      
      // Рисуем вторую стрелку на расстоянии offset2
      const cursorX2 = player.x + Math.cos(player.angle) * offset2;
      const cursorY2 = player.y + Math.sin(player.angle) * offset2;
      
      ctx.save();
      ctx.translate(cursorX2, cursorY2);
      ctx.rotate(player.angle);
      ctx.beginPath();
      ctx.moveTo(0, -5 * uiScale);
      ctx.lineTo(0, 5 * uiScale);
      ctx.lineTo(20 * uiScale, 0);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,0.2)";
      ctx.fill();
      ctx.restore();
    }

    // ***************************************
    // ---------------------------------------
    // =========  Drawing methods end ========
    // ---------------------------------------
    // ***************************************

    // Глобальная переменная для таймера спавна специальных collectible
    let specialCollectibleSpawnTimer = 0;
    function spawnSpecialCollectibleRandom() {
      // Проверяем условия: уровень >= 5 и наличие босса
      if (currentLevel < 4 || bosses.length === 0) return;
      
      const maxStage = ((currentLevel - 1) % 5) + 1;
      // Например, шанс спавна можно задать как: maxStage * 0.1 (от 0.1 до 0.5)
      const specialProbability = maxStage * 0.1;
      
      if (Math.random() < specialProbability) {
        // Выбираем случайные координаты внутри экрана
        const x = Math.random() * width;
        const y = Math.random() * height;
        // Добавляем специальный collectible в массив collectibles
        collectibles.push(new SpecialCollectible(x, y));
      }
    }

    function revivePlayer() {
      // Если игра не в состоянии gameover – выходим
      if (gameState !== "gameover") return;
    
      // Если игрок существует, восстанавливаем здоровье и активируем щит
      if (player) {
        // Восстанавливаем здоровье до 50% от максимума
        player.currentHP = Math.floor(player.maxHP / 2);
        // Активируем щит: задаём длительность щита (например, 5000 мс) и 1 стэк
        player.activePowerUps.shield.duration = 5000; // щит действует 5 секунд
        player.activePowerUps.shield.stacks = 1;
      }
    
      // Скрываем оверлей "Game Over" и переводим игру в состояние "playing"
      resumeGame();
    }
    


    //========== Combo переменные и func для комбо-системы

    let comboCounter = 0;           // Для подсчёта убийств
    let comboTimer = 0;             // Для подсчёта времени  
    const COMBO_RESET_TIME = 7000;  // Время, за которое надо убить нового врага, чтобы не сбросился счётчик в милисекундах
    
    // Функция увеличения комбо при убийстве врага
    function increaseCombo() {
      comboCounter++;
      comboTimer = COMBO_RESET_TIME;
      // Пример: активация бонусов
      if (comboCounter === 5) {
        applyPowerUp("Damage Boost", true);
      } else if (comboCounter === 30) {
        applyPowerUp("Bullet Time", true);
      } else if (comboCounter === 70) {
        applyPowerUp("Power Meter Boost", true);
      } else if (comboCounter === 100) {
        applyPowerUp("Friend", true);
      }else if (comboCounter === 150) {
        isFV ? applyPowerUp("Restore Health", true) : applyPowerUp("Health Boost", true);
      }else if (comboCounter === 200) {
        applyPowerUp("Neon Overdrive", true);
        applyPowerUp("Shield", true);
      }else if (comboCounter === 300) {
        isFV ? applyPowerUp("Psi Blast", true) : applyPowerUp("EMP Blast", true);
      }else if (comboCounter === 400) {
        showPermanentUpgradeMenu();
        resetCombo();
      }
    }
    function resetCombo() {
      comboCounter = 0;
      comboTimer = 0;
    }
    function updateCombo(deltaTime) {
      if (comboTimer > 0) {
        comboTimer -= deltaTime;
        if (comboTimer <= 0) {
          comboCounter = 0;
        }
      }
    }

    function onEnemyKilled(enemy) {
      playSfx("deadenemy");

      increaseCombo();
    }

    //================== конец Combo functions

    function onResize() {
      // 1) Use CSS pixel dimensions for your game logic:
      width = window.innerWidth;
      height = window.innerHeight;
      
      // 2) Device pixel ratio (high‑DPI “retina” scaling factor)
      dpr = window.devicePixelRatio || 1;

      // 3) Visually, the canvas should fill the screen in CSS pixels:
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      
      // 4) Internally, give the canvas more pixels (for crispness):
      canvas.width = Math.floor(width * dpr);
      canvas.height = Math.floor(height * dpr);
      
      // Обновляем размеры offscreen‑canvas:
      updateCachedCanvasSizes();
      // Сброс кэша, чтобы сразу перерисовать фон на новом размере
      lastBiomeStaticUpdate = 0;
      // 5) Make 1 “unit” in your drawing code == 1 CSS pixel:
      // If browser supports resetTransform():
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // Attach it:
    window.addEventListener("resize", onResize);
    // Call once on load:
    onResize();

    // =================== Device Detection & UI Setup ===================
    const leftJoystickElem = document.getElementById("leftJoystick");
    const rightJoystickElem = document.getElementById("rightJoystick");
    const mobilePauseButton = document.getElementById("mobilePauseButton");
    let scaleFactor = (isMobile) ? (1 / dpr) : 1;
    if(isMobile) {
      leftJoystickElem.style.display = "block";
      rightJoystickElem.style.display = "block";
      mobilePauseButton.style.display = "block";
      document.getElementById("startHint").innerHTML = "Tap anywhere to begin";
    }
    let uiScale = isMobile ? 1.6 : 1; // Increase scale on mobile

    
    // =================== Update Scale Function ===================
    function updateScale() {
      if (isMobile) {
        // On mobile, use landscape or portrait-specific scales.
        if (window.innerWidth > window.innerHeight) {
          uiScale = 1.6 / dpr;    // mobile landscape
        } else {
          uiScale = 1.6 / dpr;  // mobile portrait
        }
      } else {
        // On desktop, always use scale 1.
        uiScale = 1;
      }
      // Update CSS custom property so that DOM elements also scale accordingly.
      document.documentElement.style.setProperty('--ui-scale', uiScale);
    }
    

    // Call updateScale initially
    updateScale();

    // Add resize listener to update canvas dimensions and scale on orientation change
    window.addEventListener("resize", () => {
      onResize();
      updateScale();
    });

    // =================== Game States & Global Variables ===================
    // States: "menu", "playing", "transition", "powerup", "pause", "gameover"
    let gameState = "menu";
    let score = 0;
    let currentLevel = 1;
    let levelDuration = 30000; // 30 sec per wave
    let levelTimer = levelDuration;
    let maxLevelDuration = 60000;
    // Permanent upgrades (affect damage, speed, fire rate)
    const permanentUpgrades = {
      damage: 1,
      speed: 1,
      fireRate: 1,
      health: 0,            // *** NEW: добавлено для перманентного увеличения здоровья ***
      damageReduction: 0
    };
    // Power meter for temporary power‑ups
    let powerMeter = 0;
    //const POWER_METER_MAX = 100;
    function getPowerMeterMax() {
      return 100 + Math.floor((currentLevel - 1) / 2) * 80;  //Harm-mode
    }
    // Spawn & firing timers
    let enemySpawnTimer = 0;
    let enemySpawnInterval = 1500;
    let fireCooldown = 0;
    const BASE_FIRE_RATE = 200;

    // =================== Global Arrays for Game Objects ===================
    let player;
    let bullets = [];
    let enemies = [];
    let collectibles = [];
    const particles = [];
    let bonusDamage = Math.floor((currentLevel - 1) / 2);  //Hard-mode
    // Вместо одиночного босса используем массив
    let bosses = [];
    // --- Новый массив для отображения урона (плавающие красные числа) ---
    let damageTexts = [];
    // *** NEW: Массив для объектов-друзей (Friend) ***
    let friends = [];
    let acidTrails = [];
    const randomLightsaberColors = ["#00ff00", "#f00", "#9A00FF", "#05f", "#ff0", "#0ff"];
    let lightSaberWaveTimer = 0;
    let lightSaberWave = null;

    let psiBlastWave = null;
    let miniWaves = [];
    
    let isFV = true;

    // Функция для добавления эффекта мини‑волны
    function addMiniWave(x, y) {
      miniWaves.push({
        x: x,
        y: y,
        phase1Duration: 100 * (bombRadius / (80 * scaleFactor)),  // длительность фазы 1 в мс (расширение до 80)
        phase2Duration: 50 * (bombRadius / (80 * scaleFactor)),  // длительность фазы 2 в мс (расширение до 110 и затухание)
        elapsed: 0,          // прошедшее время эффекта
        color: randomLightsaberColors[Math.floor(Math.random() * randomLightsaberColors.length)]
      });
    }
    function hexToRgba(hex, alpha) {
      hex = hex.replace('#', '');
      let r, g, b;
      if (hex.length === 3) {
        r = parseInt(hex.charAt(0) + hex.charAt(0), 16);
        g = parseInt(hex.charAt(1) + hex.charAt(1), 16);
        b = parseInt(hex.charAt(2) + hex.charAt(2), 16);
      } else if (hex.length === 6) {
        r = parseInt(hex.substring(0,2), 16);
        g = parseInt(hex.substring(2,4), 16);
        b = parseInt(hex.substring(4,6), 16);
      }
      return `rgba(${r},${g},${b},${alpha})`;
    }
    // =================== Input Handling ===================
    const keys = {};
    const mouse = { x: width/2, y: height/2, down: false };
    window.addEventListener("keydown", (e) => {
      if((gameState === "menu" || gameState === "gameover") && (e.key === " " || e.code === "Space")) {
        playSfx("click");
        startGame();
      }
      switch(e.code) {
        case "KeyW":
        case "ArrowUp":
          keys.up = true;
          break;
        case "KeyA":
        case "ArrowLeft":
          keys.left = true;
          break;
        case "KeyS":
        case "ArrowDown":
          keys.down = true;
          break;
        case "KeyD":
        case "ArrowRight":
          keys.right = true;
          break;
        case "Escape":
          if (gameState === "playing") pauseGame();
          else if (gameState === "pause") resumeGame();
          break;
      }
    });
    window.addEventListener("keyup", (e) => {
      switch(e.code) {
        case "KeyW":
        case "ArrowUp":
          keys.up = false;
          break;
        case "KeyA":
        case "ArrowLeft":
          keys.left = false;
          break;
        case "KeyS":
        case "ArrowDown":
          keys.down = false;
          break;
        case "KeyD":
        case "ArrowRight":
          keys.right = false;
          break;
      }
    });
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener("mousedown", () => { mouse.down = true; });
    canvas.addEventListener("mouseup", () => { mouse.down = false; });
    mobilePauseButton.addEventListener("click", () => {
      if(gameState === "playing") 
      {
        //applyPowerUp("Light Saber");   //cheat
        pauseGame();
        //nextLevel();   //cheat
      }
    });
    document.addEventListener("pointerdown", (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') {
        return;
      }
      if (gameState === "menu" || gameState === "gameover") {
        playSfx("click");
        startGame();
      }
    });

    // =================== Virtual Joysticks (Mobile) ===================
    const leftJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
    const rightJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0, angle: 0 };
    function setupJoystick(joystickElem, joystickObj) {
      // Get the thumb element from the joystick container
      const thumb = joystickElem.querySelector('.joystick-thumb');
    
      // Touch Start: store the active touch and reset offsets
      joystickElem.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (!joystickObj.active) {
          const touch = e.changedTouches[0];
          joystickObj.active = true;
          joystickObj.activeTouchId = touch.identifier; // Save the unique touch id
          const rect = joystickElem.getBoundingClientRect();
          joystickObj.startX = touch.clientX - rect.left;
          joystickObj.startY = touch.clientY - rect.top;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          // Ensure the thumb starts centered
          thumb.style.transform = 'translate(0px, 0px)';
        }
      });
      // Touch Move: update the joystick offset and move the thumb visually
      joystickElem.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if (!joystickObj.active) return;
    
        // Find the touch that corresponds to this joystick
        let relevantTouch = null;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joystickObj.activeTouchId) {
            relevantTouch = e.changedTouches[i];
            break;
          }
        }
        if (!relevantTouch) return; // No matching touch
    
        const rect = joystickElem.getBoundingClientRect();
        const x = relevantTouch.clientX - rect.left;
        const y = relevantTouch.clientY - rect.top;
        let dx = x - joystickObj.startX;
        let dy = y - joystickObj.startY;
        const maxDist = 80 * uiScale; // Adjust according to your new joystick size
        const dist = Math.hypot(dx, dy);
        if (dist > maxDist) {
          dx = (dx / dist) * maxDist;
          dy = (dy / dist) * maxDist;
        }
        joystickObj.dx = dx;
        joystickObj.dy = dy;
        
        // Update the thumb's position for visual feedback:
        thumb.style.transform = 'translate(' + dx + 'px, ' + dy + 'px)';
    
        // If this is the right joystick, update the aiming angle as well
        if (joystickObj === rightJoystick) {
          joystickObj.angle = Math.atan2(dy, dx);
        }
      });
    
      // Touch End: reset the joystick state and thumb position
      joystickElem.addEventListener("touchend", (e) => {
        let touchEnded = false;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joystickObj.activeTouchId) {
            touchEnded = true;
            break;
          }
        }
        if (touchEnded) {
          joystickObj.active = false;
          joystickObj.activeTouchId = null;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          // Reset thumb to center
          thumb.style.transform = 'translate(0px, 0px)';
        }
      });
    
      // Handle touch cancel events similarly to touch end
      joystickElem.addEventListener("touchcancel", (e) => {
        let touchCanceled = false;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joystickObj.activeTouchId) {
            touchCanceled = true;
            break;
          }
        }
        if (touchCanceled) {
          joystickObj.active = false;
          joystickObj.activeTouchId = null;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          thumb.style.transform = 'translate(0px, 0px)';
        }
      });
    }
    
    if(isMobile) {
      setupJoystick(leftJoystickElem, leftJoystick);
      setupJoystick(rightJoystickElem, rightJoystick);
    }
    // =================== Drawing Enemies ===================
    // Спайковый круг – для базовых врагов
    function drawSpikyCircle(ctx, radius, spikes, spikeFactor) {
      const step = (Math.PI * 2) / (spikes * 2);
      ctx.beginPath();
      for (let i = 0; i < spikes * 2; i++) {
        // Чередуем радиус: обычный и увеличенный на spikeFactor
        const r = i % 2 === 0 ? radius : radius * (1 + spikeFactor);
        const angle = i * step;
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }
    
    // Функция отрисовки многоугольника (например, для элитных врагов)
    function drawPolygon(ctx, sides, radius) {
      const step = (Math.PI * 2) / sides;
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const angle = i * step;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }
    
    // Функция отрисовки снежинки – для врагов типа "freeze"
    function drawSnowflake(ctx, radius) {
      ctx.save();
      ctx.lineWidth = 2;
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI) / 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
        // Добавляем небольшие "ветви"
        let branchAngle = angle + Math.PI / 12;
        ctx.moveTo(radius * 0.7 * Math.cos(angle), radius * 0.7 * Math.sin(angle));
        ctx.lineTo(
          radius * 0.9 * Math.cos(branchAngle),
          radius * 0.9 * Math.sin(branchAngle)
        );
        ctx.stroke();
      }
      ctx.restore();
    }
    
    // Функция отрисовки турели – для врагов типа "shooter"
    function drawTurret(ctx, radius) {
      // Основа – круг
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.fill();
      // "Ствол" – прямоугольник, направленный вправо
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.rect(0, -radius * 0.2, radius, radius * 0.4);
      ctx.fill();
    }
    
    // Функция отрисовки эллипса – для врагов типа "parasite"
    function drawEllipse(ctx, rx, ry) {
      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Функция отрисовки зазубренной фигуры – для врагов типа "emp"
    function drawJaggedShape(ctx, radius) {
      const points = 8;
      ctx.beginPath();
      for (let i = 0; i < points; i++) {
        const angle = (i * Math.PI * 2) / points;
        // Немного случайного колебания радиуса для зазубренности
        const r = radius * (0.7 + Math.random() * 0.6);
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }
    
    // Функция отрисовки треугольника – для врагов типа "sharpshooter"
    function drawTriangle(ctx, radius) {
      ctx.beginPath();
      ctx.moveTo(0, -radius);
      ctx.lineTo(radius, radius);
      ctx.lineTo(-radius, radius);
      ctx.closePath();
      ctx.fill();
    }
    
    // Функция отрисовки "бомбы" – для врагов типа "exploder"
    function drawBomb(ctx, radius) {
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.fill();
      // Фьюз
      ctx.beginPath();
      ctx.moveTo(radius * 0.5, -radius * 0.5);
      ctx.lineTo(radius * 0.8, -radius * 0.8);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    // Функция отрисовки сегментированной фигуры – для врагов типа "splitter"
    function drawSegmentedShape(ctx, radius) {
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      // Разделительные линии
      for (let i = 0; i < 4; i++) {
        const angle = (i * Math.PI) / 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
        ctx.stroke();
      }
    }
    
    // Для боссов можно добавить функцию звёздной фигуры – например, для титула "Emperor"
    function drawStar(ctx, outerRadius, points, insetFactor) {
      const step = Math.PI / points;
      ctx.beginPath();
      for (let i = 0; i < 2 * points; i++) {
        const r = i % 2 === 0 ? outerRadius : outerRadius * insetFactor;
        const angle = i * step;
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }

    // =================== Main Biomes / Backgrounds ===================
   
    const biomes = [
      {   // biome_1
        name: "Neon Arena",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#111";
          context.fillRect(0,0,width,height);
          const gridSize = 50;
          context.strokeStyle = "#222";
          context.lineWidth = 1 * scaleFactor;
          for(let x = 0; x < width; x += actualGridSize){
            context.beginPath();
            context.moveTo(x,0);
            context.lineTo(x,height);
            context.stroke();
          }
          for(let y = 0; y < height; y += actualGridSize){
            context.beginPath();
            context.moveTo(0,y);
            context.lineTo(width,y);
            context.stroke();
          }
        }
      },
      {   // biome_2
        name: "Galactic Nebula",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Создаём эффект туманной галактики с помощью радиального градиента
          let grad = context.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height) / 2);
          grad.addColorStop(0, "#2a2a72");   // тёмно-синий/фиолетовый
          grad.addColorStop(0.5, "#9c27b0");   // яркий пурпурный
          grad.addColorStop(1, "#0d0d0d");     // почти чёрный
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          
          for (let i = 0; i < 50; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            let radius = Math.random() * 50 + 20;
            context.beginPath();
            context.arc(x, y, radius, 0, Math.PI * 2);
            context.fillStyle = "rgba(156,39,176,0.1)";
            context.fill();
          }
          
          // Рассыпка случайных звёзд
          for (let i = 0; i < 200; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            context.fillStyle = "rgba(255,255,255," + (Math.random() * 0.8) + ")";
            context.fillRect(x, y, 2, 2);
          }
        }
      },
      {   // biome_3
        name: "Neon Abyss",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Радиационный градиент от темно-синего к чёрному
          let grad = context.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height)/2);
          grad.addColorStop(0, "#000033");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          // Рисуем «неоновые пузыри»
          for (let i = 0; i < 50; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            let r = Math.random() * 30 + 10;
            context.beginPath();
            context.arc(x, y, r, 0, Math.PI * 2);
            context.strokeStyle = "rgba(0,255,255,0.3)";
            context.lineWidth = 4 * scaleFactor;
            context.shadowColor = "rgba(0,255,255,0.8)";
            context.shadowBlur = 15 * scaleFactor;
            context.stroke();
            context.shadowBlur = 0;
          }
        }
      },
      {   // biome_4
        name: "Pixelated Matrix",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Чёрный фон
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          // Рисуем случайные «биты» в стиле матрицы
          context.fillStyle = "rgba(0,255,0,0.2)";
          const fontSize = 32;
          context.font = fontSize + "px monospace";
          for (let i = 0; i < 100; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            context.fillText(Math.random() > 0.5 ? "0" : "1", x, y);
          }
        }
      },
      {   // biome_5
        name: "Retro Wave",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Градиент от пурпурного к оранжевому
          let grad = context.createLinearGradient(0, 0, 0, height);
          grad.addColorStop(0, "rgba(128,0,128,0.7)");
          grad.addColorStop(1, "rgba(0,255,255,0.9)");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          // Лёгкая сетка
          context.strokeStyle = "rgba(255,255,255,0.1)";
          context.lineWidth = 1 * scaleFactor;
          for (let x = 0; x < width; x += 50 * scaleFactor) {
            context.beginPath();
            context.moveTo(x, 0);
            context.lineTo(x, height);
            context.stroke();
          }
          for (let y = 0; y < height; y += 50 * scaleFactor) {
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(width, y);
            context.stroke();
          }
        }
      },
      { // biome_6
        name: "Cyber Circuit",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          // Рисуем «схемные» линии и узлы
          context.strokeStyle = "#00f";
          context.lineWidth = 2 * scaleFactor;
          // Desktop: re-generate glitch EVERY frame
          for (let i = 0; i < 20; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x + (Math.random() - 0.5) * 100, y + (Math.random() - 0.5) * 100);
            context.stroke();
          }
          for (let i = 0; i < 10; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            context.beginPath();
            context.arc(x, y, Math.random() * 20, 0, Math.PI * 2);
            context.stroke();
          }
        }
      },
      { // biome_7
        name: "Digital Dystopia",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Градиент тёмно-красного к чёрному
          let grad = context.createLinearGradient(0, 0, width, height);
          grad.addColorStop(0, "#330000");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          // Desktop: re-generate glitch EVERY frame
          for (let i = 0; i < 40; i++) {
            context.fillStyle = "rgba(0,255,0,0.1)";
            let x = Math.random() * width;
            let y = Math.random() * height;
            let w = Math.random() * 80;
            let h = Math.random() * 20;
            context.fillRect(x, y, w, h);
          }
        }
      },
      { // biome_8
        name: "Holographic Grid",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Фон с затемнённым градиентом
          let grad = context.createLinearGradient(0, 0, 0, height);
          grad.addColorStop(0, "#111");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          // Наложение полупрозрачной сетки
          context.strokeStyle = "rgba(0,255,255,0.15)";
          context.lineWidth = 1 * scaleFactor;
          let gridSize = 40 * scaleFactor;
          for (let x = 0; x < width; x += gridSize) {
            context.beginPath();
            context.moveTo(x, 0);
            context.lineTo(x, height);
            context.stroke();
          }
          for (let y = 0; y < height; y += gridSize) {
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(width, y);
            context.stroke();
          }
        }
      },
      { // biome_9
        name: "Laser Lair",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          // Desktop: re-generate glitch EVERY frame
          for (let i = 0; i < 15; i++) {
            context.beginPath();
            let startX = Math.random() * width;
            let startY = Math.random() * height;
            let angle = Math.random() * Math.PI * 2;
            let length = Math.random() * 200 + 100;
            context.moveTo(startX, startY);
            context.lineTo(startX + Math.cos(angle) * length, startY + Math.sin(angle) * length);
            context.strokeStyle = "rgba(255,0,0,0.5)";
            context.lineWidth = 4 * scaleFactor;
            context.shadowColor = "rgba(255,0,0,1)";
            context.shadowBlur = 10 * scaleFactor;
            context.stroke();
            context.shadowBlur = 0;
          }
        }
      },
      { // biome_10
        name: "Virtual Vortex",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          // Рисуем вихревые линии, создающие эффект воронки
          let centerX = width / 2;
          let centerY = height / 2;
          // Desktop: re-generate glitch EVERY frame
          for (let i = 0; i < 30; i++) {
            context.beginPath();
            let radius = (i / 30) * Math.max(width, height) / 2;
            context.arc(centerX, centerY, radius, Math.PI * 0.5 + i * 0.2, Math.PI * 1.5 + i * 0.2);
            context.strokeStyle = "rgba(0,255,255," + (0.1 + i / 300) + ")";
            context.lineWidth = 3 * scaleFactor;
            context.stroke();
          }
        }
      },
      { // biome_11
        name: "Cyber Grid",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          const grad = context.createLinearGradient(0,0,width,height);
          grad.addColorStop(0, "#001a00");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0,0,width,height);
          const gridSize = 60;
          context.strokeStyle = "rgba(0,255,100,0.2)";
          context.lineWidth = 1 * scaleFactor;
          for(let x = 0; x < width; x += actualGridSize2){
            context.beginPath();
            context.moveTo(x,0);
            context.lineTo(x,height);
            context.stroke();
          }
          for(let y = 0; y < height; y += actualGridSize2){
            context.beginPath();
            context.moveTo(0,y);
            context.lineTo(width,y);
            context.stroke();
          }
        }
      },
      { // biome_12
        name: "Digital Void",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0,0,width,height);
          // Desktop: re-generate glitch EVERY frame
          for(let i=0;i<150;i++){
            const x = Math.random()*width;
            const y = Math.random()*height;
            context.fillStyle = "#fff";
            context.fillRect(x,y,2,2);
          }
        }
      },
      // Добавляем новые биомы:
      { // biome_13
        name: "Cyber Grid Cyan",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          const grad = context.createLinearGradient(0,0,width,height);
          grad.addColorStop(0, "#001a00");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0,0,width,height);
          const gridSize = 60;
          context.strokeStyle = "rgba(0,255,255,0.2)";
          context.lineWidth = 1 * scaleFactor;
          for(let x = 0; x < width; x += actualGridSize2){
            context.beginPath();
            context.moveTo(x,0);
            context.lineTo(x,height);
            context.stroke();
          }
          for(let y = 0; y < height; y += actualGridSize2){
            context.beginPath();
            context.moveTo(0,y);
            context.lineTo(width,y);
            context.stroke();
          }
        }
      },
      { // biome_14
        name: "Aurora Borealis",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Используем линейный градиент для имитации северного сияния
          let grad = context.createLinearGradient(0, 0, 0, height);
          grad.addColorStop(0, "#1a237e");
          grad.addColorStop(0.5, "#43a047");
          grad.addColorStop(1, "#fdd835");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          // Добавляем плавные линии, имитирующие сияние
          for (let i = 0; i < 10; i++) {
            context.beginPath();
            context.moveTo(0, Math.random() * height);
            context.bezierCurveTo(
              width * 0.3, Math.random() * height,
              width * 0.7, Math.random() * height,
              width, Math.random() * height
            );
            context.strokeStyle = "rgba(255, 255, 255, 0.1)";
            context.lineWidth = 2 * scaleFactor;
            context.stroke();
          }
        }
      },
      { // biome_15
        name: "Cyber Grid Violet",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          const grad = context.createLinearGradient(0,0,width,height);
          grad.addColorStop(0, "#001a00");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0,0,width,height);
          const gridSize = 60;
          context.strokeStyle = "rgba(255,0,255,0.2)";
          context.lineWidth = 1 * scaleFactor;
          for(let x = 0; x < width; x += actualGridSize2){
            context.beginPath();
            context.moveTo(x,0);
            context.lineTo(x,height);
            context.stroke();
          }
          for(let y = 0; y < height; y += actualGridSize2){
            context.beginPath();
            context.moveTo(0,y);
            context.lineTo(width,y);
            context.stroke();
          }
        }
      },
      {   // biome_16
        name: "Glitch Zone",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Always draw the (current) glitchCanvas first.
          context.drawImage(glitchCanvas, 0, 0);
          // Desktop: re-generate glitch EVERY frame
          generateGlitchPattern();
        }
      },
      {   // biome_17
        name: "Cosmic Rift",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Радиационный градиент, создающий космическое настроение
          let grad = context.createRadialGradient(width / 2, height / 2, 0, width / 2,    height / 2, Math.max(width, height) / 2);
          grad.addColorStop(0, "#0d0d0d");
          grad.addColorStop(0.5, "#1a1a1a");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          // Desktop: re-generate glitch EVERY frame
          // Рисуем звёзды
          for (let i = 0; i < 100; i++) {
            context.fillStyle = "#fff";
            let x = Math.random() * width;
            let y = Math.random() * height;
            context.fillRect(x, y, 1.5 * scaleFactor, 1.5 * scaleFactor);
          }
          // Лёгкие круговые вспышки для эффекта космических рифтов
          for (let i = 0; i < 5; i++) {
            context.beginPath();
            context.arc(Math.random() * width, Math.random() * height, Math.random() * (100 * scaleFactor),     0, Math.PI * 2);
            context.strokeStyle = "rgba(255, 0, 255, 0.1)";
            context.lineWidth = 5 * scaleFactor;
            context.shadowColor = "rgba(255, 0, 255, 0.1)";
            context.shadowBlur = 10;
            context.stroke();
          }
        }
      },
      {   // biome_18
        name: "Retro Circuit",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Фон в стиле печатной платы
          context.fillStyle = "#001";
          context.fillRect(0, 0, width, height);
          context.strokeStyle = "rgba(0,255,0,0.4)";
          context.lineWidth = 3 * scaleFactor;
          // Вертикальные линии
          for (let x = 0; x < width; x += actualGridSize40) {
            context.beginPath();
            context.moveTo(x, 0);
            context.lineTo(x, height);
            context.stroke();
          }
          // Горизонтальные линии
          for (let y = 0; y < height; y += actualGridSize40) {
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(width, y);
            context.stroke();
          }
          // Рисуем случайные "узлы" для имитации контактов
          for (let i = 0; i < 20; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            context.beginPath();
            context.arc(x, y, 3 * scaleFactor, 0, Math.PI * 2);
            context.fillStyle = "rgba(0,255,0,0.4)";
            context.fill();
          }
        }
      },
      {   // biome_19
        name: "Neon Forest",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Тёмный фон с неоновыми "деревьями"
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          // Рисуем неоновые столбы (как абстрактные деревья)
          for (let i = 0; i < 10; i++) {
            let x = Math.random() * width;
            let treeHeight = Math.random() * (height / 2) + height / 4;
            context.beginPath();
            context.moveTo(x, height);
            context.lineTo(x, height - treeHeight);
            context.strokeStyle = "rgba(0,255,150,0.7)";
            context.lineWidth = 4 * scaleFactor;
            context.shadowColor = "rgba(0,255,150,0.7)";
            context.shadowBlur = 10;
            context.stroke();
            context.shadowBlur = 0;
          }
        }
      },
      {    // biome_20 
        name: "Mirror Infinity",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          const grad = context.createLinearGradient(0, 0, width, height);
          grad.addColorStop(0, "#111");
          grad.addColorStop(1, "#333");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          for (let i = 0; i < 50; i++) {
            let x1 = Math.random() * width;
            let y1 = Math.random() * height;
            let x2 = x1 + (Math.random() - 0.5) * 200;
            let y2 = y1 + (Math.random() - 0.5) * 200;
            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.strokeStyle = "rgba(0,255,255,0.3)";
            context.lineWidth = 2 * scaleFactor;
            context.stroke();
          }
        }
      },
      {     // biome_21
        name: "Laser Stage",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          const time = performance.now() / 1000;
          for (let i = 0; i < 8; i++) {
            let angle = (i / 8) * Math.PI * 2 + time;
            let x1 = width / 2;
            let y1 = height / 2;
            let x2 = x1 + Math.cos(angle) * width;
            let y2 = y1 + Math.sin(angle) * height;
            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.strokeStyle = "rgba(255,0,0,0.5)";
            context.lineWidth = 4 * scaleFactor;
            context.shadowColor = "rgba(255,0,0,0.8)";
            context.shadowBlur = 10;
            context.stroke();
            context.shadowBlur = 0;
          }
        }
      },
      {     // biome_22
        name: "Hexagonal Rhythm",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#111";
          context.fillRect(0, 0, width, height);
          const hexSize = 30 * scaleFactor;
          const hexHeight = hexSize * Math.sqrt(3);
          const alpha = 0.6; // Плавное изменение от 0 до 1
          for (let row = 0; row < height / hexHeight; row++) {
            for (let col = 0; col < width / (hexSize * 1.5); col++) {
              let x = col * hexSize * 1.5;
              let y = row * hexHeight + (col % 2 === 0 ? 0 : hexHeight / 2);
              context.beginPath();
              for (let i = 0; i < 6; i++) {
                let angle = (i / 6) * Math.PI * 2;
                let px = x + Math.cos(angle) * hexSize;
                let py = y + Math.sin(angle) * hexSize;
                if (i === 0) context.moveTo(px, py);
                else context.lineTo(px, py);
              }
              context.closePath();
              context.fillStyle = `rgba(0,255,255,${alpha})`;
              context.fill();
            }
          }
        }
      },
      {     // biome_23
        name: "Low Gravity DISCO",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          for (let i = 0; i < 15; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            let w = Math.random() * 100 + 50;
            let h = Math.random() * 20 + 10;
            context.beginPath();
            context.rect(x, y, w, h);
            context.strokeStyle = "rgba(0,255,255,0.7)";
            context.lineWidth = 3 * scaleFactor;
            context.shadowColor = "rgba(0,255,255,0.7)";
            context.shadowBlur = 10;
            context.stroke();
            context.shadowBlur = 0;
          }
        }
      },
      {     // biome_24
        name: "Light Waves",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          const time = performance.now() / 1000;
          for (let i = 0; i < 10; i++) {
            let offset = (time + i * 0.5) % 1;
            let y = offset * height;
            context.beginPath();
            context.moveTo(0, y);
            context.bezierCurveTo(width * 0.3, y + 50, width * 0.7, y - 50, width, y);
            context.strokeStyle = "rgba(0,255,255,0.5)";
            context.lineWidth = 4 * scaleFactor;
            context.stroke();
          }
        }
      },
      {   // biome_25  
        name: "Retro 80s Disco",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#111";
          context.fillRect(0, 0, width, height);
          for (let i = 0; i < 5; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            let size = Math.random() * 50 + 20;
            context.beginPath();
            context.arc(x, y, size, 0, Math.PI * 2);
            context.fillStyle = "rgba(255,105,180,0.2)";
            context.shadowColor = "rgba(255,105,180,0.2)";
            context.shadowBlur = 10;
            context.fill();
            context.shadowBlur = 0;
          }
          for (let i = 0; i < 10; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            let w = Math.random() * 100 + 50;
            let h = Math.random() * 20 + 10;
            context.fillStyle = "rgba(0,255,255,0.3)";
            context.shadowColor = "rgba(0,255,255,0.3)";
            context.shadowBlur = 10;
            context.fillRect(x, y, w, h);
            context.shadowBlur = 0;
          }
        }
      },
      {     // biome_26
        name: "Cyber Future Disco",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#001";
          context.fillRect(0, 0, width, height);
          const gridSize = 50 * scaleFactor;
          context.strokeStyle = "rgba(0,255,255,0.2)";
          context.lineWidth = 1 * scaleFactor;
          for (let x = 0; x < width; x += gridSize) {
            context.beginPath();
            context.moveTo(x, 0);
            context.lineTo(x, height);
            context.stroke();
          }
          for (let y = 0; y < height; y += gridSize) {
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(width, y);
            context.stroke();
          }
          for (let i = 0; i < 30; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            context.beginPath();
            context.arc(x, y, 5 * scaleFactor, 0, Math.PI * 2);
            context.fillStyle = "rgba(0,255,255,0.8)";
            context.fill();
          }
        }
      },
      {     // biome_27
        name: "Underwater Party",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          const grad = context.createLinearGradient(0, 0, 0, height);
          grad.addColorStop(0, "#001a33");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          for (let i = 0; i < 50; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            let r = Math.random() * 20 + 5;
            context.beginPath();
            context.arc(x, y, r, 0, Math.PI * 2);
            context.strokeStyle = "rgba(0,255,255,0.3)";
            context.lineWidth = 2 * scaleFactor;
            context.stroke();
          }
          for (let i = 0; i < 5; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x + 20, y + 10);
            context.lineTo(x - 20, y + 10);
            context.closePath();
            context.fillStyle = "rgba(255,0,255,0.2)";
            context.shadowColor = "rgba(255,0,255,0.2)";
            context.shadowBlur = 10;
            context.fill();
            context.shadowBlur = 0;
          }
        }
      },
      {     // biome_28
        name: "Rotating Chaos",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          const time = performance.now() / 1000;
          for (let i = 0; i < 20; i++) {
            let radius = 100 + i * 50;
            let angle = time * (i + 1);
            context.beginPath();
            context.arc(width / 2, height / 2, radius * scaleFactor, angle, angle + Math.PI * 2);
            const specColor = i % 2 === 0 ? "rgba(0,255,255,0.5)" : "rgba(138,43,226,0.5)"
            context.strokeStyle = specColor;
            context.lineWidth = 5 * scaleFactor;
            context.shadowColor = specColor;
            context.shadowBlur = 10;
            context.stroke();
            context.shadowBlur = 0;
          }
        }
      }
    ];
    const demoBiomes = biomes.slice(0, 8); // Берем первые 5 биомов
    function getCurrentBiome() {
      const biomesToUse = isFV ? biomes : demoBiomes;
      return biomesToUse[(currentLevel - 1) % biomesToUse.length];
    }

    // Outside your draw function, create an offscreen canvas & context
    const glitchCanvas = document.createElement('canvas');
    const glitchCtx = glitchCanvas.getContext('2d');

    // We'll keep a frame counter so we can throttle updates on mobile
    let glitchFrameCounter = 0;

    // This function draws a new random glitch pattern onto glitchCanvas
    function generateGlitchPattern() {
      glitchCanvas.width = width;    // match your main canvas dimensions
      glitchCanvas.height = height;
      
      // 1) Solid black background
      glitchCtx.fillStyle = "#000";
      glitchCtx.fillRect(0, 0, width, height);
      
      // 2) Random color rectangles
      for (let i = 0; i < 30; i++) {
        glitchCtx.fillStyle = `rgba(
          ${Math.floor(Math.random() * 256)},
          ${Math.floor(Math.random() * 256)},
          ${Math.floor(Math.random() * 256)},
          0.2
        )`;
        let x = Math.random() * width;
        let y = Math.random() * height;
        let w = Math.random() * (50 * scaleFactor);
        let h = Math.random() * (20 * scaleFactor);
        glitchCtx.fillRect(x, y, w, h);
      }
      
      // 3) Random horizontal lines
      for (let i = 0; i < 10; i++) {
        glitchCtx.beginPath();
        let y = Math.random() * height;
        glitchCtx.moveTo(0, y);
        glitchCtx.lineTo(width, y);
        glitchCtx.strokeStyle = "rgba(255,255,255,0.1)";
        glitchCtx.lineWidth = (Math.random() * 3) * scaleFactor;
        glitchCtx.stroke();
      }
    }
    
    // =================== Classes ===================
    // --- Player ---
    class Player {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 15 * scaleFactor;
        this.maxHP = 100;
        this.currentHP = 100;
        this.baseSpeed = 3 * scaleFactor;
        this.speed = this.baseSpeed;
        this.reflectedKillCount = 0;
        // Temporary power‑ups (duration in ms)
        this.activePowerUps = {
          // Double Shot – позволяет одновременно выпускать две пули с небольшим угловым отклонением.
          doubleShot: { duration: 0, stacks: 0 },
          // Triple Shot – позволяет стрелять тремя пулями одновременно, повышая шанс попадания.
          tripleShot: { duration: 0, stacks: 0 },
          // Rapid Fire – ускоряет стрельбу, уменьшая интервал между выстрелами.
          rapidFire: { duration: 0, stacks: 0 },
          // Shield – создает временный защитный щит вокруг игрока, уменьшая получаемый урон
          // от боссов (только половина урона) и полностью блокируя урон от обычных врагов.
          shield: { duration: 0, stacks: 0 },
          // Speed Boost – временно увеличивает скорость передвижения игрока (×2).
          speedBoost: { duration: 0, stacks: 0 },
          // Damage Boost – повышает наносимый урон за счет увеличения силы выстрелов.
          damageBoost: { duration: 0, stacks: 0 },
          // Piercing – пули с этим эффектом могут пробивать нескольких врагов подряд.
          piercing: { duration: 0, stacks: 0 },
          // Homing – пули с автонаведением, корректирующие траекторию в сторону ближайшего врага.
          homing: { duration: 0, stacks: 0 },
          // Bomb – пули, взрывающиеся при попадании и наносящие урон в области взрыва.
          bomb: { duration: 0, stacks: 0 },
          // Freeze Blast – замораживает врагов, снижая их скорость или полностью останавливая их на время.
          freezeBlast: { duration: 0, stacks: 0 },
          // Reflective – пули, которые отскакивают от границ экрана, увеличивая вероятность попадания.
          reflective: { duration: 0, stacks: 0 },
          // Life Steal – при попадании пули возвращают часть здоровья игроку.
          lifeSteal: { duration: 0, stacks: 0 },
          // EMP Blast – пули, которые могут временно оглушать или замедлять врагов, воздействуя на их электронику.
          empBlast: { duration: 0, stacks: 0 },
          // Critical Strike – увеличивает шанс нанести критический урон (например, двойной урон).
          criticalStrike: { duration: 0, stacks: 0 },
          // Overcharge – увеличивает скорость пуль.
          overcharge: { duration: 0, stacks: 0 },
          // Scatter Shot – добавляет +4 пули за каждый стэк.
          scatterShot: { duration: 0, stacks: 0 },
          // *** NEW: временное увеличение здоровья (увеличивает maxHP на +20) ***
          healthBoost: { duration: 0, stacks: 0, bonus: 0 },
          // *** NEW: магнит очков (притягивает коллекционные объекты) ***
          scoreMagnet: { duration: 0, stacks: 0 },
          // *** NEW: Friend power‑up – при получении появляется друг рядом с игроком ***
          friend: { duration: 0, stacks: 0 },
          neonOverdrive: { duration: 0, stacks: 0 }, // Добавлено
          // удвоение прироста powerMeter
          powerMeterBoost: { duration: 0, stacks: 0 },
          // Пуль всем хватит:
          bulletTime: { duration: 0, stacks: 0 },
          acidRain: { duration: 0, stacks: 0 },
          ninjaSpirit: { duration: 0, stacks: 0 },
          lightSaber: { duration: 0, stacks: 0, color: "#fff"},
          
        };
        // Additional status effects (негативные эффекты)
        this.frozenTime = 0;
        this.shootingDisabled = 0;
        this.empSlowed = 0;
        this.angle = 0;
        
      }
      update(deltaTime) {
        for (let key in this.activePowerUps) {
          const consumedEffectsNeonOverdrive = ["friend", "scoreMagnet", "neonOverdrive", "powerMeterBoost", "damageBoost", "shield", "speedBoost", "ninjaSpirit"];
          const consumedEffectsLightSaber = ["friend", "scoreMagnet","neonOverdrive", "lightSaber", "powerMeterBoost", "damageBoost", "shield", "speedBoost", "ninjaSpirit"];
          const consumedEffectsAcidRain = ["friend", "scoreMagnet", "acidRain", "lightSaber", "neonOverdrive", "powerMeterBoost","damageBoost", "shield", "speedBoost", "ninjaSpirit"];
          const preservedForBulletTimeOnly = ["doubleShot", "tripleShot", "scatterShot","ninjaSpirit"];
          const consumedEffectsBulletTimeOnly = allPowerUpKeys.filter(key => !preservedForBulletTimeOnly.includes(key));
          const preservedForEffectsHoming = ["ninjaSpirit"];
          const consumedEffectsHomingOnly = allPowerUpKeys.filter(key => !preservedForEffectsHoming.includes(key));
          let consumedList;
          let pu = this.activePowerUps[key];
          if (pu.duration > 0) {
            // Определяем список, по которому будем расходовать время для данного набора активных эффектов:
            if (this.activePowerUps.neonOverdrive && this.activePowerUps.neonOverdrive.duration > 0) {
              consumedList = consumedEffectsNeonOverdrive;
            } else if (this.activePowerUps.lightSaber && this.activePowerUps.lightSaber.duration > 0) {
              consumedList = consumedEffectsLightSaber;
            } else if (this.activePowerUps.acidRain && this.activePowerUps.acidRain.duration > 0) {
              consumedList = consumedEffectsAcidRain;
            } else if (this.activePowerUps.bulletTime && this.activePowerUps.bulletTime.duration > 0) {
              consumedList = consumedEffectsBulletTimeOnly;
            } else if (this.activePowerUps.homing && this.activePowerUps.homing.duration > 0) {
              consumedList = consumedEffectsHomingOnly;
            } else {
              consumedList = allPowerUpKeys;
            }
            
            // Если текущий эффект входит в список расходуемых – уменьшаем его длительность
            if (consumedList.includes(key)) {
              pu.duration -= deltaTime;
              if (pu.duration < 0) pu.duration = 0;
            }
            // Если эффект не входит в список – его время остаётся неизменным

            // Сохраняем предыдущее количество стэков, чтобы понять, сколько стэков "упало" за этот кадр
            let previousStacks = pu.stacks || 0;
            let displayName = getPowerUpDisplayName(key);
            let timePerStack = powerUpDurations[displayName] || 30000;
            pu.stacks = pu.duration > 0 ? Math.ceil(pu.duration / timePerStack) : 0;
        
            // Если это Health Boost – снимаем бонус постепенно (по 50 за каждый потерянный стэк)
            if (key === "healthBoost") {
              const bonusPerStack = 70; // бонус, который даёт один стэк
              let expiredStacks = previousStacks - pu.stacks;
              if (expiredStacks > 0) {
                let bonusToRemove = bonusPerStack * expiredStacks;
                this.maxHP -= bonusToRemove;
                if (this.currentHP > this.maxHP) this.currentHP = this.maxHP;
                pu.bonus -= bonusToRemove;
                if (pu.bonus < 0) pu.bonus = 0;  // на всякий случай – не допускаем отрицательного бонуса
              }
            }
        
            // Если число стэков стало 0, обнуляем параметры эффекта
            if (pu.stacks <= 0) {
              pu.duration = 0;
              pu.stacks = 0;
              // На случай, если остаётся небольшой остаточный бонус для Health Boost – удаляем его полностью
              if (key === "healthBoost" && pu.bonus > 0) {
                this.maxHP -= pu.bonus;
                if (this.currentHP > this.maxHP) this.currentHP = this.maxHP;
                pu.bonus = 0;
              }
              if (key === "lightSaber"){
                this.reflectedKillCount = 0;
              }
            }
          }
        }
        // Если игрок заморожен, полностью блокируем движение
        if (this.frozenTime > 0) {
          this.frozenTime -= deltaTime;
          return;  // ранний выход — никаких изменений позиции
        }
        
        // Вычисляем базовую скорость с учётом постоянного апгрейда и временного ускорения
        let effectiveSpeed = this.baseSpeed * permanentUpgrades.speed;
        if (this.activePowerUps.speedBoost.duration > 0) {
          effectiveSpeed *= 1.8;
        }
        // Если действует EMP замедление, скорость уменьшается (в 2 раза)
        if (this.empSlowed > 0) {
          effectiveSpeed *= 0.5;
          this.empSlowed -= deltaTime;
        }
        let dx = 0, dy = 0;
        if(!isMobile) {
          if (keys.up)    dy -= 1;
          if (keys.down)  dy += 1;
          if (keys.left)  dx -= 1;
          if (keys.right) dx += 1;
        } else {
          dx = leftJoystick.dx/(80 * uiScale);
          dy = leftJoystick.dy/(80 * uiScale);
        }
        if(dx || dy) {
          const mag = Math.hypot(dx, dy);
          dx /= mag;
          dy /= mag;
          this.x += dx * effectiveSpeed;
          this.y += dy * effectiveSpeed;
        }
        
        const effectiveHeight = (isMobile && window.innerHeight > window.innerWidth)
            ? height - getBottomCropHeight()
            : height;

        // Constrain to canvas
        this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(effectiveHeight - this.radius, this.y));
        // Aiming: desktop uses mouse; mobile uses right joystick if active
        let effectiveFireRate = BASE_FIRE_RATE / permanentUpgrades.fireRate;
        if(player.activePowerUps.rapidFire.duration > 0) effectiveFireRate /= 2;
        if(player.empSlowed > 0) {
          effectiveFireRate *= 1.5;
          player.empSlowed -= deltaTime;
        }
        // Если активен Acid Rain – стрельба становится медленнее:
        if (player.activePowerUps.acidRain.duration > 0) {
          effectiveFireRate = BASE_FIRE_RATE*3;
        }
        if (!isMobile) {
          // Aim Mechanic
          if (this.activePowerUps.ninjaSpirit.duration > 0) {
            let target = getClosestTarget();
            if (target) {
              let targetVel = getTargetVelocity(target);
              
              this.angle = computeInterceptAngle(this, effectiveFireRate, target, targetVel);
            }
            // Если цели нет – можно оставить предыдущий угол или задать дефолтное значение
          } else {
            // Обычный режим – угол определяется мышью
            this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
          }
          //Old Desktop: aim with mouse
          //this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
        } else {
          if (this.activePowerUps.ninjaSpirit.duration > 0) {
            let target = getClosestTarget();
            if (target) {
              let targetVel = getTargetVelocity(target);
              this.angle = computeInterceptAngle(this, effectiveFireRate, target, targetVel);
            }
          } else {
            if (rightJoystick.active && (rightJoystick.dx || rightJoystick.dy)) {
              this.angle = rightJoystick.angle;
            }
          }

          /* Old 
          // Mobile: only use right joystick if active
          if (rightJoystick.active && (rightJoystick.dx || rightJoystick.dy)) {
            this.angle = rightJoystick.angle;
          }*/
        }
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        // Если активирован магнит, отрисовываем область его действия
        if (this.activePowerUps.scoreMagnet && this.activePowerUps.scoreMagnet.duration > 0) {
          let baseAttractionRange = 200 * scaleFactor; // базовая дистанция (в пикселях)
          let additionalRangePerStack = 100 * scaleFactor; // прибавка за каждый дополнительный стэк
          let magnetRange = (baseAttractionRange + additionalRangePerStack * (this.activePowerUps.scoreMagnet.stacks - 1));

          ctx.beginPath();
          ctx.arc(0, 0, magnetRange, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)'; // полупрозрачный зелёный цвет
          ctx.shadowColor = 'rgba(0, 255, 0, 0.5)';
          ctx.shadowBlur = 5;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        // Используем проверку длительности для щита:
        if(this.activePowerUps.shield.duration > 0) {
          ctx.beginPath();
          ctx.arc(0,0,this.radius+(8* scaleFactor),0,Math.PI*2);
          ctx.fillStyle = "rgba(0,200,255,0.3)";
          ctx.fill();
        }
        ctx.fillStyle = "#0ff";
        ctx.shadowColor = "#0ff";
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.moveTo( (20*scaleFactor), 0 );
        ctx.lineTo( (-10*scaleFactor),  (10*scaleFactor) );
        ctx.lineTo( (-10*scaleFactor), (-10*scaleFactor) );
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
    // Помогательная функция для нормализации угла в диапазоне [-π, π]
    function normalizeAngle(angle) {
      while (angle > Math.PI) { angle -= 2 * Math.PI; }
      while (angle < -Math.PI) { angle += 2 * Math.PI; }
      return angle;
    }

    // =================== Изменённый класс Friend ===================
    class Friend {
      constructor(offsetAngle) {
        this.offsetAngle = offsetAngle; // фиксированный угол смещения относительно игрока
        this.shootCooldown = 0;
        // Инициализируем позицию в текущем положении игрока (если он уже существует)
        this.x = player ? player.x : 0;
        this.y = player ? player.y : 0;
        // Инициализируем угол "друга" равным углу игрока
        this.angle = player ? player.angle : 0;
      }
      update(deltaTime) {
        if (!player) return;
      
        // Задаём желаемое расстояние от игрока
        const followDistance = 30 * scaleFactor; // можно менять по вкусу
        // Вычисляем желаемую позицию относительно игрока с учётом угла игрока и смещения
        const desiredX = player.x + Math.cos(player.angle + this.offsetAngle) * followDistance;
        const desiredY = player.y + Math.sin(player.angle + this.offsetAngle) * followDistance;


      
        // Перемещаем друга к желаемой позиции
        const diffX = (desiredX - this.x) * scaleFactor;
        const diffY = (desiredY - this.y) * scaleFactor;
        const dist = (Math.hypot(diffX, diffY));
        const catchUpSpeed = (0.4 * deltaTime) * scaleFactor;
        if (dist > 1) {
          const moveDist = Math.min(catchUpSpeed, dist);
          this.x += (diffX / dist) * moveDist * scaleFactor;
          this.y += (diffY / dist) * moveDist * scaleFactor;
        }
      
        // Автонаведение: ищем ближайшего врага для прицеливания
        let nearest = null;
        let minEnemyDist = Infinity;
        for (let enemy of enemies) {
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const d = Math.hypot(dx, dy);
          if (d < minEnemyDist) {
            minEnemyDist = d;
            nearest = enemy;
          }
        }
        // Если враг найден – целевой угол по направлению к нему, иначе используем угол игрока
        let targetAngle = player.angle;
        if (nearest) {
          targetAngle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
        }
      
        // Плавное поворот: постепенно приближаем this.angle к targetAngle
        let angleDiff = normalizeAngle(targetAngle - this.angle);
        const rotationSpeed = 0.010 * deltaTime * scaleFactor; // настройте скорость поворота по необходимости
        if (Math.abs(angleDiff) < rotationSpeed) {
          this.angle = targetAngle;
        } else {
          this.angle += Math.sign(angleDiff) * rotationSpeed;
        }
      
        // Логика стрельбы: стреляем только если угол почти совпадает с целевым (порог 0.1 радиана)
        this.shootCooldown -= deltaTime;
        let friendFireRate = 400 / permanentUpgrades.fireRate; // базовый интервал в мс

        let friendStacks = player.activePowerUps.friend.stacks || 1;
        if (player.activePowerUps.friend && player.activePowerUps.friend.stacks >= 3) {
          friendFireRate = (400 / (1 + 0.5 * (friendStacks - 1))) * scaleFactor;  // при 3+ стэках – ускоряем стрельбу
        }
        if (this.shootCooldown <= 0 && Math.abs(normalizeAngle(targetAngle - this.angle)) < 0.1) {
          let bullet = new Bullet(this.x, this.y, this.angle,1 * player.activePowerUps.damageBoost.stacks * permanentUpgrades.damage,"friend");
          bullet.fromFriend = true;  // Помечаем пулю как выпущенную другом
          bullets.push(bullet);
          this.shootCooldown = friendFireRate;
        }        
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        // Используем угол, рассчитанный для объекта Friend
        ctx.rotate(this.angle);
        ctx.fillStyle = "#A31FA3"; // фиолетовый цвет
        ctx.shadowColor = "#A31FA3";
        ctx.shadowBlur = 20;
        ctx.beginPath();
        // Рисуем уменьшенную копию фигуры игрока (масштаб 0.5)
        ctx.moveTo((20 * 0.5) * scaleFactor, 0);
        ctx.lineTo((-10 * 0.5) * scaleFactor, (10 * 0.5) * scaleFactor);
        ctx.lineTo((-10 * 0.5) * scaleFactor, (-10 * 0.5) * scaleFactor);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = "#0ff";
        ctx.lineWidth = 2 * scaleFactor;
        ctx.stroke();

        ctx.restore();
      }
    }
    // Функция для вычисления расстояния от точки (px,py) до линии, задаваемой двумя точками (x1,y1) и (x2,y2)
    function distancePointToLine(px, py, x1, y1, x2, y2) {
      let A = px - x1;
      let B = py - y1;
      let C = x2 - x1;
      let D = y2 - y1;

      let dot = A * C + B * D;
      let len_sq = C * C + D * D;
      let param = (len_sq !== 0) ? (dot / len_sq) : -1;

      let xx, yy;
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }
      let dx = px - xx;
      let dy = py - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Помогательная функция для вычисления точки пересечения луча с границами канвы
    function getRayIntersection(x, y, angle, width, height) {
      let tValues = [];
      const cosA = Math.cos(angle), sinA = Math.sin(angle);
      if(cosA > 0) {
        let t = (width - x) / cosA;
        if(t >= 0) tValues.push(t);
      } else if(cosA < 0) {
        let t = (0 - x) / cosA;
        if(t >= 0) tValues.push(t);
      }
      if(sinA > 0) {
        let t = (height - y) / sinA;
        if(t >= 0) tValues.push(t);
      } else if(sinA < 0) {
        let t = (0 - y) / sinA;
        if(t >= 0) tValues.push(t);
      }
      if(tValues.length === 0) return {x: x, y: y};
      let tMin = Math.min(...tValues);
      return { x: x + cosA * tMin, y: y + sinA * tMin };
    }

    // =================== Класс AcidTrail (след от Acid Rain) ===================
    class AcidTrail {
      constructor(x, y, angle) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.duration = 15000; // След живёт ? мс
        this.damagePerSecond = 0.1 * permanentUpgrades.damage * (1+player.activePowerUps.damageBoost.stacks); // Урон единицы в секунду
        this.length = 0;  // начальная длина линии равна 0
        // Задаём скорость удлинения.
        // Если пуля движется со скоростью 6 * scaleFactor, можно установить, например:
        this.extensionSpeed = BASE_FIRE_RATE * 3 * scaleFactor;
      }
      update(deltaTime) {
        this.duration -= deltaTime;
        if(this.duration < 0) this.duration = 0;

        // Вычисляем конечную точку луча по пересечению с границами канвы

        // ==== было
        //const endPoint = getRayIntersection(this.x, this.y, this.angle, width, height);

        const endPoint = {
          x: this.x + Math.cos(this.angle) * this.length,
          y: this.y + Math.sin(this.angle) * this.length
        };

        let actualTime = isMobile ? 1700 : 430;
        // ==== стало
        this.length += this.extensionSpeed * (deltaTime / actualTime);
    
        // (Опционально) Ограничиваем длину максимальной величиной, чтобы AcidTrail не выходил за границы канвы.
        const maxEnd = getRayIntersection(this.x, this.y, this.angle, width, height);
        const maxLength = Math.hypot(maxEnd.x - this.x, maxEnd.y - this.y);
        if (this.length > maxLength) {
          this.length = maxLength;
        }

        // Проверка коллизий с врагами
        enemies.forEach(enemy => {
          let dist = distancePointToLine(enemy.x, enemy.y, this.x, this.y, endPoint.x, endPoint.y);
          if (dist < enemy.radius) {
            // Наносим урон: если враг щитован – сначала щит, иначе напрямую HP
            if (enemy.type === "shielded" && enemy.shield && enemy.shieldHP > 0) {
              enemy.shieldHP -= this.damagePerSecond;
            } else {
              enemy.hp -= this.damagePerSecond;
            }
            // Эффект попадания
            if(enemy.hp <= 0) {
              if(enemy.type === "exploder") {
                // When an exploder dies, it explodes—damaging nearby enemies.
                for(let k=0; k<enemies.length; k++){
                  const dx = enemy.x - enemy.x;
                  const dy = enemy.y - enemy.y;
                  if(Math.hypot(dx,dy) < 80) {
                    enemy.hp -= 5;
                  }
                }
              }
              if(enemy.type === "splitter") {
                // Splitter splits into two basic enemies when killed.
                enemies.push(new Enemy(enemy.x, enemy.y, "basic"));
                enemies.push(new Enemy(enemy.x, enemy.y, "basic"));
              }
              for(let k=0; k<20; k++){
                particles.push(new Particle(enemy.x, enemy.y, enemy.color));
              }
              spawnCollectible(enemy.x, enemy.y);
              score += (enemy.type==="elite")?200:100;
              enemy.dead = true;
              onEnemyKilled(enemy);
            }
            else{
              for (let blood = 0; blood < 8; blood++) {
                particles.push(new Particle(enemy.x, enemy.y, enemy.color));
              }
            }
          }
        });
        // Проверка коллизий с боссами
        bosses.forEach(boss => {
          let dist = distancePointToLine(boss.x, boss.y, this.x, this.y, endPoint.x, endPoint.y);
          if (dist < boss.radius) {
            boss.hp -= this.damagePerSecond;
            for (let blood = 0; blood < 8; blood++) {
              particles.push(new Particle(boss.x, boss.y, "#f00"));
            }
          }
        });

        // *** Новый блок: уничтожение пуль врагов при столкновении с лучом ***
        bullets.forEach(b => {
          // Рассматриваем только пули, выпущенные врагами или боссами
          if (b.fromEnemy || b.fromBoss) {
            let dist = distancePointToLine(b.x, b.y, this.x, this.y, endPoint.x, endPoint.y);
            // Если использовать для отрисовки луча lineWidth = 8*scaleFactor, то его "половина" равна 4*scaleFactor.
            // Добавляем также радиус пули для более корректного расчёта.
            if (dist < (b.radius + 4 * scaleFactor)) {
              b.dead = true;
            }
          }
        });
      }
      draw() {
        ctx.save();
        ctx.lineWidth = 5 * scaleFactor;
        ctx.strokeStyle = "rgba(0,255,0,0.5)";
        ctx.shadowColor = "#00ff00";
        ctx.shadowBlur = 20 * scaleFactor;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        //const endPoint = getRayIntersection(this.x, this.y, this.angle, width, height);

        // Вычисляем конечную точку на основе текущей длины
        const endX = this.x + Math.cos(this.angle) * this.length;
        const endY = this.y + Math.sin(this.angle) * this.length;
        ctx.lineTo(endX, endY); 

        //ctx.lineTo(endPoint.x, endPoint.y);
        ctx.stroke();
        ctx.restore();
      }
    }
    // --- Bullet ---
    class Bullet {
      constructor(x, y, angle, dmgFactor = 1, source = "player") {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 6 * scaleFactor;
        this.radius = 4 * scaleFactor;
        this.damage = 1 * dmgFactor * (source === "player" ? permanentUpgrades.damage : 1);

        // Сохранение источника пули
        this.source = source;
        // Если пуля принадлежит игроку и активирован power‑up Acid Rain, создаём кислотный след
        if (this.source === "player" && player && player.activePowerUps.acidRain.duration > 0) {
          acidTrails.push(new AcidTrail(this.x, this.y, this.angle));
          this.hasAcidTrail = false;
        }
        this.hasAcidTrail = false;
  
        this.owner;
        // Special properties (default off)
        this.piercing = false;
        this.piercingCount = 0;
        this.homing = false;
        this.bomb = false;
        this.freezeBlast = false;
        this.empBlast = false;
        this.reflective = false;
        this.critical = false;
        this.lifeSteal = false;
        this.fromBoss = false;
        this.fromFriend = false;
        this.dead = false;
        // --- Добавлен счётчик отскоков для reflective пуль ---
        this.bounceCount = 0;
      }
      update(deltaTime) {
        // Homing effect: adjust angle toward nearest enemy
        if (this.homing && enemies.length > 0) {
          if(!this.fromBoss || !this.fromEnemy){
            let nearest = null, minDist = Infinity;
            for(let enemy of enemies) {
              const dx = enemy.x - this.x, dy = enemy.y - this.y;
              const d = Math.hypot(dx, dy);
              if(d < minDist) { minDist = d; nearest = enemy; }
            }
            if(nearest) {
              const desired = Math.atan2(nearest.y - this.y, nearest.x - this.x);
              this.angle += 0.1 * (desired - this.angle);
            }
          } 
        }
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        // --- Обработка отражения reflective пуль ---
        const effectiveHeight = (isMobile && window.innerHeight > window.innerWidth)
          ? height - getBottomCropHeight()
          : height;

        if(!this.reflective && (this.x < -10 || this.x > width+10 || this.y < -10 || this.y > effectiveHeight+10)) {
          this.dead = true;
        }
        if(this.reflective) {
          let bounced = false;
          if(this.x < this.radius) {
            this.x = this.radius;
            this.angle = Math.PI - this.angle;
            bounced = true;
          } else if(this.x > width - this.radius) {
            this.x = width - this.radius;
            this.angle = Math.PI - this.angle;
            bounced = true;
          }
          if(this.y < this.radius) {
            this.y = this.radius;
            this.angle = -this.angle;
            bounced = true;
          } else if(this.y > effectiveHeight - this.radius) {
            this.y = effectiveHeight - this.radius;
            this.angle = -this.angle;
            bounced = true;
          }
          if(bounced) {
            this.bounceCount++;
            if(this.bounceCount >= 4) { // после 3 отскоков (на 4-ом исчезает)
              this.dead = true;
            }
          }
        }
      }
      draw() {
        ctx.save();
        if (this.fromFriend) {
          ctx.fillStyle = "rgba(163, 31, 163, 0.7)";  
          ctx.shadowColor = "rgba(163, 31, 163, 0.7)";
        } else if (this.fromBoss || this.fromEnemy) {
          ctx.fillStyle = "#f00";
          ctx.shadowColor = "#f00";
        } else {
          ctx.fillStyle = "#ff0";
          ctx.shadowColor = "#ff0";
        }
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // --- Enemy ---
    class Enemy {
      constructor(x, y, type="basic") {
        this.x = x;
        this.y = y;
        this.type = type;
        this.frozenTime = 0;
        this.empTime = 0;
        this.dead = false;
        // Set properties based on type
        switch(type) {
          case "basic":
            this.radius = 15 * scaleFactor;
            this.speed = 1.5 * scaleFactor;
            this.hp = 1;
            this.color = "#ff4444";
            break;
          case "elite":  // Танк
            this.radius = 20 * scaleFactor;
            this.speed = 0.5 * scaleFactor; // fixed slower speed
            this.hp = 5;
            this.color = "#ff8000";
            break;
          case "freeze":  //Замораживает
            this.radius = 15 * scaleFactor;
            this.speed = 2.0 * scaleFactor;
            this.hp = 1;
            this.color = "#00f";
            break;
          case "shooter": // Должен стрелять (исправлено)
            this.radius = 15 * scaleFactor;
            this.speed = 1.2 * scaleFactor;
            this.hp = 2;
            this.color = "#f0f";
            this.shootCooldown = 2000;
            this.bulletDamage = 15;  // Новый параметр: урон от пули врага
            break;
          case "parasite":  // Забирает возможность стрелять
            this.radius = 12 * scaleFactor;
            this.speed = 3.0 * scaleFactor;
            this.hp = 1;
            this.color = "#0f0";
            break;
          case "emp":
            this.radius = 18 * scaleFactor;
            this.speed = 1.5 * scaleFactor;
            this.hp = 2;
            this.color = "#ff0";
            this.shootCooldown = 2500;
            this.bulletDamage = 10;  // Урон от пули emp-врага
            break;
          case "shielded":
            this.radius = 20 * scaleFactor;
            this.speed = 1.5 * scaleFactor;
            this.hp = 3;
            this.color = "#0ff";
            this.shield = true;
            this.shieldHP = 5;
            break;
          case "sharpshooter":
            this.radius = 15 * scaleFactor;
            this.speed = 0.8 * scaleFactor;
            this.hp = 2;
            this.color = "#608"; // purple tone
            this.shootCooldown = 3000;
            this.bulletDamage = 35;  // Урон от пули sharpshooter
            break;
          case "exploder":
            this.radius = 15 * scaleFactor;
            this.speed = 1.2 * scaleFactor;
            this.hp = 1;
            this.color = "#fa0"; // orange
            break;
          case "splitter":
            this.radius = 18 * scaleFactor;
            this.speed = 1.0 * scaleFactor;
            this.hp = 3;
            this.color = "#0a0"; // dark green            
            break;
          default:
            this.radius = 15 * scaleFactor;
            this.speed = 1.5 * scaleFactor;
            this.hp = 1;
            this.color = "#ff4444";
        }
        // Добавляем усложнение: каждые 3 уровня враги получают +1 к HP
        this.hp += Math.floor(currentLevel / 3);
      }
      update(deltaTime) {
        // If frozen, do not move
        if(this.frozenTime > 0) {
          this.frozenTime -= deltaTime;
          return;
        }
        // Slow down if under EMP effect
        let effSpeed = this.speed;
        if(this.empTime > 0) {
          effSpeed *= 0.5;
          this.empTime -= deltaTime;
        }
        if(this.type === "shooter") {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.hypot(dx, dy);
          const preferredDistance = 250 * scaleFactor;
          if(dist > preferredDistance) {
            this.shootCooldown -= deltaTime;
            this.x += (dx/dist) * this.speed * (deltaTime/16);
            this.y += (dy/dist) * this.speed * (deltaTime/16);
          } else {
            this.shootCooldown -= deltaTime;
            if(this.shootCooldown <= 0) {
              const angle = Math.atan2(dy, dx);
              let spawnX = this.x + Math.cos(angle) * (this.radius + 5);
              let spawnY = this.y + Math.sin(angle) * (this.radius + 5);
              let b = new Bullet(spawnX, spawnY, angle, 1, "enemy");
              b.fromEnemy = true;         // Помечаем как пуля врага
              b.speed = 6 * scaleFactor;
              b.damage = Math.max(0, this.bulletDamage + bonusDamage - permanentUpgrades.damageReduction); // Урон берётся из врага
              bullets.push(b);
              this.shootCooldown = 2000;
            }
          }
        }
        if(this.type === "emp") {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.hypot(dx, dy);
          const preferredDistance = 150 * scaleFactor;
          if(dist > preferredDistance) {
            this.shootCooldown -= deltaTime;
            this.x += (dx/dist) * this.speed * (deltaTime/16);
            this.y += (dy/dist) * this.speed * (deltaTime/16);
          } else {
          this.shootCooldown -= deltaTime;
          if(this.shootCooldown <= 0) {
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              let b = new Bullet(this.x, this.y, angle, 1, "enemy");
              b.empBlast = true;
              b.speed = 4 * scaleFactor;
              b.damage = Math.max(0, this.bulletDamage + bonusDamage - permanentUpgrades.damageReduction);
              b.fromEnemy = true;  // Помечаем как пуля врага
              bullets.push(b);
              this.shootCooldown = 2500;
            }
          }
        }
        if(this.type === "sharpshooter") {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.hypot(dx, dy);
          const preferredDistance = 550 * scaleFactor;
          if(dist > preferredDistance) {
            this.shootCooldown -= deltaTime;
            this.x += (dx/dist) * this.speed * (deltaTime/16);
            this.y += (dy/dist) * this.speed * (deltaTime/16);
          } else {
            this.shootCooldown -= deltaTime;
            if(this.shootCooldown <= 0) {
              const angle = Math.atan2(dy, dx);
              let spawnX = this.x + Math.cos(angle) * this.radius;
              let spawnY = this.y + Math.sin(angle) * this.radius;
              let b = new Bullet(spawnX, spawnY, angle, 1, "enemy");
              b.fromEnemy = true;        // Помечаем как пуля врага
              b.radius = 8 * scaleFactor;
              b.speed = 7 * scaleFactor;
              b.damage = Math.max(0, this.bulletDamage + bonusDamage - permanentUpgrades.damageReduction);
              bullets.push(b);
              this.shootCooldown = 3000;
            }
          }
        }
        // Для остальных врагов – стандартное движение (как было)
        if(this.type !== "shooter" && this.type !== "sharpshooter") {
          const dx = player.x - this.x, dy = player.y - this.y;
          const dist = Math.hypot(dx,dy);
          if(dist !== 0) {
            this.x += (dx/dist) * effSpeed;
            this.y += (dy/dist) * effSpeed;
          }
        }
        const effectiveHeight = (isMobile && window.innerHeight > window.innerWidth)
        ? height - getBottomCropHeight()
        : height;
        if (this.x < this.radius) {
          this.x = this.radius;
        } else if (this.x > width - this.radius) {
          this.x = width - this.radius;
        }
        if (this.y < this.radius) {
          this.y = this.radius;
        } else if (this.y > effectiveHeight - this.radius) {
          this.y = effectiveHeight - this.radius;
        }
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        ctx.fillStyle = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
          
        switch (this.type) {
          case "basic":
            // Простой спайковый круг (6 спайков, spikeFactor = 0.2)
            drawSpikyCircle(ctx, this.radius, 6, 0.2);
            break;
          case "elite":
            // Рисуем шестиугольник
            drawPolygon(ctx, 6, this.radius);
            break;
          case "freeze":
            // Снежинка – для врагов, замораживающих игрока
            drawSnowflake(ctx, this.radius);
            break;
          case "shooter":
            // Турель – для врагов, которые стреляют
            drawTurret(ctx, this.radius);
            break;
          case "parasite":
            // Эллипс – для тонких, быстрых врагов
            drawEllipse(ctx, 1.2 * this.radius, 0.6 * this.radius);
            break;
          case "emp":
            // Зазубренная фигура – для врагов, применяющих EMP
            drawJaggedShape(ctx, this.radius);
            break;
          case "shielded":
            // Отрисовываем круг и затем добавляем защитный контур
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.save();
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
            break;
          case "sharpshooter":
            // Треугольник – символизирует меткость
            drawTriangle(ctx, this.radius);
            break;
          case "exploder":
            // Форма "бомбы"
            drawBomb(ctx, this.radius);
            break;
          case "splitter":
            // Сегментированная фигура
            drawSegmentedShape(ctx, this.radius);
            break;
          default:
            // Если тип не распознан – стандартный круг
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Если враг заморожен, накладываем прозрачный синий слой
        if (this.frozenTime > 0) {
          ctx.fillStyle = "rgba(0,200,255,0.5)";
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }
    }

    // --- Boss ---
    class Boss {
      // Добавляем параметры x и y, чтобы можно было задавать позицию спавна
      constructor(x, y) {
        // Если координаты заданы, используем их, иначе стандартно центр по горизонтали и y = 100
        this.x = (typeof x === 'number') ? x : width / 2;
        this.y = (typeof y === 'number') ? y : 100;
        
        // Базовый размер босса
        const minBossSize = 20;
        this.baseRadius = Math.max(60 / Math.pow(2, Math.floor((currentLevel - 1) / 5)), minBossSize);
        this.radius = this.baseRadius * scaleFactor;
        this.stunDuration = 0;
        // Базовые HP и скорость
        this.bossBaseHP = 50;
        let bossDifficulty = currentLevel < 4 ? 0.6 : 1;
        this.maxHP = Math.floor((this.bossBaseHP + currentLevel * 25 * 1.5) * bossDifficulty);  //Hard-mode
        this.hp = this.maxHP;
        const MAX_BOSS_SPEED = 5 * scaleFactor;
        this.speed = Math.min(((1 + currentLevel * 0.1) * bossDifficulty) * scaleFactor, MAX_BOSS_SPEED);
        
        // Определяем титул босса
        if (currentLevel % 15 === 0) this.tier = "Emperor";
        else if (currentLevel % 10 === 0) this.tier = "Champion";
        else if (currentLevel % 5 === 0) this.tier = "Elite";
        else this.tier = "Easy";
        
        // Вместо одного shootCooldown используем массив для всех 5 паттернов
        this.shootCooldown = 3000;
        // --- Добавлен параметр для замедления от Freeze Blast ---
        this.freezeSlow = 0;
      }

      update(deltaTime) {
        // Определяем максимальную стадию, доступную на текущем уровне:
        const maxStage = ((currentLevel - 1) % 5) + 1;
        // Вычисляем соотношение оставшегося здоровья:
        const hpRatio = this.hp / this.maxHP;
        // По умолчанию boss находится на самой "низкой" стадии (максимальное число)
        let stage = maxStage;
        // Для maxStage=5 пороговые значения: >0.8 → stage 1, >0.6 → stage 2, >0.4 → stage 3, >0.2 → stage 4, иначе 5.
        // Для меньшего maxStage масштабируем пороги пропорционально.
        for (let s = 1; s < maxStage; s++) {
          if (hpRatio > (maxStage - s) / maxStage) {
            stage = s;
            break;
          }
        }
        // Теперь stage изменяется от 1 (при почти полном HP) до maxStage (при критически малом HP).
      
        // --- Шаг 1: Определяем эффективную скорость с учётом эффекта Freeze Blast ---
        let effectiveSpeed = this.speed;
        if(this.freezeSlow > 0) {
          effectiveSpeed *= 0.5;
          this.freezeSlow -= deltaTime;
        }
        if (this.stunDuration > 0) {
          this.stunDuration -= deltaTime;
        }else{
          // --- Движение босса ---
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist !== 0) {
            let currentSpeed = effectiveSpeed;
            if (stage >= 4) currentSpeed *= 1.2;
            this.x += (dx / dist) * currentSpeed;
            this.y += (dy / dist) * currentSpeed;
          }
          // Добавляем небольшое колебание: если достигнута максимальная (самая "низкая") стадия и она равна 5,
          // добавляем дрожание, иначе — небольшое косинусоидальное смещение.
          if (stage === 5) {
            this.x += (Math.random() - 0.5) * 5;
            this.y += (Math.random() - 0.5) * 5;
          } else {
            this.x += Math.cos(performance.now() / 500) * 0.5;
          }
        
          // --- Шаблоны стрельбы в зависимости от стадии ---
          this.shootCooldown -= deltaTime;
          if (this.shootCooldown <= 0) {
            if (stage === 1) {
              const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
              for (let offset of [-0.1, 0, 0.1]) {
                let b = new Bullet(this.x, this.y, baseAngle + offset, 1, "boss");
                b.fromBoss = true;
                b.speed = 5 * scaleFactor;
                b.damage = Math.max(0, 20 + bonusDamage - permanentUpgrades.damageReduction);
                bullets.push(b);
              }
              this.shootCooldown = 3000;
            } else if (stage === 2) {
              const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
              for (let offset of [-0.2, -0.1, 0, 0.1, 0.2]) {
                let b = new Bullet(this.x, this.y, baseAngle + offset, 1, "boss");
                b.fromBoss = true;
                b.speed = 6 * scaleFactor;
                b.damage = Math.max(0, 25 + bonusDamage - permanentUpgrades.damageReduction);
                bullets.push(b);
              }
              this.shootCooldown = 2000;
            } else if (stage === 3) {
              const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
              for (let offset of [-0.1, 0, 0.1]) {
                let b = new Bullet(this.x, this.y, baseAngle + offset, 1, "boss");
                b.fromBoss = true;
                b.speed = 6 * scaleFactor;
                b.damage = Math.max(0, 30 + bonusDamage - permanentUpgrades.damageReduction);
                b.homing = true;
                bullets.push(b);
              }
              this.shootCooldown = 1000;
            } else if (stage === 4) {
              for (let i = 0; i < 8; i++) {
                let angle = i * (Math.PI * 2 / 8);
                let b = new Bullet(this.x, this.y, angle, 1, "boss");
                b.fromBoss = true;
                b.speed = 7 * scaleFactor;
                b.damage = Math.max(0, 20 + bonusDamage - permanentUpgrades.damageReduction);
                bullets.push(b);
              }
              this.shootCooldown = 500;
            } else if (stage === 5) {
              const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
              for (let offset of [-0.3, -0.15, 0, 0.15, 0.3]) {
                let b = new Bullet(this.x, this.y, baseAngle + offset, 1, "boss");
                b.fromBoss = true;
                b.speed = 8 * scaleFactor;
                b.damage = Math.max(0, 35 + bonusDamage - permanentUpgrades.damageReduction);
                bullets.push(b);
              }
              this.shootCooldown = 150;
            }
          }
        }
      }
      
      draw() {
        // --- Определяем цвет босса в зависимости от оставшегося HP ---
        let bossColor = "#ff0"; // по умолчанию – желтый
        if (this.hp < this.maxHP * 0.7) bossColor = "#ff6600"; // оранжевый при потере 30% HP
        if (this.hp < this.maxHP * 0.4) bossColor = "#f00";    // красный при критически малом HP

        // --- Отрисовка босса с выбранной формой ---
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = bossColor;
        ctx.strokeStyle = bossColor;
        ctx.lineWidth = 2;

        // Выбираем форму отрисовки в зависимости от титула (tier)
        switch (this.tier) {
          case "Emperor":
            // Звёздная фигура – символ величия
            drawStar(ctx, this.radius, 8, 0.5);
            break;
          case "Champion":
            // Многоугольник (например, с 8 сторонами)
            drawPolygon(ctx, 8, this.radius);
            break;
          case "Elite":
            // Спайковый круг с большим числом "шипов"
            drawSpikyCircle(ctx, this.radius, 12, 0.3);
            break;
          case "Easy":
          default:
            // Стандартный круг
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
        
        // Отрисовка полосы HP босса.
        // Если босс один – стандартное положение (y = 20).
        // Если боссов несколько – для босса с индексом i полоса смещается на i*30 пикселей вниз.

        // Отрисовка полосы HP босса
        // Получаем индекс босса в массиве bosses
        let index = bosses.indexOf(this);
        let barWidth, barHeight, barX, barY;
        barHeight = 20;        // высота полосы (в пикселях)
        const spacing = 47;    // вертикальное расстояние между полосами
        const gap = 10;        // горизонтальный зазор между столбцами

        // Если боссов 5 или больше – делим на два столбца
        if (bosses.length >= 5) {
          barWidth = (300 / 2) *scaleFactor; // ширина полосы уменьшается вдвое
          if (index < 4) {
            // Для босса с индексами 0–3 – левый столбец
            barX = width / 2 - (barWidth + gap);
            barY = 20 + index * spacing;
          } else {
            // Для босса с индексами 4–7 – правый столбец
            barX = width / 2 + gap;
            barY = 20 + (index - 4) * spacing;
          }
        } else {
          // Если боссов 4 или меньше – рисуем по центру
          barWidth = 300;
          barX = width / 2 - barWidth * uiScale / 2;
          barY = 20 + index * spacing;
        }
        // Отрисовка фона полосы
        ctx.fillStyle = "#222";
        //ctx.fillRect(barX, barY * uiScale, barWidth * uiScale, barHeight * uiScale);
        
        drawRoundedRect(ctx, barX, barY * uiScale, barWidth * uiScale, barHeight * uiScale, 8 * uiScale);
        // Отрисовка заполненной части (с учетом оставшегося здоровья)
        ctx.fillStyle = bossColor;
        const hpWidth = barWidth * (this.hp / this.maxHP);
        //ctx.fillRect(barX, barY * uiScale, hpWidth * uiScale, barHeight * uiScale);

        drawRoundedRect(ctx, barX, barY * uiScale, hpWidth * uiScale, barHeight * uiScale, 8 * uiScale);
        // Рамка полосы
        //ctx.strokeStyle = "#fff";
        //ctx.strokeRect(barX, barY * uiScale, barWidth * uiScale, barHeight * uiScale);
        
        /*
        let index = bosses.indexOf(this);
        const barWidth = 300, barHeight = 20;
        let barY = 20 + index * 47;
        
        ctx.fillStyle = "#222";
        ctx.fillRect(width / 2 - (barWidth * uiScale) / 2, barY * uiScale, barWidth * uiScale, barHeight * uiScale);
        ctx.fillStyle = bossColor;
        const hpWidth = barWidth * (this.hp / this.maxHP);
        ctx.fillRect(width / 2 - (barWidth * uiScale) / 2, barY * uiScale, hpWidth * uiScale, barHeight * uiScale);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(width / 2 - (barWidth * uiScale) / 2, barY * uiScale, barWidth * uiScale, barHeight * uiScale);

        // Отрисовка имени босса над полосой здоровья.
        // Вычисляем горизонтальный центр полосы:
        let resultWidth = (bosses.length >= 5) ? barWidth : (width / 2)*uiScale;
        const nameX = barX * uiScale + resultWidth;
        //const nameX = barX * uiScale + resultWidth * uiScale / 2;
        const nameY = (barY - 5) * uiScale; // имя немного выше полосы
        ctx.save();
        ctx.fillStyle = "#fff";
        ctx.font = (18 * uiScale) + "px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.tier + " Boss", nameX, nameY);
        ctx.restore();
        */
        
        ctx.save();
        ctx.fillStyle = "#fff";
        ctx.font = (18 * uiScale) + "px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.tier + " Boss", width / 2, (barY - 5) * uiScale);
        ctx.restore();
        
        
      }
    }

    // --- Collectible ---
    class Collectible {
      constructor(x,y) {
        this.x = x;
        this.y = y;
        this.radius = 8 * scaleFactor;
        this.angle = Math.random()*Math.PI*2;
        this.lifeTime = mainCollectibleLifeTime; // время жизни 15 секунд (в мс)
        this.dead = false;     // флаг, по которому будем удалять объект
      }
      update(deltaTime) {
        // Отсчитываем время жизни
        this.lifeTime -= deltaTime;
        if (this.lifeTime <= 0) {
          this.dead = true;
          return; // можно досрочно выйти из update, если объект "умер"
        }
        // *** Измененный механизм притягивания коллекционных предметов ***
        if (
          player &&
          player.activePowerUps.scoreMagnet &&
          player.activePowerUps.scoreMagnet.duration > 0
        ) {
          let dx = player.x - this.x;
          let dy = player.y - this.y;
          let dist = Math.hypot(dx, dy);
    
          // Параметры притяжения: базовая дистанция и прирост дистанции с каждым стэком
          let baseAttractionRange = 200 * scaleFactor; // базовая дистанция притяжения (в пикселях)
          let additionalRangePerStack = 100 * scaleFactor; // прибавка к дистанции за каждый дополнительный стэк
          // Вычисляем общую дистанцию притяжения в зависимости от количества стэков
          let attractionRange =
            baseAttractionRange +
            additionalRangePerStack * (player.activePowerUps.scoreMagnet.stacks - 1);
    
          // Если объект находится в пределах дистанции притяжения, притягиваем его
          if (dist < attractionRange) {
            // Вычисляем эффективную скорость игрока (учитывая power‑up Speed Boost, замедление и прочее)
            let playerEffectiveSpeed = player.baseSpeed * permanentUpgrades.speed;
            if (player.activePowerUps.speedBoost.duration > 0) {
              playerEffectiveSpeed *= 1.8;
            }
            // Новая скорость притяжения: на 1 больше, чем скорость игрока, умноженная на deltaTime
            let attractSpeed = (playerEffectiveSpeed + 1) * deltaTime;
            
            this.x += (dx / dist) * attractSpeed;
            this.y += (dy / dist) * attractSpeed;
          }
          
        }
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        let r = this.radius;
        ctx.beginPath();
        // Начинаем с верхней центральной точки сердца
        ctx.moveTo(0, -r / 2);
        // Правая половина сердца
        ctx.bezierCurveTo(r, -r * 1.3, r * 1.3, r / 3, 0, r * 1.5);
        // Левая половина сердца
        ctx.bezierCurveTo(-r * 1.3, r / 3, -r, -r * 1.3, 0, -r / 2);
        ctx.closePath();
        ctx.fillStyle = "#0f0"; // зеленый цвет для обычного collectible
        ctx.shadowColor = "#0f0";
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.restore();
      }
    }
    // --- SpecialCollectible: красный круг с зелёным контуром, дающий двойное вознаграждение ---
    class SpecialCollectible {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 8 * scaleFactor; // тот же размер, что и у обычного
        this.angle = Math.random() * Math.PI * 2;
        this.lifeTime = mainCollectibleLifeTime; // 15 секунд жизни
        this.dead = false;
      }
      update(deltaTime) {
        // Отсчитываем время жизни
        this.lifeTime -= deltaTime;
        if (this.lifeTime <= 0) {
          this.dead = true;
          return;
        }
        // *** Измененный механизм притягивания коллекционных предметов ***
        if (
          player &&
          player.activePowerUps.scoreMagnet &&
          player.activePowerUps.scoreMagnet.duration > 0
        ) {
          let dx = player.x - this.x;
          let dy = player.y - this.y;
          let dist = Math.hypot(dx, dy);
    
          // Параметры притяжения: базовая дистанция и прирост дистанции с каждым стэком
          let baseAttractionRange = 200 * scaleFactor; // базовая дистанция притяжения (в пикселях)
          let additionalRangePerStack = 70 * scaleFactor; // прибавка к дистанции за каждый дополнительный стэк
          // Вычисляем общую дистанцию притяжения в зависимости от количества стэков
          let attractionRange =
            baseAttractionRange +
            additionalRangePerStack * (player.activePowerUps.scoreMagnet.stacks - 1);
    
          // Если объект находится в пределах дистанции притяжения, притягиваем его
          if (dist < attractionRange) {
            let baseAttractSpeed = 1 * scaleFactor; // базовая скорость притяжения
            // Увеличиваем скорость притяжения пропорционально количеству стэков
            let attractSpeed = baseAttractSpeed * player.activePowerUps.scoreMagnet.stacks * deltaTime;
            this.x += (dx / dist) * attractSpeed;
            this.y += (dy / dist) * attractSpeed;
          }
        }
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        let r = this.radius;
        ctx.beginPath();
        ctx.moveTo(0, -r / 2);
        ctx.bezierCurveTo(r, -r * 1.3, r * 1.3, r / 3, 0, r * 1.5);
        ctx.bezierCurveTo(-r * 1.3, r / 3, -r, -r * 1.3, 0, -r / 2);
        ctx.closePath();
        ctx.fillStyle = "#f00"; // красный цвет для специального collectible
        ctx.shadowColor = "#0f0";
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.lineWidth = 3 * scaleFactor;
        ctx.strokeStyle = "#0f0";
        ctx.stroke();
        ctx.restore();
      }
    }

    // --- Particle ---
    class Particle {
      constructor(x,y,color) {
        this.x = x;
        this.y = y;
        this.radius = (Math.random()*3 + 2) * scaleFactor;
        this.angle = Math.random()*Math.PI*2;
        this.speed = (Math.random()*2 + 1) * scaleFactor;
        this.life = 100;
        this.color = color;
      }
      update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life -= 2;
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = Math.max(this.life/100,0);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    // =================== Global Objects & Arrays ===================
    // (Массивы и переменные уже объявлены выше)

    // =================== Utility Function ===================
    function circleCollision(a, b) {
      if (!a || !b) return false;
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx, dy) < a.radius + b.radius;
    }


    // =================== Spawning Functions ===================
    function spawnEnemy() {
      let x, y;

      const effectiveHeight = (isMobile && window.innerHeight > window.innerWidth)
          ? height - getBottomCropHeight()
          : height;

      const edge = Math.floor(Math.random() * 4);
      if (edge === 0) { x = Math.random() * width; y = -30; }
      else if (edge === 1) { x = width + 30; y = Math.random() * effectiveHeight; }
      else if (edge === 2) { x = Math.random() * width; y = effectiveHeight + 5; }
      else { x = -30; y = Math.random() * effectiveHeight; }
      let r = Math.random();
      let type = "basic";
      if(r < 0.35)          type = "basic";
      else if(r < 0.50)     type = "elite";
      else if(r < 0.60)     type = "freeze";
      else if(r < 0.70)     type = "shooter";
      else if(r < 0.75)     type = "sharpshooter";
      else if(r < 0.77)     type = "shielded";
      else if(r < 0.80)     type = "parasite";
      else if(r < 0.85)     type = "emp";
      else if(r < 0.92)     type = "exploder";
      else                   type = "splitter";
      enemies.push(new Enemy(x, y, type));
    }
    function spawnCollectible(x,y) {
      // Спавнить collectible только с вероятностью 50%
      if (Math.random() < 0.5) {
        collectibles.push(new Collectible(x, y));
      }
    }
    /******************************************
     **  BUTTON P: SPAWN 2 BOSSES (LEVEL 7)    **
     ******************************************/
    function spawnTwoBosses() {
      let bossCount = Math.pow(2, Math.floor((currentLevel - 1) / 5));
      bossCount = Math.min(bossCount, 8);
      if(bossCount>8)
      {
        bossCount=8;
      }
      bossCount=8; // -----------------   Временно
          
      // Если один босс – стандартный спавн
      if (bossCount === 1) {
        bosses.push(new Boss());
      } else {
        // Вычисляем базовый радиус, который уже учитывает уменьшение при currentLevel > 5
        let baseRadius = 60 * scaleFactor;
        if (currentLevel > 5) baseRadius *= 0.5;
        // Для равномерного расположения вычисляем радиус окружности так,
        // чтобы расстояние между центрами соседних боссов было равно 2 * baseRadius.
        let spawnCircleRadius = baseRadius / Math.sin(Math.PI / bossCount);
        
        // Центр спавна (можно изменить по желанию)
        let centerX = width / 2;
        let centerY = 100;
        
        for (let i = 0; i < bossCount; i++) {
          let angle = (2 * Math.PI * i) / bossCount;
          let bossX = centerX + spawnCircleRadius * Math.cos(angle);
          let bossY = centerY + spawnCircleRadius * Math.sin(angle);
          bosses.push(new Boss(bossX, bossY));
        }
      }
    }
    function givePlayerMagnetEffect() {
      applyPowerUp("Damage Boost");
      applyPowerUp("Friend");
      applyPowerUp("Health Boost");
      applyPowerUp("Critical Strike");
      applyPowerUp("Freeze Blast");
      applyPowerUp("Shield");
      applyPowerUp("Bomb");
      applyPowerUp("Rapid Fire");
      /*
      "Double Shot", "Triple Shot", "Rapid Fire", "Shield", "Speed Boost",
      "Damage Boost", "Piercing", "Homing", "Bomb", "Freeze Blast",
      "Reflective", "Life Steal", "EMP Blast", "Critical Strike", "Overcharge",
      "Scatter Shot",
      "Health Boost", "Restore Health", "Magnet", "Friend"
      */
    }
    function addFriendPowerUp() {
      if (!player) return;
      
      const key = "friend"; // Ключ для эффекта Friend в объекте activePowerUps
      // Используем длительность, заданную в словаре powerUpDurations (или 40000 мс по умолчанию)
      const friendDuration = powerUpDurations["Friend"] || 40000;
      
      // Если эффекта ещё нет (или его длительность равна 0)
      if (player.activePowerUps[key].duration <= 0) {
        player.activePowerUps[key].duration = friendDuration;
        player.activePowerUps[key].stacks = 1;
      } else {
        // Если эффект уже активен – увеличиваем длительность и число стэков
        player.activePowerUps[key].duration += friendDuration;
        player.activePowerUps[key].stacks += 1;
      }
      
      console.log(`Friend power-up applied. Current stacks: ${player.activePowerUps[key].stacks}`);
    }

    // =================== Power‑Up Mapping ===================
    // This mapping ensures that "Double Shot" becomes the property "doubleShot" etc.
    const powerUpMap = {
      "Double Shot": "doubleShot",
      "Triple Shot": "tripleShot",
      "Rapid Fire": "rapidFire",
      "Shield": "shield",
      "Speed Boost": "speedBoost",
      "Damage Boost": "damageBoost",
      "Piercing": "piercing",
      "Homing": "homing",
      "Bomb": "bomb",
      "Freeze Blast": "freezeBlast",
      "Reflective": "reflective",
      "Life Steal": "lifeSteal",
      "EMP Blast": "empBlast",
      "Critical Strike": "criticalStrike",
      "Overcharge": "overcharge",
      "Scatter Shot": "scatterShot",
      "Health Boost": "healthBoost",          // *** NEW: временное увеличение здоровья (увеличивает maxHP на +20) ***
      "Restore Health": "healthRestore",       // *** NEW: мгновенное Restore Health
      "Magnet": "scoreMagnet",            // *** NEW: притягивает коллекционные объекты (25с)
      "Friend": "friend",
      "Neon Overdrive": "neonOverdrive",   // ← новая запись
      "Power Meter Boost": "powerMeterBoost",
      "Bullet Time": "bulletTime",
      "Psi Blast": "psiBlast",
      "Acid Rain": "acidRain",
      "Ninja Spirit": "ninjaSpirit",
      "Light Saber": "lightSaber",
    };
    
    // =================== Temporary Power‑Up Pool & Durations ===================
    const powerUpPool = [
      "Double Shot", "Triple Shot", "Rapid Fire", "Shield", "Speed Boost",
      "Damage Boost", "Piercing", "Homing", "Bomb", "Freeze Blast",
      "Reflective", "Life Steal", "EMP Blast", "Critical Strike", "Overcharge",
      "Scatter Shot", "Health Boost", "Restore Health", "Magnet", "Friend", "Neon Overdrive", "Power Meter Boost", "Bullet Time", "Psi Blast", "Acid Rain", "Ninja Spirit","Light Saber",
    ];
    const demoPowerUpPool = [
        "Double Shot", "Triple Shot", "Rapid Fire", "Shield", "Speed Boost",
        "Damage Boost", "Piercing", "Homing", "Bomb", "Freeze Blast",
        "Reflective", "Life Steal", "EMP Blast", "Critical Strike", "Overcharge",
        "Scatter Shot", "Health Boost", "Magnet", "Friend", "Neon Overdrive", "Power Meter Boost", "Bullet Time"
    ];
    const allPowerUpKeys = [
      "doubleShot", "tripleShot", "rapidFire", "shield", "speedBoost", "damageBoost", "piercing", "homing", "bomb", "freezeBlast", "reflective", "lifeSteal", "empBlast", "criticalStrike", "overcharge", "scatterShot", "healthBoost", "healthRestore", "scoreMagnet", "friend", "neonOverdrive", "powerMeterBoost", "bulletTime", "psiBlast", "acidRain", "ninjaSpirit", "lightSaber"
    ];
    const powerUpDurations = {
      "Reflective": 10000, // 10 секунд для Reflective
      "Triple Shot": 28000,
      "Double Shot": 35000,
      "Shield": 25000,
      "EMP Blast": 40000,
      "Health Boost": 25000,         // *** NEW: 25 секунд
      "Magnet": 25000,          // *** NEW: 25 секунд
      "Friend": 40000,
      "Neon Overdrive": 10000,
      "Power Meter Boost": 15000, // 15 секунд
      "Bullet Time": 15000,  // 15 секунд   
      "Acid Rain": 10000,
      "Ninja Spirit": 10000,
      "Light Saber": 20000,
    };

    // =================== Temporary Power‑Up Selection ===================
    function showPowerUpMenu() {
      gameState = "powerup";
      const overlay = document.getElementById("overlay");
      const pool = isFV ? powerUpPool : demoPowerUpPool;
      const case_to_much_bullets = (player.activePowerUps.tripleShot.stacks >= 2 || player.activePowerUps.doubleShot.stacks >= 3 || player.activePowerUps.scatterShot.stacks >= 3);
      const case_to_much_bullets2 = (player.activePowerUps.tripleShot.stacks >= 1 && player.activePowerUps.doubleShot.stacks >= 1 || player.activePowerUps.scatterShot.stacks >= 1);
      const case_to_much_magnet = (player.activePowerUps.scoreMagnet.stacks >= 3)
      const case_to_much_bullet_time2 = (player.activePowerUps.bulletTime.stacks >= 2)
      const case_to_much_bullet_time = (player.activePowerUps.bulletTime.stacks >= 2)
      const case_to_much_powerMeterBoost = (player.activePowerUps.powerMeterBoost.stacks >= 4) && currentLevel<30
      const case_to_much_neonOverDrive = (player.activePowerUps.neonOverdrive.stacks >= 2)
      const case_no_neon_overdrive = (player.activePowerUps.acidRain.stacks >= 1 || player.activePowerUps.bulletTime.stacks >= 1 || player.activePowerUps.lightSaber.stacks >= 1 || case_to_much_bullets)
      // Фильтруем pool: исключаем усиления, у которых игрок уже достиг максимума стаков
      const availablePool = pool.filter(choice => {
        if (!player) return true; // на всякий случай
        if (choice === "Triple Shot" && case_to_much_bullets) return false;
        if (choice === "Double Shot" && case_to_much_bullets) return false;
        if (choice === "Scatter Shot" && case_to_much_bullets) return false;
        if (choice === "Magnet" && case_to_much_magnet) return false;
        if (choice === "Reflective" && case_to_much_bullet_time) return false;
        if (choice === "Bullet Time" && case_to_much_bullet_time2) return false;
        if (choice === "Rapid Fire" && (case_to_much_bullets||case_to_much_bullets2)) return false;
        if (choice === "Power Meter Boost" && case_to_much_powerMeterBoost) return false;
        if (choice === "Neon Overdrive" && (case_to_much_neonOverDrive || case_no_neon_overdrive)) return false;
        if (choice === "Ninja Spirit" && player.activePowerUps.ninjaSpirit >= 2) return false;
        return true;
      });

      let options = [];
      while (options.length < 3 && availablePool.length > 0) {
        let randomIndex = Math.floor(Math.random() * availablePool.length);
        let choice = availablePool[randomIndex];
        if (!options.includes(choice)) {
          options.push(choice);
        }
      }

      // Если по каким-то причинам список пустой – можно сразу возобновить игру
      if(options.length === 0) {
        resumeGame();
        return;
      }

      overlay.innerHTML = `<h1>Power-Up Ready!</h1>
        <p>Choose one temporary power-up:</p>
        <div>
          ${options.map((option, index) => `<button class="button" id="pu${index+1}">${option}</button>`).join("")}
        </div>`;
      overlay.classList.remove("hidden");
      
      options.forEach((option, index) => {
        document.getElementById("pu" + (index + 1))
          .addEventListener("click", () => applyPowerUp(option));
      });
    }
    // =================== Функция применения усиления ===================
    function applyPowerUp(choice,comboPowerUp=false) {
      // *** NEW: При выборе "Restore Health" – мгновенное восстановление 30 HP (учитывая текущий maxHP) ***
      const key = powerUpMap[choice];
      if (choice === "Restore Health") {
          // Пример мгновенного эффекта
          player.currentHP = Math.min(player.maxHP, player.currentHP + (Math.floor(player.maxHP * 0.3)));
          powerMeter = Math.max(0, powerMeter - getPowerMeterMax());
          resumeGame();
          return;
      } else if (choice === "Light Saber") {
        // Задаём длительность усиления как обычно
        const timePerStack = powerUpDurations[choice] || 20000;
        if (player.activePowerUps.lightSaber.duration <= 0) {
          player.activePowerUps.lightSaber.duration = timePerStack;
          // Присваиваем случайный цвет из массива
          player.activePowerUps.lightSaber.color = randomLightsaberColors[Math.floor(Math.random() * randomLightsaberColors.length)];
        } else {
          player.activePowerUps.lightSaber.duration += timePerStack;
        }
      } else if (choice === "Health Boost") {
          // Теперь Health Boost прибавляет бонус, равный 20% от текущего maxHP игрока
          const bonusHealth = Math.floor(player.maxHP * 0.2);
          const timePerStack = powerUpDurations[choice] || 30000;
          if (player.activePowerUps[key].duration <= 0) {
              player.activePowerUps[key].duration = timePerStack;
              player.activePowerUps[key].bonus = bonusHealth;
          } else {
              player.activePowerUps[key].duration += timePerStack;
              player.activePowerUps[key].bonus += bonusHealth;
          }
          // Применяем бонус сразу же
          player.maxHP += bonusHealth;
          player.currentHP += bonusHealth;
          if(!comboPowerUp) powerMeter = 0;
          resumeGame();
          return;
      } else if (choice === "Psi Blast") {
        // Проходим по массиву врагов и устанавливаем у каждого frozenTime = 5000 (5 секунд)
        enemies.forEach(enemy => {
          enemy.frozenTime = 5000;
        });
        // Для боссов добавим новое свойство stunDuration (оглушение)
        bosses.forEach(boss => {
          boss.stunDuration = 5000;
        });

        // Создаем визуальный эффект волны в позиции игрока
        psiBlastWave = {
          x: player.x,
          y: player.y,
          radius: 0,
          // Максимальный радиус – диагональ канвы (чтобы охватить всю карту)
          maxRadius: Math.sqrt(width * width + height * height),
          duration: 500,   // эффект длится 500 мс (можно настроить)
          elapsed: 0
        };
        
        // Можно добавить эффект частиц или проиграть звук (например, playSfx ("psiBlast"))
        resumeGame();
        // Обнуляем powerMeter (если нужно)
        if(!comboPowerUp) powerMeter = 0;
        return;
      } else {
        if (key && player) {
          const timePerStack = powerUpDurations[choice] || 30000;

          // если эффект не активен (duration ≤ 0)
          if (player.activePowerUps[key].duration <= 0) {
            player.activePowerUps[key].duration = timePerStack;
          } else {
            // увеличиваем время
            player.activePowerUps[key].duration += timePerStack;
          }
        }
      }
      if(!comboPowerUp) powerMeter = 0;
      resumeGame();
    }

    // =================== Permanent Upgrade (Show menu) ===================

    function showHTMLMenu(version){
      const overlay = document.getElementById("overlay");
      // Определяем список возможных перманентных улучшений с их весами (относительные вероятности)
      let upgrades = [
        { id: "upgDamage", name: "Damage Up", weight: 40 },
        { id: "upgSpeed", name: "Speed Up", weight: 30 },
        { id: "upgFireRate", name: "Fire Rate Up", weight: 20 },
        { id: "upgHealth", name: "Health Up", weight: 10 },
        { id: "upgDamageReduction", name: "Damage Reduction Up", weight: 20 }
      ];
      // Если Fire Rate уже выше 6.5, исключаем эту опцию
      if (permanentUpgrades.fireRate > 6.5) {
        upgrades = upgrades.filter(upg => upg.id !== "upgFireRate");
      }
      // Выбираем 3 уникальных улучшения с учётом их весов
      const chosenUpgrades = [];
      const availableUpgrades = [...upgrades]; // создаём копию массива, чтобы не менять исходный список
      for (let i = 0; i < 3; i++) {
        // Вычисляем суммарный вес для оставшихся улучшений
        const totalWeight = availableUpgrades.reduce((sum, upg) => sum + upg.weight, 0);
        let random = Math.random() * totalWeight;
        let selectedIndex = 0;
        // Ищем случайное улучшение согласно весам
        for (let j = 0; j < availableUpgrades.length; j++) {
          random -= availableUpgrades[j].weight;
          if (random < 0) {
            selectedIndex = j;
            break;
          }
        }
        chosenUpgrades.push(availableUpgrades[selectedIndex]);
        availableUpgrades.splice(selectedIndex, 1); // удаляем выбранное, чтобы избежать повторения
      }
      // Формируем HTML с кнопками для выбранных улучшений
      const buttonsHTML = chosenUpgrades
        .map(upg => `<button class="button" id="${upg.id}">${upg.name}</button>`)
        .join("");
        if(version===1){ //resumeGame()
          overlay.innerHTML = `<h1>YOU ARE MONSTER!!!</h1>
          <p>Choose your permanent upgrade:</p>
          <div>${buttonsHTML}</div>`
        } else { // nextLevel()
          overlay.innerHTML = `<h1>Level ${currentLevel} Complete!</h1>
          <p>Choose your permanent upgrade:</p>
          <div>${buttonsHTML}</div>`
        } 
      ;
      overlay.classList.remove("hidden");
      // Назначаем обработчики событий для каждой кнопки
      chosenUpgrades.forEach(upg => {
        document.getElementById(upg.id).addEventListener("click", () => {
          switch (upg.name) {
            case "Damage Up":
              permanentUpgrades.damage += 0.5;
              break;
            case "Speed Up":
              permanentUpgrades.speed += 0.2;
              break;
            case "Fire Rate Up":
              permanentUpgrades.fireRate += 0.5;
              break;
            case "Health Up":
              permanentUpgrades.health += 30;
              if (player) {
                player.maxHP += 15;
                player.currentHP += 15;
              }
              break;
            case "Damage Reduction Up":
              // Например, увеличиваем на 1 единицу
              permanentUpgrades.damageReduction += 4;
              break;
          }
          version===1? resumeGame(): nextLevel();
        });
      });
    }

    // =================== Permanent Upgrade ===================

    function showPermanentUpgradeMenu() {
      playSfx("powerup");
      gameState = "transition";
      showHTMLMenu(1);
    }

    // =================== Permanent Upgrade (Level Transition) ===================

    function showTransitionMenu() {
      playSfx("powerup");
      gameState = "transition";
      showHTMLMenu(2);
    }

    function nextLevel() {
      currentLevel++;
      if (currentLevel > 5) {
        levelDuration = Math.min(levelDuration + 2000, maxLevelDuration);
      }
      levelTimer = levelDuration;
      enemySpawnTimer = 0;
      // Очищаем массивы
      enemies.length = 0;
      bullets.length = 0;
      //collectibles.length = 0;   //Hard-mode
      particles.length = 0;
      bosses.length = 0;
      resumeGame();
    }
    let wasMusicPlaying = false;

    // =================== Pause & Game Over ===================
    function pauseGame() {
      playSfx("click");
      if (gameState === "playing") {
        gameState = "pause";
        const overlay = document.getElementById("overlay");
        overlay.innerHTML = `
          <div class="pause-menu">
            <h2>Paused</h2>
            
            <div class="pause-menu-buttons">
              <button class="button" id="resumeBtn">Resume</button>
              <button class="button" id="restartBtn">Restart</button>
              <button class="button" id="menuBtn">Main Menu</button>
            </div>

            <button class="button" id="pauseMusicToggleBtn"></button>
            <button class="button" id="toggleAudioBtn">Audio Settings</button>

            <div id="audioSettingsContainer" class="collapsible-container">
              <div id="audioSettingsInner">

                <label class="mute-label">
                  <input type="checkbox" id="muteCheckbox" class="mute-checkbox"/>
                  Mute All
                </label>
          
                <div class="slider-container">
                  <label class="slider-label">Music Volume</label>
                  <input type="range" id="musicVolumeSlider" class="slider neon-slider"
                        min="0" max="1" step="0.01"  value="${ Math.sqrt(musicVolume).toFixed(2) }">
                </div>
          
                <div class="slider-container">
                  <label class="slider-label">SFX Volume</label>
                  <input type="range" id="sfxVolumeSlider" class="slider neon-slider"
                        min="0" max="1" step="0.01" value="${ Math.sqrt(sfxVolume).toFixed(2) }">
                </div>
          
                <!-- Music Genre Select -->
                <div class="slider-container">
                  <label class="slider-label">Music Genre</label>
                  <select id="musicGenreSelect" class="neon-select">
                    <option value="calm">Calm</option>
                    <option value="phonk">Phonk</option>
                    <option value="custom">Custom</option>
                  </select>
                </div>
          
                <div id="musicNavContainer" class="music-nav">
                  <button class="button" id="nextTrackBtn">»</button>
                  <button class="button" id="loopTrackBtn">⟳</button>
                </div>

                <!-- Custom tracks UI -->
                <div id="customTracksContainer">
                  <!-- A button to toggle/hide the custom list area -->
                  <button class="button" id="toggleCustomTracksBtn">Custom Tracks</button>

                  <!-- Hidden by default, we'll toggle with JS. -->
                  <div id="customTracksList" style="display: none; margin-top: 10px;">
                    <h3 id="customTracksCount">Custom Tracks (0)</h3>
                    <ul id="customTracksUL" style="list-style-type: none; padding-left: 0;"></ul>

                    <div style="margin-top: 10px;">
                      <!-- Hidden file input -->
                      <input type="file" id="customTrackFile" accept="audio/*" style="display: none;"/>
                      <!-- Neon label for the file picker -->
                      <label for="customTrackFile" id="customFileLabel" class="file-choose-btn">
                        Choose a file
                      </label>
                      <!-- Text area for "No file chosen" or the selected filename -->
                      <span id="customFileName" class="file-chosen-label">No file chosen</span>

                      <!-- Add Track button -->
                      <button class="button" id="addCustomTrackBtn">Add Track</button>
                    </div>
                  </div>
                </div>

              </div><!-- end #audioSettingsInner -->
            </div><!-- end #audioSettingsContainer -->
          </div><!-- end .pause-menu -->
        `;
        overlay.classList.remove("hidden");

        // ========== 1) Immediately pause the music  ==========
        const activeMusic = getActiveMusic();
        if (activeMusic && activeMusic.playing()) {
          wasMusicPlaying = true;  // it was playing
        }
        // Force music to pause
        if (activeMusic) activeMusic.pause();
    
        // ========== Button event handlers (Resume, Restart, Menu) ==========
        document.getElementById("resumeBtn").addEventListener("click", resumeGame);
        document.getElementById("restartBtn").addEventListener("click", restartGame);
        document.getElementById("menuBtn").addEventListener("click", mainMenu);
    
        // ========== Collapsible audio settings toggle ==========
        const audioToggleBtn = document.getElementById("toggleAudioBtn");
        const audioSettings = document.getElementById("audioSettingsContainer");
        audioToggleBtn.addEventListener("click", () => {
          playSfx("click");
          audioSettings.classList.toggle("open");
        });

        // ========== 4) NEW: Music toggle button logic ==========
        const pauseMusicToggleBtn = document.getElementById("pauseMusicToggleBtn");

        // We'll store a boolean to track "music playing in pause or not"
        // We just paused it above, so let's say it's currently "false"
        let pauseMusicPlaying = false;

        // Label the button "Music: Off" initially (since we just paused)
        pauseMusicToggleBtn.innerText = "Music: Off";
        
        // On click, we either play or pause the music
        pauseMusicToggleBtn.addEventListener("click", () => {
          const music = getActiveMusic();
          if (!music) return;
          
          if (pauseMusicPlaying) {
            // was playing in pause → now pause it
            music.pause();
            pauseMusicToggleBtn.innerText = "Music: Off";
          } else {
            // was paused in pause → now play it
            // user interaction => allowed
            try {
              music.play();
            } catch (err) {
              console.warn("Music play error:", err);
            }

            pauseMusicToggleBtn.innerText = "Music: On";
          }
          // flip the boolean
          pauseMusicPlaying = !pauseMusicPlaying;
        });
    
        // ========== Mute checkbox ==========
        const muteCheckbox = document.getElementById("muteCheckbox");
        muteCheckbox.checked = !soundEnabled;
        muteCheckbox.addEventListener("change", (e) => {
          soundEnabled = !e.target.checked;
          const activeMusic = getActiveMusic();
          if (!soundEnabled) {
            if (activeMusic && activeMusic.playing()) {
              activeMusic.pause();
            }
          } else {
            if (activeMusic && !activeMusic.playing()) {
              playCurrentMusic();
              activeMusic.play();
            }
          }
        });        

        // ========== Music Volume slider ==========
        const musicSlider = document.getElementById("musicVolumeSlider");
        musicSlider.addEventListener("input", (e) => {
          const sliderVal = parseFloat(e.target.value); // value between 0 and 1
          musicVolume = Math.pow(sliderVal, 2);
          const activeMusic = getActiveMusic();
          if (activeMusic) {
            activeMusic.volume(musicVolume);
          }
        });
    
        // ========== SFX Volume slider ==========
        const sfxSlider = document.getElementById("sfxVolumeSlider");
        sfxSlider.addEventListener("input", (e) => {
          const sliderVal = parseFloat(e.target.value);
          sfxVolume = Math.pow(sliderVal, 2);
          for (let key in sfxMap) {
            sfxMap[key].volume(sfxVolume);
          }
        });
    
        // ========== NEW: Music Genre Dropdown ==========
        const musicGenreSelect = document.getElementById("musicGenreSelect");
        // Set initial option (e.g. if 'currentMusicTrack' was 'phonk')
        musicGenreSelect.value = currentMusicTrack;
    
        musicGenreSelect.addEventListener("change", (e) => {
          // Switch global track choice
          currentMusicTrack = e.target.value;
    
          if (pauseMusicPlaying === false) {
            pauseMusicToggleBtn.click();
          }
          
          // Immediately play the chosen genre
          playCurrentMusic();
        });
    
        // ========== Next track & loop toggles ==========
        const nextTrackBtn = document.getElementById("nextTrackBtn");
        nextTrackBtn.addEventListener("click", () => {
          playSfx("click");
          nextTrack();
        });
    
        const loopTrackBtn = document.getElementById("loopTrackBtn");
        loopTrackBtn.addEventListener("click", () => {
          playSfx("click");
          loopSingleTrack = !loopSingleTrack;
          if (loopSingleTrack) {
            loopTrackBtn.style.background = "#0ff";
            loopTrackBtn.style.color = "#000";
          } else {
            loopTrackBtn.style.background = "#222";
            loopTrackBtn.style.color = "#0ff";
          }
        });

        // ===== NEW: Custom Tracks UI =====
        const toggleCustomTracksBtn = document.getElementById("toggleCustomTracksBtn");
        const customTracksListDiv = document.getElementById("customTracksList");
        const customTracksCountEl = document.getElementById("customTracksCount");
        const customTracksUL = document.getElementById("customTracksUL");
        const customTrackFileInput = document.getElementById("customTrackFile");
        const customFileNameSpan = document.getElementById("customFileName");
        const addCustomTrackBtn = document.getElementById("addCustomTrackBtn");

        // Whenever the user selects a file, update the text:
        customTrackFileInput.addEventListener("change", () => {
          if (customTrackFileInput.files.length > 0) {
            customFileNameSpan.textContent = customTrackFileInput.files[0].name;
          } else {
            customFileNameSpan.textContent = "No file chosen";
          }
        });

        // Toggle the custom tracks list area
        toggleCustomTracksBtn.addEventListener("click", () => {
          playSfx("click");
          if (customTracksListDiv.style.display === "none") {
            customTracksListDiv.style.display = "block";
          } else {
            customTracksListDiv.style.display = "none";
          }
        });

        function updateCustomTracksUI() {
          // Update the count heading
          customTracksCountEl.textContent = `Custom Tracks (${customTracks.length})`;

          // Rebuild the <ul>
          customTracksUL.innerHTML = "";
          customTracks.forEach((audioObj, index) => {
            const li = document.createElement("li");
            li.style.marginBottom = "6px";
            li.textContent = `Track #${index + 1} - ${audioObj.src}`;
            customTracksUL.appendChild(li);
          });
        }

        // When "Add Track" is clicked:
        addCustomTrackBtn.addEventListener("click", () => {
          playSfx("click");
          const file = customTrackFileInput.files[0];
          if (!file) return;
        
          const objectURL = URL.createObjectURL(file);
          const audioObj = new Howl({ src: [objectURL], volume: musicVolume, loop: false, html5: false });
          customTracks.push(audioObj);
        
          // Reset the file input for next time
          customTrackFileInput.value = "";
          customFileNameSpan.textContent = "No file chosen";
          updateCustomTracksUI();
        });

        // Initialize display to reflect any existing custom tracks
        updateCustomTracksUI();
      }
    }
    
    function resumeGame() {
      playSfx("click");
      if(gameState !== "playing") {
        const music = getActiveMusic();

        // Останавливаем все треки, кроме активного,
        // чтобы не сбросить позицию активного трека.
        calmTracks.forEach(track => {
          if (track !== music && track.playing()) {
            track.stop();
          }
        });
        phonkTracks.forEach(track => {
          if (track !== music && track.playing()) {
            track.stop();
          }
        });
        customTracks.forEach(track => {
          if (track !== music && track.playing()) {
            track.stop();
          }
        });

        if (wasMusicPlaying && soundEnabled && music && !music.playing()) {
          try {
            music.play();
          } catch (err) {
            console.warn("Ошибка при возобновлении музыки:", err);
          }
        }
        wasMusicPlaying = false;
        gameState = "playing";
        document.getElementById("overlay").classList.add("hidden");
      }
    }
    function restartGame() {
      playSfx("click");
      score = 0;
      currentLevel = 1;
      levelDuration = 30000;
      comboCounter = 0;
      levelTimer = levelDuration;
      permanentUpgrades.damage = 1;
      permanentUpgrades.speed = 1;
      permanentUpgrades.fireRate = 1;
      permanentUpgrades.health = 0;   // *** NEW: сброс здоровья ***
      permanentUpgrades.damageReduction = 0;
      powerMeter = 0;
      enemySpawnTimer = 0;
      fireCooldown = 0;
      enemies.length = 0;
      bullets.length = 0;
      miniWaves.length = 0;
      collectibles.length = 0;
      particles.length = 0;
      bosses.length = 0;
      player = new Player(width/2, height/2);
      player.maxHP = 100 + permanentUpgrades.health;  // *** NEW: учитываем перманентное здоровье
      player.currentHP = player.maxHP;
      resumeGame();
    }
    function mainMenu() {
      playSfx("click");
      gameState = "menu";

      soundEnabled = false;      
      getActiveMusic().pause();
      document.getElementById("overlay").innerHTML = `<h1 class="cyan_color" >Neon Nexus: Ultimate Gauntlet</h1>
      <p id="overlayText">Move with WASD, aim with your mouse (or use on‑screen joysticks on mobile),</br> and auto‑fire is enabled.<br>
         Fill your power meter by defeating enemies and choose temporary power‑ups.<br>
         Survive waves and defeat bosses to earn permanent upgrades!</p>
      <p id="startHint">${isMobile ? "Tap anywhere" : "Press SPACE"} to begin</p>
      <p class="cyan_color" >The game was made by the developers</br>of the game "Fearful Obscured Grounds"</p>`;
      document.getElementById("overlay").classList.remove("hidden");
    }
    function showGameOver() {
      gameState = "gameover";
      getActiveMusic().stop();
      const overlay = document.getElementById("overlay");
      overlay.innerHTML = `<h1 class="cyan_color" >Game Over</h1>
        <p>Your Score: ${Math.floor(score)}</p>
        <p>${isMobile ? "Tap anywhere" : "Press SPACE"} to restart</p>
        <p class="cyan_color" >The game was made by the developers</br> of the game "Fearful Obscured Grounds"</p>`;
      overlay.classList.remove("hidden");
    }
    // =================== Main Game Loop ===================
    let lastTime = performance.now();
    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      update(deltaTime);
      draw();
      requestAnimationFrame(gameLoop);
    }

    // =================== Main Update Function ===================
    function update(deltaTime) {
      if(gameState !== "playing") return;
      score += deltaTime * 0.05;
      // Спавн босса (или боссов) после истечения таймера
      if (bosses.length === 0) {
        levelTimer -= deltaTime;
        if (levelTimer <= 0) {
          // Определяем количество боссов:
          // Если уровень <= 5 – один босс, а дальше удачи
          let bossCount = Math.pow(2, Math.floor((currentLevel - 1) / 5));
          bossCount = Math.min(bossCount, 8); // Ограничиваем максимум 8 боссов
          if(bossCount>8)
          {
            bossCount=8;
          }
         
          // Если один босс – стандартный спавн
          if (bossCount === 1) {
            bosses.push(new Boss());
          } else {
            // Вычисляем базовый радиус, который уже учитывает уменьшение при currentLevel > 5
            let baseRadius = 60 * scaleFactor;
            if (currentLevel > 5) baseRadius *= 0.5;
            // Для равномерного расположения вычисляем радиус окружности так,
            // чтобы расстояние между центрами соседних боссов было равно 2 * baseRadius.
            let spawnCircleRadius = baseRadius / Math.sin(Math.PI / bossCount);
            
            // Центр спавна (можно изменить по желанию)
            let centerX = width / 2;
            let centerY = 100;
            
            for (let i = 0; i < bossCount; i++) {
              let angle = (2 * Math.PI * i) / bossCount;
              let bossX = centerX + spawnCircleRadius * Math.cos(angle);
              let bossY = centerY + spawnCircleRadius * Math.sin(angle);
              bosses.push(new Boss(bossX, bossY));
            }
          }
        }
      }
      if(player) {
        if(player.shootingDisabled > 0) player.shootingDisabled -= deltaTime;
        player.update(deltaTime);
      }

      // Определение скорости стрельбы
      // Adjust fire rate (rapid fire and EMP effects)
      let effectiveFireRate = BASE_FIRE_RATE / permanentUpgrades.fireRate;
      if(player.activePowerUps.rapidFire.duration > 0) effectiveFireRate /= 2;
      if(player.empSlowed > 0) {
        effectiveFireRate *= 1.5;
        player.empSlowed -= deltaTime;
      }
      // Если активен Acid Rain – стрельба становится медленнее:
      if (player.activePowerUps.acidRain.duration > 0) {
        effectiveFireRate = BASE_FIRE_RATE*3;
      }
      //Конец определения скорости стрельбы

      // Изменённая логика автострельбы с учётом стэков усилений
      if (player && player.shootingDisabled <= 0&& !( (player.activePowerUps.neonOverdrive && player.activePowerUps.neonOverdrive.duration > 0) ||
      (player.activePowerUps.lightSaber && player.activePowerUps.lightSaber.duration > 0) ) ) 
      {
        fireCooldown -= deltaTime;
        if (fireCooldown <= 0) {
          fireCooldown = effectiveFireRate;
          const bulletOffset = player.radius;
          const bx = player.x + Math.cos(player.angle) * bulletOffset;
          const by = player.y + Math.sin(player.angle) * bulletOffset;
          // Вычисляем коэффициент урона: damageBoost увеличивает урон на +1 за каждый стэк
          let dmgFactor = 1;
          if (player.activePowerUps.damageBoost.duration > 0) {
            dmgFactor = 1 + player.activePowerUps.damageBoost.stacks;
          }
          // Новая логика для подсчёта количества пуль:
          // Базово 1 пуля, но если активны усиления Double Shot и/или Triple Shot – применяем мультипликативный эффект
          let bulletCount = 1;
          let totalSpread = 0;
          if (!(player.activePowerUps.acidRain.duration > 0)) {
            // Если Double Shot активен, умножаем количество пуль на 2 для каждого стэка
            if (player.activePowerUps.doubleShot.duration > 0) {
              bulletCount *= Math.pow(2, player.activePowerUps.doubleShot.stacks);
              totalSpread += 0.1 * player.activePowerUps.doubleShot.stacks;
            }
            // Если Triple Shot активен, умножаем количество пуль на 3 для каждого стэка
            if (player.activePowerUps.tripleShot.duration > 0) {
              bulletCount *= Math.pow(3, player.activePowerUps.tripleShot.stacks);
              totalSpread += 0.15 * player.activePowerUps.tripleShot.stacks;
            }
            // Scatter Shot теперь добавляет +4 пули за каждый стэк
            if (player.activePowerUps.scatterShot.duration > 0) {
              bulletCount += 4 * player.activePowerUps.scatterShot.stacks;
              totalSpread += 0.3 * player.activePowerUps.scatterShot.stacks;
            }
            if (player.activePowerUps.bulletTime.duration > 0) {
              // Если исходное число пуль ≤ 8, прибавляем 8; иначе ставим 16 (максимум)
              bulletCount = (bulletCount <= 10) ? (bulletCount + 10) : 10 * player.activePowerUps.bulletTime.stacks;
              // При этом задаём разброс на 360 градусов (2π радиан)
              totalSpread = Math.PI * 2;
            }
          }
          // Overcharge теперь не влияет на число пуль, а ускоряет их – поэтому здесь не модифицируем bulletCount
          let newBullets = [];
          if (bulletCount > 1) {
            let startAngle = player.angle - totalSpread / 2;
            let angleStep = bulletCount > 1 ? totalSpread / (bulletCount - 1) : 0;
            for (let i = 0; i < bulletCount; i++) {
              let angle = startAngle + i * angleStep;
              let b = new Bullet(bx, by, angle, dmgFactor);
              // Применяем остальные свойства пули в зависимости от активных усилений
              if (player.activePowerUps.piercing.duration > 0) {
                b.piercing = true;
                b.piercingCount = 3 * player.activePowerUps.piercing.stacks;
              }
              if (player.activePowerUps.homing.duration > 0) {
                b.homing = true;
              }
              if (player.activePowerUps.bomb.duration > 0) {
                b.bomb = true;
              }
              if (player.activePowerUps.freezeBlast.duration > 0) {
                b.freezeBlast = true;
              }
              if (player.activePowerUps.empBlast.duration > 0) {
                b.empBlast = true;
              }
              if (player.activePowerUps.reflective.duration > 0) {
                b.reflective = true;
              }
              if (player.activePowerUps.criticalStrike.duration > 0) {
                b.critical = true;
                if (Math.random() < 0.2 * player.activePowerUps.criticalStrike.stacks) {
                  if (player.activePowerUps.criticalStrike.stacks>3)
                  {
                    b.damage *= 3 + player.activePowerUps.criticalStrike.stacks-3;
                  }else{
                    b.damage *= 3;
                  }
                }
              }
              if (player.activePowerUps.lifeSteal.duration > 0) {
                b.lifeSteal = true;
              }
              if (player.activePowerUps.overcharge.duration > 0) {
                  b.speed *= (1 + 0.5 * player.activePowerUps.overcharge.stacks);
              }
              newBullets.push(b);
            }
          } else {
            let b = new Bullet(bx, by, player.angle, dmgFactor);
            if (player.activePowerUps.piercing.duration > 0) {
              b.piercing = true;
              b.piercingCount = 3 * player.activePowerUps.piercing.stacks;
            }
            if (player.activePowerUps.homing.duration > 0) {
              b.homing = true;
            }
            if (player.activePowerUps.bomb.duration > 0) {
              b.bomb = true;
            }
            if (player.activePowerUps.freezeBlast.duration > 0) {
              b.freezeBlast = true;
            }
            if (player.activePowerUps.empBlast.duration > 0) {
              b.empBlast = true;
            }
            if (player.activePowerUps.reflective.duration > 0) {
              b.reflective = true;
            }
            if (player.activePowerUps.criticalStrike.duration > 0) {
              b.critical = true;
              if (Math.random() < 0.2 * player.activePowerUps.criticalStrike.stacks) {
                b.damage *= 2;
              }
            }
            if (player.activePowerUps.lifeSteal.duration > 0) {
              b.lifeSteal = true;
            }
            if (player.activePowerUps.overcharge.duration > 0) {
                b.speed *= (1 + 0.5 * player.activePowerUps.overcharge.stacks);
            }
            newBullets.push(b);
          }
          newBullets.forEach(b => bullets.push(b));
          
          // Play a shot sound
          playSfx("shot");
        }
      }

      // Обновляем пули
      const effectiveHeight = (isMobile && window.innerHeight > window.innerWidth)
          ? height - getBottomCropHeight()
          : height;
      for(let i = bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        b.update(deltaTime);
        if(!b.reflective && (b.x < -10 || b.x > width+10 || b.y < -10 || b.y > effectiveHeight+10)) {
          b.dead = true;
        }
      }
      // Обновляем кислотные следы (AcidRain)
      for(let i = acidTrails.length-1; i>=0; i--) {
        acidTrails[i].update(deltaTime);
        if(acidTrails[i].duration <= 0) {
          acidTrails.splice(i,1);
        }
      }
      // ===== LightSaber
      if (
        player &&
        player.activePowerUps.lightSaber &&
        player.activePowerUps.lightSaber.duration > 0 &&
        !(player.activePowerUps.neonOverdrive && player.activePowerUps.neonOverdrive.duration > 0)
      ) {
        playNeonOverdriveSound();
        let lsStacks = player.activePowerUps.lightSaber.stacks;
        // Параметры меча
        let bladeLength = 220 * scaleFactor; // длина лезвия (подберите по вкусу)
        // Расчет урона меча: базовый урон (например, 10) умноженный на постоянный бонус и количество стэков, затем делим в 2 раза
        let swordDamage = 3 * permanentUpgrades.damage * player.activePowerUps.lightSaber.stacks;
        // Определяем массив угловых смещений относительно основного направления (player.angle)
        // Здесь задаются различные схемы в зависимости от количества стэков
        let angleOffsets = [];
        if (lsStacks === 1) {
          angleOffsets = [0];
        } else if (lsStacks === 2) {
          angleOffsets = [0, Math.PI];
        } else if (lsStacks === 3) {
          angleOffsets = [0, (3 * Math.PI) / 4, (5 * Math.PI) / 4];
        } else if (lsStacks === 4) {
          angleOffsets = [0, Math.PI / 2, Math.PI, (3 * Math.PI) / 2];
        } else if (lsStacks >= 5) {
          angleOffsets = [0, Math.PI / 2, Math.PI, (3 * Math.PI) / 2];
        }
        angleOffsets.forEach(offset => {
          // Эффективный угол для текущего меча: основное направление игрока плюс смещение
          let effectiveAngle = player.angle + offset;
          
          // Начало меча – от центра игрока смещаемся на его радиус
          let bladeStartX = player.x + Math.cos(effectiveAngle) * player.radius;
          let bladeStartY = player.y + Math.sin(effectiveAngle) * player.radius;
          
          // Конец меча – на расстоянии (player.radius + bladeLength) по направлению effectiveAngle
          let bladeEndX = player.x + Math.cos(effectiveAngle) * (player.radius + bladeLength);
          let bladeEndY = player.y + Math.sin(effectiveAngle) * (player.radius + bladeLength);


          // Проверка коллизий с врагами
          enemies.forEach(enemy => {
            let dist = distancePointToLine(
              enemy.x, enemy.y,
              bladeStartX, bladeStartY,
              bladeEndX, bladeEndY
            );
            if (dist < enemy.radius) {
              // Наносим урон: если враг щитован – сначала щит, иначе напрямую HP
              if (enemy.type === "shielded" && enemy.shield && enemy.shieldHP > 0) {
                enemy.shieldHP -= swordDamage;
              } else {
                enemy.hp -= swordDamage;
              }
              // Эффект попадания
              if(enemy.hp <= 0) {
                if(enemy.type === "exploder") {
                  // When an exploder dies, it explodes—damaging nearby enemies.
                  for(let k=0; k<enemies.length; k++){
                    const dx = enemy.x - enemy.x;
                    const dy = enemy.y - enemy.y;
                    if(Math.hypot(dx,dy) < 80) {
                      enemy.hp -= 5;
                    }
                  }
                }
                if(enemy.type === "splitter") {
                  // Splitter splits into two basic enemies when killed.
                  enemies.push(new Enemy(enemy.x, enemy.y, "basic"));
                  enemies.push(new Enemy(enemy.x, enemy.y, "basic"));
                }
                for(let k=0; k<20; k++){
                  particles.push(new Particle(enemy.x, enemy.y, enemy.color));
                }
                spawnCollectible(enemy.x, enemy.y);
                score += (enemy.type==="elite")?200:100;
                enemy.dead = true;
                onEnemyKilled(enemy);
              }
              /*else{
                for (let blood = 0; blood < 8; blood++) {
                  particles.push(new Particle(enemy.x, enemy.y, enemy.color));
                }
              }*/
            }
          });
          
          // Проверка коллизий с боссами
          bosses.forEach(boss => {
            let dist = distancePointToLine(boss.x, boss.y,
            bladeStartX, bladeStartY,
            bladeEndX, bladeEndY);
            if (dist < boss.radius) {
              boss.hp -= swordDamage/12;
              /*for (let blood = 0; blood < 8; blood++) {
                particles.push(new Particle(boss.x, boss.y, "#f00"));
              }*/
            }
          });

          bullets.forEach(b => {
            // Рассматриваем только пули, выпущенные врагами или боссами
            if (b.fromEnemy || b.fromBoss) {
              let dist = distancePointToLine(b.x, b.y,
              bladeStartX, bladeStartY,
              bladeEndX, bladeEndY);
              if (dist < (b.radius + 4 * scaleFactor)) {
                b.damage = b.damage + permanentUpgrades.damageReduction;
                b.fromEnemy = false;
                b.fromBoss = false;
                b.source = "player";
                let target = getClosestTargetWithoutBullet();
                if (target) {
                  let dx = target.x - b.x;
                  let dy = target.y - b.y;
                  b.angle = Math.atan2(dy, dx);
                } else {
                  // Если противников нет, можно задать любое дефолтное направление
                  b.angle = player.angle;
                }
                b.reflected = true;
                playReflectedSound();
              }
            }
          });
        });
      }

      // ==== lightSaber Wave
      if (player && player.activePowerUps.lightSaber.duration > 0 &&
        player.activePowerUps.lightSaber.stacks >= 5) {
        lightSaberWaveTimer += deltaTime;
        if (lightSaberWaveTimer >= 3000) {
          // Применяем отбрасывание врагов
          enemies.forEach(enemy => {
            let dx = enemy.x - player.x;
            let dy = enemy.y - player.y;
            let dist = Math.hypot(dx, dy);
            if (dist > 0) {
              // Например, knockBackDistance = 4 * actualGridSize (где actualGridSize = cssGridSize)
              let knockBackDistance = 4 * actualGridSize;
              enemy.x += (dx / dist) * knockBackDistance;
              enemy.y += (dy / dist) * knockBackDistance;
              enemy.frozenTime = 2000;
            }
          });
          // Создаём визуальный эффект волны
          lightSaberWave = {
            x: player.x,
            y: player.y,
            radius: 0,
            maxRadius: Math.sqrt(width * width + height * height),
            duration: 500,  // длительность эффекта, например, 500 мс
            elapsed: 0
          };
          lightSaberWaveTimer = 0;
        }
      }

      // Обновление визуальной волны, если она существует
      if (lightSaberWave) {
        lightSaberWave.elapsed += deltaTime;
        lightSaberWave.radius = lightSaberWave.maxRadius * (lightSaberWave.elapsed / lightSaberWave.duration);
        if (lightSaberWave.elapsed >= lightSaberWave.duration) {
          lightSaberWave = null;
        }
      }
      // Если активен Neon Overdrive – стреляем лазером вместо обычных пуль
      if (player.activePowerUps.neonOverdrive.duration > 0) {
        playNeonOverdriveSound();
        // Определяем начало луча с учётом scaleFactor:
        let beamStartX = player.x + Math.cos(player.angle) * (player.radius * scaleFactor);
        let beamStartY = player.y + Math.sin(player.angle) * (player.radius * scaleFactor);
        
        // Вычисляем конец луча
        let beamLength = Math.sqrt(width * width + height * height);
        let beamEndX = beamStartX + Math.cos(player.angle) * beamLength;
        let beamEndY = beamStartY + Math.sin(player.angle) * beamLength;
        
        // Урон в секунду с учётом улучшений
        let beamDamage = 10 * permanentUpgrades.damage * player.activePowerUps.neonOverdrive.stacks;
        
        // Проверка коллизий с врагами
        enemies.forEach(enemy => {
            let dist = distancePointToLine(enemy.x, enemy.y, beamStartX, beamStartY, beamEndX, beamEndY);
            if (dist < enemy.radius) {
              // Наносим урон: если враг щитован – сначала щит, иначе напрямую HP
              if (enemy.type === "shielded" && enemy.shield && enemy.shieldHP > 0) {
                enemy.shieldHP -= beamDamage;
              } else {
                enemy.hp -= beamDamage;
              }distancePointToLine
                // Эффект попадания
                if(enemy.hp <= 0) {
                  if(enemy.type === "exploder") {
                    // When an exploder dies, it explodes—damaging nearby enemies.
                    for(let k=0; k<enemies.length; k++){
                      const dx = enemy.x - enemy.x;
                      const dy = enemy.y - enemy.y;
                      if(Math.hypot(dx,dy) < 80) {
                        enemy.hp -= 5;
                      }
                    }
                  }
                  if(enemy.type === "splitter") {
                    // Splitter splits into two basic enemies when killed.
                    enemies.push(new Enemy(enemy.x, enemy.y, "basic"));
                    enemies.push(new Enemy(enemy.x, enemy.y, "basic"));
                  }
                  for(let k=0; k<20; k++){
                    particles.push(new Particle(enemy.x, enemy.y, enemy.color));
                  }
                  spawnCollectible(enemy.x, enemy.y);
                  score += (enemy.type==="elite")?200:100;
                  enemy.dead = true;
                  onEnemyKilled(enemy);
                }
                else{
                  for (let blood = 0; blood < 8; blood++) {
                    particles.push(new Particle(enemy.x, enemy.y, enemy.color));
                  }
                }
            }
        });
        
        // Проверка коллизий с боссами
        bosses.forEach(boss => {
            let dist = distancePointToLine(boss.x, boss.y, beamStartX, beamStartY, beamEndX, beamEndY);
            if (dist < boss.radius) {
                boss.hp -= beamDamage/6;
                for (let blood = 0; blood < 8; blood++) {
                  particles.push(new Particle(boss.x, boss.y, "#f00"));
                }
            }
        });

        // *** Новый блок: уничтожение пуль врагов при столкновении с лучом ***
        bullets.forEach(b => {
            // Рассматриваем только пули, выпущенные врагами или боссами
            if (b.fromEnemy || b.fromBoss) {
                let dist = distancePointToLine(b.x, b.y, beamStartX, beamStartY, beamEndX, beamEndY);
                // Если использовать для отрисовки луча lineWidth = 8*scaleFactor, то его "половина" равна 4*scaleFactor.
                // Добавляем также радиус пули для более корректного расчёта.
                if (dist < (b.radius + 4 * scaleFactor)) {
                    b.dead = true;
                    // Можно добавить эффекты уничтожения пули (например, вспышку или частицы)
                }
            }
        });
      } 

      // Спавн врагов (если не идёт бой с боссом)
      if(bosses.length === 0) {
          // Уменьшаем таймер уровня (до спавна босса)
          levelTimer -= deltaTime;

          // Вычисляем отношение прошедшего времени (0 в начале, 1 в конце)
          let elapsedRatio = 1 - (levelTimer / levelDuration);
          // Здесь задаём динамический интервал спавна:
          // В начале (elapsedRatio ~ 0) интервал будет около 1500 мс,
          // а к концу (elapsedRatio ~ 1) – около 500 мс.
          let dynamicSpawnInterval = Math.max(500, 1500 - elapsedRatio * 1000);


        enemySpawnTimer += deltaTime;
        if(enemySpawnTimer > dynamicSpawnInterval) {
          enemySpawnTimer = 0;
          // Определяем число врагов для спавна, например, от 1 до 5 в зависимости от уровня:
          let spawnCount = Math.min(5, Math.floor(currentLevel / 2) + 1);
          for (let i = 0; i < spawnCount; i++) {
            spawnEnemy();
          }
        }
        //enemySpawnInterval = Math.max(500, 1500 - score/10);
      }
      // Обновляем врагов
      for(let i = enemies.length-1; i>=0; i--) {
        enemies[i].update(deltaTime);
        if(circleCollision(enemies[i], player)) {
          // --- Изменено: если щит активен, урон от обычных врагов блокируется полностью ---
          if(player.activePowerUps.shield.duration > 0) {
            player.activePowerUps.shield.duration = Math.max(0, player.activePowerUps.shield.duration - 100);
            // Можно отобразить специальное сообщение об уменьшении времени щита:
            damageTexts.push({ x: player.x, y: player.y, damage: "Shield -0.1s", alpha: 1, lifetime: 1000 });
            enemies[i].dead = true;
            onEnemyKilled(enemies[i]);
          } else {
            let damage = 20;
            if(enemies[i].type === "freeze") { playSfx("freeze"); player.frozenTime = 2000; damage = 10; }
            else if(enemies[i].type === "parasite") { player.shootingDisabled = 2000; damage = 10; }
            else if(enemies[i].type === "emp") { player.empSlowed = 2000; damage = 15; }
            let resultDamage = Math.max(0, damage + bonusDamage - permanentUpgrades.damageReduction);
            player.currentHP -= resultDamage;
            // --- Добавлено: отображение полученного урона красным цветом ---
            damageTexts.push({ x: player.x, y: player.y, damage: resultDamage, alpha: 1, lifetime: 1000 });
            if(player.currentHP <= 0) { gameState = "gameover"; showGameOver(); }
            enemies[i].dead = true;
            onEnemyKilled(enemies[i]);
          }
        }
      }
      // Обновляем боссов
      for(let i = bosses.length - 1; i >= 0; i--) {
        bosses[i].update(deltaTime);
        // --- Изменено: при столкновении с боссом проверяем наличие щита.
        if(circleCollision(bosses[i], player)) {
          // Вычисляем вектор от босса к игроку
          let dx = player.x - bosses[i].x;
          let dy = player.y - bosses[i].y;
          let dist = Math.hypot(dx, dy);
          // Если расстояние оказалось нулевым (на всякий случай)
          if (dist === 0) { dx = 1; dy = 0; dist = 1; }
          // Определяем расстояние отбрасывания: 5 клеток
          let knockBackDistance = 5 * actualGridSize; 
          player.x += (dx / dist) * knockBackDistance;
          player.y += (dy / dist) * knockBackDistance;
          player.x = Math.max(player.radius, Math.min(width - player.radius, player.x));
          player.y = Math.max(player.radius, Math.min(effectiveHeight - player.radius, player.y));
          if (player.activePowerUps.shield.duration > 0) {
            player.activePowerUps.shield.duration = Math.max(0, player.activePowerUps.shield.duration - 100);
            // Можно отобразить специальное сообщение об уменьшении времени щита:
            damageTexts.push({ x: player.x, y: player.y, damage: "Shield -0.1s", alpha: 1, lifetime: 1000 });
          } else {
            // Если щита нет – наносим обычный урон от босса (30 единиц)
            let bossDamage = Math.max(0, 30 + bonusDamage - permanentUpgrades.damageReduction);
            player.currentHP -= bossDamage;
            damageTexts.push({ x: player.x, y: player.y, damage: bossDamage, alpha: 1, lifetime: 1000 });
            if (player.currentHP <= 0) {
              gameState = "gameover";
              showGameOver();
            }
          }
        }
        if (bosses[i].hp <= 0) {
          playSfx("bossDeath");
          score += 1000;
          bosses.splice(i, 1);
          if(bosses.length === 0) {
            showTransitionMenu();
          }
        }
      }
      // Обновляем коллекционные предметы
      for(let i = collectibles.length-1; i>=0; i--) {
        collectibles[i].update(deltaTime);
        // Если время жизни истекло, удаляем collectible
        if (collectibles[i].dead) {
          collectibles.splice(i, 1);
          continue;
        }
        if(circleCollision(collectibles[i], player)) {
          let addValue = 20;
          // Если уровень выше 15, увеличиваем награду:
          if (currentLevel > 15) {
            // Вычисляем, сколько "пакетов" по 5 уровней прошло после 15-го:
            // Math.ceil((currentLevel - 15) / 5) возвращает 1 для уровней 16-20, 2 для 21-25 и т.д.
            let bonusMultiplier = Math.ceil((currentLevel - 15) / 5) + 1;
            // Коэффициент увеличения: 1 + 0.3 * bonusMultiplier
            addValue *= (1 + 0.3 * bonusMultiplier);
          }
          // Если собран специальный collectible, даем в 2 раза больше
          if (collectibles[i] instanceof SpecialCollectible) {
            addValue *= 3;
            // Добавляем бонус здоровья: 10% от максимального здоровья игрока
            const baseMaxHP = 100 + permanentUpgrades.health;
            const bonusHealth = Math.floor(baseMaxHP * 0.1);
            // Обновляем текущее здоровье, не превышая максимальное значение
            player.currentHP = Math.min(player.maxHP, player.currentHP + bonusHealth);
          }
          if (player.activePowerUps.powerMeterBoost && player.activePowerUps.powerMeterBoost.duration > 0) {
            addValue *= (1 + player.activePowerUps.powerMeterBoost.stacks); 
          }
          powerMeter = Math.min(getPowerMeterMax(), powerMeter+addValue);
          collectibles.splice(i,1);
        }
      }
      // Спавним специальный collectible в случайном месте, если условия выполнены
      if (currentLevel >= 5 && bosses.length > 0) {
        specialCollectibleSpawnTimer += deltaTime;
        // Каждые 5000 мс (5 секунд) пробуем заспавнить специальный объект
        if (specialCollectibleSpawnTimer >= 1000) {
          spawnSpecialCollectibleRandom();
          specialCollectibleSpawnTimer = 0;
        }
      }
      // Обновляем частицы
      for(let i = particles.length-1; i>=0; i--) {
        particles[i].update();
        if(particles[i].life <= 0) { particles.splice(i,1); }
      }
      // Обработка столкновений пуль с врагами
      for(let i = enemies.length-1; i>=0; i--) {
        for(let j = bullets.length - 1; j>=0; j--) {
          let b = bullets[j];
          if(b.fromEnemy || b.fromBoss) continue;  // только пули игрока
          if(circleCollision(enemies[i], b)) {
            if (b.bomb) {
              const explosionDamage = calculateRadiusAndDamageBomb(b);
              for (let p = enemies.length - 1; p >= 0; p--) {
                const dx = enemies[p].x - b.x;
                const dy = enemies[p].y - b.y;
                if (Math.hypot(dx, dy) < bombRadius) {
                  if (enemies[p].type === "shielded" && enemies[p].shield && enemies[p].shieldHP > 0) {
                    enemies[p].shieldHP -= b.damage;
                    enemies[p].hp -= explosionDamage;
                  } else {
                    enemies[p].hp -= explosionDamage;
                  }
                  // Отталкивание объекта от центра взрыва
                  const pushStrength = 15;
                  const impactAngle = Math.atan2(dy, dx);
                  enemies[p].x += Math.cos(impactAngle) * pushStrength;
                  enemies[p].y += Math.sin(impactAngle) * pushStrength;
                  for (let blood = 0; blood < 8; blood++) { // Кровь каждого врага
                    particles.push(new Particle(b.x, b.y, enemies[p].color));
                  }
                  if (b.freezeBlast) {
                    if (enemies[p].hp > 0) {
                      enemies[p].frozenTime = Math.max(enemies[p].frozenTime, 3000);
                      playSfx("freeze");
                    }
                  }
                  if (b.empBlast) {
                    enemies[p].empTime = Math.max(enemies[p].empTime, 3000 * player.activePowerUps.empBlast.stacks);
                  }
                  if (b.lifeSteal) {
                    player.currentHP = Math.min(player.maxHP, player.currentHP + explosionDamage * player.activePowerUps.lifeSteal.stacks);
                  }
                  // Пирсинг должен отключаться когда включён bomb
    
                  if (enemies[p].hp <= 0 && !enemies[p].dead) {
                    if (b.reflected && player.activePowerUps.lightSaber.duration > 0) {
                      player.reflectedKillCount = (player.reflectedKillCount || 0) + 1;
                      if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks > 6) {
                        player.reflectedKillCount = 0; // либо можно сбросить: = 0
                      } else if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks < 6){
                        player.activePowerUps.lightSaber.duration += 20000;
                      };
                    }
                    if (enemies[p].type === "exploder") {
                      for (let k = 0; k < enemies.length; k++) {
                        const dx = enemies[k].x - enemies[p].x;
                        const dy = enemies[k].y - enemies[p].y;
                        if (Math.hypot(dx, dy) < 80) {
                          enemies[k].hp -= 5;
                        }
                      }
                      for (let k = 0; k < 20; k++) {
                        particles.push(new Particle(enemies[p].x, enemies[p].y, "#fa0"));
                      }
                    }
                    if (enemies[p].type === "splitter") {
                      enemies.push(new Enemy(enemies[p].x, enemies[p].y, "basic"));
                      enemies.push(new Enemy(enemies[p].x, enemies[p].y, "basic"));
                    }
                    spawnCollectible(enemies[p].x, enemies[p].y);
                    score += (enemies[p].type === "elite") ? 200 : 100;
                    enemies[p].dead = true;
                    onEnemyKilled(enemies[p]);
                  }
                }
              }
              for (let k = 0; k < bosses.length; k++) {
                const dx = bosses[k].x - b.x;
                const dy = bosses[k].y - b.y;
                if (Math.hypot(dx, dy) < bombRadius) {
                  bosses[k].hp -= explosionDamage;
                  // --- Если пуля имеет Freeze Blast, то замедляем босса ---
                  if(b.freezeBlast) {
                    bosses[k].freezeSlow = Math.max(bosses[k].freezeSlow, 3000);
                  }
                  for(let blood = 0; blood < 5; blood++){
                    particles.push(new Particle(b.x, b.y, "#800000"));
                  }
                  if (bosses[k].hp <= 0){
                    if (b.reflected && player.activePowerUps.lightSaber.duration > 0) {
                      player.reflectedKillCount += 5;
                      if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks > 6) {
                        player.reflectedKillCount = 0;
                      } else if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks < 6){
                        player.activePowerUps.lightSaber.duration += 20000;
                      };
                    }
                  }
                  b.dead = true;
                }
              }
            } else {
              // по защищённым врагам
              if(enemies[i].type === "shielded" && enemies[i].shield && enemies[i].shieldHP > 0) {
                // Shielded enemy: subtract damage from shield first.
                enemies[i].shieldHP -= b.damage;
              } else {
                  enemies[i].hp -= b.damage;
              }
              let pushStrength = 10; //дальность отбрасывания
              let impactAngle = Math.atan2(enemies[i].y - b.y, enemies[i].x - b.x);
              enemies[i].x += Math.cos(impactAngle) * pushStrength;
              enemies[i].y += Math.sin(impactAngle) * pushStrength;
              // Кровь каждого врага
              for (let blood = 0; blood < 8; blood++) {
                particles.push(new Particle(b.x, b.y, enemies[i].color));
              }
              if(b.freezeBlast) { // пуля с заморозкой
                if(enemies[i].hp > 0) {  // если враг остался жив после нанесённого урона
                  enemies[i].frozenTime = Math.max(enemies[i].frozenTime, 3000);
                  playSfx("freeze");
                }
              }
              // ЭМП
              if(b.empBlast) { enemies[i].empTime = Math.max(enemies[i].empTime, 3000 * player.activePowerUps.empBlast.stacks); }
              // кража жизни
              if(b.lifeSteal) { player.currentHP = Math.min(player.maxHP, player.currentHP + b.damage * player.activePowerUps.lifeSteal.stacks); }
              if(b.piercing) {  // Обработка Пирсинга
                b.piercingCount--;
                if(b.piercingCount <= 0) { b.dead = true; }
              } else { b.dead = true; }
              if(enemies[i].hp <= 0) { // Обработка смерти врага
                if (b.reflected && player.activePowerUps.lightSaber.duration > 0) {
                  player.reflectedKillCount = (player.reflectedKillCount || 0) + 1;
                  if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks > 6) {
                    player.reflectedKillCount = 0; // либо можно сбросить: = 0
                  } else if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks < 6){
                    player.activePowerUps.lightSaber.duration += 20000;
                  };
                }
                if(enemies[i].type === "exploder") {
                  // When an exploder dies, it explodes—damaging nearby enemies.
                  for(let k=0; k<enemies.length; k++){
                    const dx = enemies[k].x - enemies[i].x;
                    const dy = enemies[k].y - enemies[i].y;
                    if(Math.hypot(dx,dy) < 80) {
                      enemies[k].hp -= 5;
                    }
                  }
                  for(let k=0; k<20; k++){
                    particles.push(new Particle(enemies[i].x, enemies[i].y, "#fa0"));
                  }
                }
                if(enemies[i].type === "splitter") {
                  // Splitter splits into two basic enemies when killed.
                  enemies.push(new Enemy(enemies[i].x, enemies[i].y, "basic"));
                  enemies.push(new Enemy(enemies[i].x, enemies[i].y, "basic"));
                }
                spawnCollectible(enemies[i].x, enemies[i].y);
                score += (enemies[i].type==="elite")?200:100;
                enemies[i].dead = true;
                onEnemyKilled(enemies[i]);
                break;
              }
            }
          }
        }
      }
      // Столкновение пуль с боссами (не боссовых пуль)
      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        if (!b.fromBoss) {
          for(let j = bosses.length - 1; j >= 0; j--) {
            if(circleCollision(b, bosses[j])) {
              if(b.bomb){
                const explosionDamage = calculateRadiusAndDamageBomb(b);
                for (let k = 0; k < bosses.length; k++) {
                  const dx = bosses[k].x - b.x;
                  const dy = bosses[k].y - b.y;
                  if (Math.hypot(dx, dy) < bombRadius) {
                    bosses[k].hp -= explosionDamage;
                    // --- Если пуля имеет Freeze Blast, то замедляем босса ---
                    if(b.freezeBlast) {
                      bosses[k].freezeSlow = Math.max(bosses[k].freezeSlow, 3000);
                    }
                    for(let blood = 0; blood < 5; blood++){
                      particles.push(new Particle(b.x, b.y, "#800000"));
                    }
                    if (bosses[k].hp <= 0){
                      if (b.reflected && player.activePowerUps.lightSaber.duration > 0) {
                        player.reflectedKillCount += 5;
                        if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks > 6) {
                          player.reflectedKillCount = 0;
                        } else if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks < 6){
                          player.activePowerUps.lightSaber.duration += 20000;
                        };
                      }
                    }
                    b.dead = true;
                  }
                }
                for (let p = enemies.length - 1; p >= 0; p--) {
                  const dx = enemies[p].x - b.x;
                  const dy = enemies[p].y - b.y;
                  if (Math.hypot(dx, dy) < bombRadius) {
                    if (enemies[p].type === "shielded" && enemies[p].shield && enemies[p].shieldHP > 0) {
                      enemies[p].shieldHP -= b.damage;
                      enemies[p].hp -= explosionDamage;
                    } else {
                      enemies[p].hp -= explosionDamage;
                    }
                    // Отталкивание объекта от центра взрыва
                    const pushStrength = 14;
                    const impactAngle = Math.atan2(dy, dx);
                    enemies[p].x += Math.cos(impactAngle) * pushStrength;
                    enemies[p].y += Math.sin(impactAngle) * pushStrength;
                    for (let blood = 0; blood < 8; blood++) { // Кровь каждого врага
                      particles.push(new Particle(b.x, b.y, enemies[p].color));
                    }
                    if (b.freezeBlast) {
                      if (enemies[p].hp > 0) {
                        enemies[p].frozenTime = Math.max(enemies[p].frozenTime, 3000);
                        playSfx("freeze");
                      }
                    }
                    if (b.empBlast) {
                      enemies[p].empTime = Math.max(enemies[p].empTime, 3000 * player.activePowerUps.empBlast.stacks);
                    }
                    if (b.lifeSteal) {
                      player.currentHP = Math.min(player.maxHP, player.currentHP + explosionDamage * player.activePowerUps.lifeSteal.stacks);
                    }
                    // Пирсинг должен отключаться когда включён bomb
      
                    if (enemies[p].hp <= 0 && !enemies[p].dead) {
                      if (b.reflected && player.activePowerUps.lightSaber.duration > 0) {
                        player.reflectedKillCount = (player.reflectedKillCount || 0) + 1;
                        if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks > 6) {
                          player.reflectedKillCount = 0; // либо можно сбросить: = 0
                        } else if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks < 6){
                          player.activePowerUps.lightSaber.duration += 20000;
                        };
                      }
                      if (enemies[p].type === "exploder") {
                        for (let k = 0; k < enemies.length; k++) {
                          const dx = enemies[k].x - enemies[p].x;
                          const dy = enemies[k].y - enemies[p].y;
                          if (Math.hypot(dx, dy) < 80) {
                            enemies[k].hp -= 5;
                          }
                        }
                        for (let k = 0; k < 20; k++) {
                          particles.push(new Particle(enemies[p].x, enemies[p].y, "#fa0"));
                        }
                      }
                      if (enemies[p].type === "splitter") {
                        enemies.push(new Enemy(enemies[p].x, enemies[p].y, "basic"));
                        enemies.push(new Enemy(enemies[p].x, enemies[p].y, "basic"));
                      }
                      spawnCollectible(enemies[p].x, enemies[p].y);
                      score += (enemies[p].type === "elite") ? 200 : 100;
                      enemies[p].dead = true;
                      onEnemyKilled(enemies[p]);
                    }
                  }
                }
              }
              else{
                bosses[j].hp -= b.damage;
                // --- Если пуля имеет Freeze Blast, то замедляем босса ---
                if(b.freezeBlast) {
                  bosses[j].freezeSlow = Math.max(bosses[j].freezeSlow, 3000);
                }
                for(let blood = 0; blood < 5; blood++){
                  particles.push(new Particle(b.x, b.y, "#800000"));
                }
                if (bosses[j].hp <= 0){
                  if (b.reflected && player.activePowerUps.lightSaber.duration > 0) {
                    player.reflectedKillCount += 5;
                    if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks > 6) {
                      player.reflectedKillCount = 0;
                    } else if (player.reflectedKillCount >= 15 && player.activePowerUps.lightSaber.stacks < 6){
                      player.activePowerUps.lightSaber.duration += 20000;
                    };
                  }
                }
                b.dead = true;
                break;
              }
            }
          }
        }
      }

      // Столкновение пуль боссов с игроком
      for(let i = bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        if((b.fromBoss || b.fromEnemy) && circleCollision(b, player)) {
          if (player.activePowerUps.shield.duration > 0) {
            // Если щит активен, пуля просто уничтожается (можно добавить визуальный эффект)
            b.dead = true;
            // Дополнительно: создаём несколько частиц для эффекта удара по щиту
            for (let k = 0; k < 3; k++) {
              particles.push(new Particle(b.x, b.y, "rgba(0,200,255,0.5)"));
            }
          } else {
            player.currentHP -= b.damage;
            // Отображение нанесённого урона
            damageTexts.push({ x: player.x, y: player.y, damage: b.damage, alpha: 1, lifetime: 1000 });
            for (let k = 0; k < 5; k++) {
              particles.push(new Particle(b.x, b.y, "#f00"));
            }
            b.dead = true;
            if (player.currentHP <= 0) { gameState = "gameover"; showGameOver(); }
          }
        }
      }
      // Столкновение пуль игрока с пулями врагов
      for (let i = 0; i < bullets.length; i++) {
        let playerBullet = bullets[i];
        if(playerBullet.fromEnemy || playerBullet.fromBoss) continue; // рассматриваем только пули игрока
        for (let j = 0; j < bullets.length; j++) {
          let enemyBullet = bullets[j];
          if(!(enemyBullet.fromEnemy || enemyBullet.fromBoss)) continue; // рассматриваем только пули врагов
          if(circleCollision(playerBullet, enemyBullet)) {
            playerBullet.dead = true;
            enemyBullet.dead = true;
          }
        }
      }


      if(powerMeter >= getPowerMeterMax() && gameState==="playing") {
        playSfx("powerup");
        showPowerUpMenu();
      }
      // Обновление эффектов мини‑волны
      for (let i = miniWaves.length - 1; i >= 0; i--) {
        miniWaves[i].elapsed += deltaTime;
        const totalDuration = miniWaves[i].phase1Duration + miniWaves[i].phase2Duration;
        if (miniWaves[i].elapsed >= totalDuration) {
          miniWaves.splice(i, 1);
        }
      } 
      // --- Обновление массива damageTexts (плавающие красные числа урона) ---
      for (let i = damageTexts.length - 1; i >= 0; i--) {
        let dt = damageTexts[i];
        dt.lifetime -= deltaTime;
        dt.y -= 0.05 * deltaTime; // поднимаемся вверх
        dt.alpha = dt.lifetime / 1000;
        if (dt.lifetime <= 0) {
          damageTexts.splice(i, 1);
        }
      }
      // *** Обновление объектов Friend на основе эффекта "Friend" ***
      if (player && player.activePowerUps && player.activePowerUps.friend) {
        let friendStacks = player.activePowerUps.friend.stacks;
        // Если стэков 1 – создаём 1 друга, если стэков 2 или больше – 2 друга
        let desiredFriendCount = 0;
        if (friendStacks >= 2) {
          desiredFriendCount = 2;
        } else if (friendStacks === 1) {
          desiredFriendCount = 1;
        }
        while (friends.length < desiredFriendCount) {
          if (desiredFriendCount === 1) {
            friends.push(new Friend(Math.PI / 2));
          } else if (desiredFriendCount === 2) {
            if (friends.length === 0) friends.push(new Friend(Math.PI / 2));
            else if (friends.length === 1) friends.push(new Friend(-Math.PI / 2));
          }
        }
        while (friends.length > desiredFriendCount) {
          friends.pop();
        }
        friends.forEach(friend => friend.update(deltaTime));
      }
      // Обновление эффекта волны "Psi Blast", если он активен
      if (psiBlastWave) {
        psiBlastWave.elapsed += deltaTime;
        // Линейное увеличение радиуса: от 0 до максимума за заданное время duration
        psiBlastWave.radius = psiBlastWave.maxRadius * (psiBlastWave.elapsed / psiBlastWave.duration);
        // Если эффект закончился, сбрасываем его
        if (psiBlastWave.elapsed >= psiBlastWave.duration) {
          psiBlastWave = null;
        }
      }
      // === combo timer
      updateCombo(deltaTime);
      collectibles = collectibles.filter(collectible => !collectible.dead)
      enemies = enemies.filter(enemy => !enemy.dead);
      bullets = bullets.filter(bullet => !bullet.dead);
    }

    // progress bar
    function drawLevelProgressBar() {
      ctx.save();
      if (isMobile) {
        ctx.globalAlpha = 0.7;
        if (window.innerWidth > window.innerHeight) {
          // Mobile Landscape → horizontal progress bar at the bottom
          const barWidth = 300 * uiScale;
          const barHeight = 25 * uiScale;
          const x = (width - barWidth) / 2;
          const y = height - barHeight - (20 * uiScale);
          
          // Draw background
          ctx.fillStyle = "#333";
          //ctx.fillRect(x, y, barWidth, barHeight);
          drawRoundedRect(ctx, x, y, barWidth, barHeight, 8 * uiScale);
          
          if (bosses.length === 0) {
            let progress = (levelDuration - levelTimer) / levelDuration;
            progress = Math.max(0, Math.min(1, progress));
            const grad = ctx.createLinearGradient(x, y, x + barWidth, y);
            grad.addColorStop(0, "#0f0");
            grad.addColorStop(1, "#ff0");
            ctx.fillStyle = grad;
            //ctx.fillRect(x, y, barWidth * progress, barHeight);
            drawRoundedRect(ctx, x, y, barWidth * progress, barHeight, 8 * uiScale);
            
            ctx.fillStyle = "#f00";
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.fillText("Boss fight in " + Math.ceil(levelTimer / 1000) + "s!!", 
                         x + barWidth / 2, 
                         y + barHeight - (5 * uiScale));
          } else {
            ctx.fillStyle = "#f00";
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.fillText("FIGHT!", x + barWidth / 2, y + barHeight - (5 * uiScale));
          }
          
          //ctx.strokeStyle = "#fff";
          //ctx.lineWidth = 2;
          //ctx.strokeRect(x, y, barWidth, barHeight);
        } else {
          // Mobile Portrait → vertical progress bar on the right
          const barWidth = 25 * uiScale;
          const barHeight = 300 * uiScale;
          const x = width - barWidth - (20 * uiScale);
          const y = (height - barHeight) / 2;
          
          // Draw background
          ctx.fillStyle = "#333";
          //ctx.fillRect(x, y, barWidth, barHeight);
          drawRoundedRect(ctx, x, y, barWidth, barHeight, 8 * uiScale);

          if (bosses.length === 0) {
            let progress = (levelDuration - levelTimer) / levelDuration;
            progress = Math.max(0, Math.min(1, progress));
            const grad = ctx.createLinearGradient(x, y + barHeight, x, y);
            grad.addColorStop(0, "#0f0");
            grad.addColorStop(1, "#ff0");
            ctx.fillStyle = grad;
            drawRoundedRect(ctx, x, y + barHeight - (barHeight * progress), barWidth, barHeight * progress, 8 * uiScale);
            //ctx.fillRect(x, y + barHeight - (barHeight * progress), barWidth, barHeight * progress);
            
            ctx.fillStyle = "#f00";
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.translate(x + barWidth / 2, y + barHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText("Boss fight in " + Math.ceil(levelTimer / 1000) + "s!!", 0, 0);
          } else {
            ctx.save();
            ctx.fillStyle = "#f00";
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.translate(x + barWidth / 2, y + barHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText("FIGHT!", 0, 0);
          }          
        }
      } else {
        // --- Horizontal Progress Bar for Desktop ---
        const barWidth = 300 * uiScale;
        const barHeight = 25 * uiScale;
        const x = (width - barWidth) / 2;
        const y = height - barHeight - (20 * uiScale);
        
        // Draw background
        ctx.fillStyle = "#333";
        //ctx.fillRect(x, y, barWidth, barHeight);
        drawRoundedRect(ctx, x, y, barWidth, barHeight, 8 * uiScale);
        
        if (bosses.length === 0) {
          let progress = (levelDuration - levelTimer) / levelDuration;
          progress = Math.max(0, Math.min(1, progress));
          const grad = ctx.createLinearGradient(x, y, x + barWidth, y);
          grad.addColorStop(0, "#0f0");
          grad.addColorStop(1, "#ff0");
          ctx.fillStyle = grad;
          //ctx.fillRect(x, y, barWidth * progress, barHeight);
          drawRoundedRect(ctx, x, y, barWidth * progress, barHeight, 8 * uiScale);
          
          ctx.fillStyle = "#f00";
          ctx.font = (18 * uiScale) + "px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Boss fight in " + Math.ceil(levelTimer / 1000) + "s!!", x + barWidth / 2, y + barHeight - (5 * uiScale));
        } else {
          ctx.fillStyle = "#f00";
          ctx.font = (18 * uiScale) + "px Arial";
          ctx.textAlign = "center";
          ctx.fillText("FIGHT!", x + barWidth / 2, y + barHeight - (5 * uiScale));
        }
      }
      
      ctx.restore();
    }
    // Функция, которая по ключу из activePowerUps ищет читаемое название в powerUpMap
    function getPowerUpDisplayName(key) {
      for (let displayName in powerUpMap) {
        if (powerUpMap[displayName] === key) {
          return displayName;
        }
      }
      return key; // если не найдено, возвращаем исходное значение
    }

    // =================== Main Draw Function ===================
    function draw() {
      // Полная очистка канвы
      ctx.clearRect(0, 0, width, height);
      // Вычисляем, сколько пикселей нужно обрезать снизу
      const cropHeight = (isMobile && window.innerHeight > window.innerWidth) ? getBottomCropHeight() : 0;
      const now = performance.now();
      updateBiomeCache(now);


      ctx.save();
      // Задаём область отрисовки – от (0,0) до (width, height - cropHeight)
      ctx.beginPath();
      ctx.rect(0, 0, width, height - cropHeight);
      ctx.clip();

      // ===== Модифицированная отрисовка фона (биома) =====
      ctx.drawImage(cachedBiomeStaticCanvas, 0, 0);
      //getCurrentBiome().drawBackground(ctx);
      // ====================================================

      collectibles.forEach(c => c.draw());
      // *** NEW: Отрисовка объектов Friend ***
      friends.forEach(friend => friend.draw());
      if(player) player.draw();
      bullets.forEach(b => b.draw());
      enemies.forEach(e => e.draw());
      // Отрисовка босса (или боссов)
      bosses.forEach(b => b.draw());
      particles.forEach(p => p.draw());
      acidTrails.forEach(trail => trail.draw());

      if (isMobile && window.innerHeight > window.innerWidth) {
        const effectiveHeight = height - getBottomCropHeight();
        //ctx.save();
        ctx.beginPath();
        ctx.moveTo(0, effectiveHeight);
        ctx.lineTo(width, effectiveHeight);
        // Настройка толщины линии (можно скорректировать под ваш uiScale)
        ctx.lineWidth = 8 * uiScale;
        // Устанавливаем бирюзовый цвет и неоновое свечение
        ctx.strokeStyle = "rgba(0,255,255,0.8)";
        ctx.shadowColor = "rgba(0,255,255,1)";
        ctx.shadowBlur = 20 * uiScale;
        ctx.stroke();
        //ctx.restore();
      }
      ctx.restore();
      // HUD 
      ctx.save();              // сохраняем текущее состояние контекста
      if (isMobile) ctx.globalAlpha = 0.7;

      ctx.fillStyle = "#fff";
      ctx.font = (20 * uiScale) + "px Arial";
      ctx.fillText("Score: " + Math.floor(score), 10, 30 * uiScale);
      ctx.fillText("Level: " + currentLevel, 10, 55 * uiScale);
      // Power Meter Bar
      ctx.fillStyle = "#222";
      let xForBars = 10 * uiScale;
      let heightForBars = 15 * uiScale;
      let roundedParam = 8 * uiScale;
      //ctx.fillRect(xForBars,65 * uiScale, 120 * uiScale,heightForBars);
      drawRoundedRect(ctx, xForBars, 65 * uiScale, 120 * uiScale, heightForBars, roundedParam);
      ctx.fillStyle = "#ff0";
      //ctx.fillRect(xForBars,65 * uiScale, (120*(powerMeter/getPowerMeterMax())) * uiScale,heightForBars);
      let barWidth = (120 * (powerMeter / getPowerMeterMax())) * uiScale;
      drawRoundedRect(ctx, xForBars, 65 * uiScale, barWidth, heightForBars, roundedParam);
      //ctx.strokeStyle = "#fff";
      //ctx.strokeRect(10 * uiScale,65 * uiScale,120 * uiScale,heightForBars);
      // Health Bar
      if(player) {
        const grad = ctx.createLinearGradient(xForBars,80 * uiScale,130 * uiScale,80 * uiScale);
        grad.addColorStop(0, "#f00");
        grad.addColorStop(1, "#f00");
        ctx.fillStyle = "#222";
        //ctx.fillRect(xForBars,80 * uiScale,120 * uiScale,heightForBars);
        drawRoundedRect(ctx, xForBars, 80 * uiScale, 120 * uiScale, heightForBars, roundedParam);
        ctx.fillStyle = grad;
        //ctx.fillRect(xForBars,80 * uiScale,(120*(player.currentHP/player.maxHP)) * uiScale,heightForBars);
        drawRoundedRect(ctx, xForBars, 80 * uiScale, (120*(player.currentHP/player.maxHP)) * uiScale, heightForBars, roundedParam);
        //ctx.strokeStyle = "#fff";
        //ctx.strokeRect(10 * uiScale,80 * uiScale,120 * uiScale,heightForBars);
      }
      
      // Отрисовка перманентных бонусов в правом верхнем углу
      ctx.textAlign = "right";  // Выравнивание текста по правому краю
      ctx.fillStyle = "#fff";
      ctx.font = (20 * uiScale) + "px Arial";
      ctx.fillText("Damage: " + permanentUpgrades.damage, (width - 10), 30 * uiScale);
      ctx.fillText("Speed: " + permanentUpgrades.speed, (width - 10), 55 * uiScale);
      ctx.fillText("Fire Rate: " + permanentUpgrades.fireRate, (width - 10), 80 * uiScale);
      ctx.fillText("Health: " + (100 + permanentUpgrades.health), (width - 10), 105 * uiScale);  // *** NEW: отображение здоровья
      ctx.fillText("Reduction: " + (permanentUpgrades.damageReduction), (width - 10), 130 * uiScale);
      ctx.textAlign = "left";  // Сброс выравнивания для дальнейшей отрисовки
      // =================== Отрисовка активных усилений и негативных эффектов (HUD) ===================
      if (player) {
        let yOffset = 120;
        // Сначала выводим активные (положительные) усиления белым цветом
        if (player.activePowerUps) {
          for (let key in player.activePowerUps) {
            if (player.activePowerUps[key].duration > 0) {
              const displayName = getPowerUpDisplayName(key);
              ctx.fillStyle = "#fff";
              ctx.fillText(displayName + " (" + Math.ceil(player.activePowerUps[key].duration / 1000) + "s, stacks: " + player.activePowerUps[key].stacks + ")", 10 * uiScale, yOffset * uiScale);
              yOffset += 25;
            }
          }
        }
        // Затем выводим негативные эффекты красным цветом
        if (player.frozenTime > 0) {
           ctx.fillStyle = "#f00";
           ctx.fillText("Frozen (" + Math.ceil(player.frozenTime / 1000) + "s)", 10 * uiScale, yOffset * uiScale);
           yOffset += 25;
        }
        if (player.shootingDisabled > 0) {
           ctx.fillStyle = "#f00";
           ctx.fillText("Shooting Disabled (" + Math.ceil(player.shootingDisabled / 1000) + "s)", 10 * uiScale, yOffset * uiScale);
           yOffset += 25;
        }
        if (player.empSlowed > 0) {
           ctx.fillStyle = "#f00";
           ctx.fillText("EMP Slowed (" + Math.ceil(player.empSlowed / 1000) + "s)", 10 * uiScale, yOffset * uiScale);
           yOffset += 25;
        }
      }
      ctx.restore(); 

      // === Отрисовка комбо-счетчика
      ctx.save();
      if (isMobile) ctx.globalAlpha = 0.7;
      
      ctx.textBaseline = "middle"; // выравниваем по вертикальному центру
      let comboColor = "#fff";
      if (comboCounter >= 30) comboColor = "#0ff";
      if (comboCounter >= 70) comboColor = "#ff0";
      if (comboCounter >= 100) comboColor = "#f00";
      if (comboCounter >= 150) comboColor = "rgba(138,43,226,1)";
      ctx.shadowColor = comboColor;    // подсветка
      ctx.shadowBlur = 10 * uiScale;     // радиус свечения
      if (comboCounter >= 200) {
        comboColor = "#000";
        ctx.shadowColor= "#fff"
        ctx.shadowBlur = 15 * uiScale;
      }
      ctx.fillStyle = comboColor;
      ctx.font = (20 * uiScale) + "px Arial";
      let comboX = (10 + 120 + 10) * uiScale;
      let comboY = 80 * uiScale + (15 * uiScale) / 2;
      ctx.fillText("Kills: " + comboCounter, comboX, comboY);
      ctx.restore();



      // Отрисовка плавающих красных чисел урона
      damageTexts.forEach(dt => {
        ctx.save();
        ctx.globalAlpha = dt.alpha;
        ctx.fillStyle = "#f00";
        ctx.font = (24 * uiScale) + "px Arial";
        // Если dt.damage является числом – добавляем минус, иначе выводим как есть
        const text = (typeof dt.damage === "number") ? "-" + dt.damage : dt.damage;
        ctx.fillText(text, dt.x, dt.y);
        ctx.restore();
      });
      // Отрисовка эффектов мини‑волны
      miniWaves.forEach(wave => {
        let currentRadius, alpha;
        // Если у волны уже записан конечный радиус, используем его,
        // иначе – берем глобальное bombRadius (это может быть актуально для первого взрыва)
        const finalRadius = (wave.finalRadius !== undefined) ? wave.finalRadius : bombRadius;

        // то есть коэффициент = 80/110 ≈ 0.73.
        const phase1Final = finalRadius * (80 / 110);
      
        if (wave.elapsed < wave.phase1Duration) {
          // Фаза 1: растём от 0 до phase1Final, альфа = 1
          currentRadius = (wave.elapsed / wave.phase1Duration) * phase1Final;
          alpha = 1;
        } else {
          // Фаза 2: растём от phase1Final до finalRadius,
          // а альфа линейно падает от 1 до 0
          let progress2 = (wave.elapsed - wave.phase1Duration) / wave.phase2Duration;
          currentRadius = phase1Final + progress2 * (finalRadius - phase1Final);
          alpha = 1 - progress2;
        }
        
        const waveThickness = 5 * scaleFactor;
        
        ctx.save();
        ctx.beginPath();
        ctx.arc(wave.x, wave.y, currentRadius, 0, Math.PI * 2);
        ctx.strokeStyle = hexToRgba(wave.color, alpha);
        ctx.lineWidth = waveThickness;
        ctx.stroke();
        ctx.restore();
      });

      if (lightSaberWave) {
        ctx.save();
        let alpha = 1 - (lightSaberWave.elapsed / lightSaberWave.duration);
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = "rgba(255,255,255,0.3)"; // можно подобрать другой цвет
        ctx.lineWidth = 8 * uiScale;
        ctx.beginPath();
        ctx.arc(lightSaberWave.x, lightSaberWave.y, lightSaberWave.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
      if (
        player &&
        player.activePowerUps.lightSaber &&
        player.activePowerUps.lightSaber.duration > 0 &&
        !(player.activePowerUps.neonOverdrive && player.activePowerUps.neonOverdrive.duration > 0)
      ) {
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.angle);

        let lsStacks = player.activePowerUps.lightSaber.stacks;
        let angles = [];

        if (lsStacks === 1) {
          angles = [0]; // только вперёд
        } else if (lsStacks === 2) {
          angles = [0, Math.PI]; // вперёд и назад
        } else if (lsStacks === 3) {
          // один меч вперёд, два сзади по диагонали (135° и 225°)
          angles = [0, (3 * Math.PI) / 4, (5 * Math.PI) / 4];
        } else if (lsStacks === 4) {
          // мечи с четырёх сторон
          angles = [0, Math.PI / 2, Math.PI, (3 * Math.PI) / 2];
        } else if (lsStacks >= 5) {
          // используем ту же схему, что и для 4 стека
          angles = [0, Math.PI / 2, Math.PI, (3 * Math.PI) / 2];
        }

        let handleLength = 30 * scaleFactor;  // рукоять длиной 10
        let bladeLength = 170 * scaleFactor;    // лезвие длиной 240
        let bladeWidth = 5 * scaleFactor;         // толщина лезвия 

        angles.forEach(offset => {
          ctx.save();
          ctx.rotate(offset);
          // Рисуем рукоять меча
          ctx.fillStyle = "gray";
          ctx.fillRect(20 * scaleFactor, -3.5 * scaleFactor, handleLength, 7 * scaleFactor);
          // Рисуем лезвие – используем случайный цвет из эффекта
          let lightsaberColor = player.activePowerUps.lightSaber.color || "red";
          ctx.fillStyle = lightsaberColor;
          ctx.shadowColor = lightsaberColor;
          ctx.shadowBlur = 70 * scaleFactor;
          ctx.fillRect(handleLength + 20 * scaleFactor, -bladeWidth / 2, bladeLength, bladeWidth);
          ctx.restore();
        });

        ctx.restore();
      }
      if (player && player.activePowerUps.neonOverdrive && player.activePowerUps.neonOverdrive.duration > 0) {
        let beamStartX = player.x + Math.cos(player.angle) * (player.radius * scaleFactor);
        let beamStartY = player.y + Math.sin(player.angle) * (player.radius * scaleFactor);
        let beamLength = Math.sqrt(width * width + height * height);
        let beamEndX = beamStartX + Math.cos(player.angle) * beamLength;
        let beamEndY = beamStartY + Math.sin(player.angle) * beamLength;
        
        ctx.save();
        // Настройка стиля для неонового эффекта
        ctx.lineWidth = 8 * scaleFactor;
        ctx.strokeStyle = "rgba(0,255,255,0.7)";  // неоновый цвет (циановый)
        ctx.shadowColor = "rgba(0,255,255,0.9)";
        ctx.shadowBlur = 20 * scaleFactor;;
        ctx.beginPath();
        ctx.moveTo(beamStartX, beamStartY);
        ctx.lineTo(beamEndX, beamEndY);
        ctx.stroke();
        ctx.restore();
        // --- Дополнительные фиолетовые неоновые линии ---
        // Параметр осцилляции (пульсация) рассчитывается на основе времени
        let oscillation = Math.sin(performance.now() / 100) * (3 * scaleFactor); //       изменяется от -3*scaleFactor до +3*scaleFactor
        let offsetBase = 10 * scaleFactor; // базовый отступ от основного луча
        let offset = offsetBase + oscillation; // суммарный отступ

        // Вычисляем перпендикуляр к направлению луча
        let perpX = -Math.sin(player.angle);
        let perpY = Math.cos(player.angle);

        ctx.save();
        ctx.lineWidth = 4 * scaleFactor; // более тонкие линии
        ctx.strokeStyle = "rgba(138,43,226,0.8)"; // фиолетовый (цвет BlueViolet)
        ctx.shadowColor = "rgba(138,43,226,1)";
        ctx.shadowBlur = 15 * scaleFactor;

        // Левая линия (смещена в сторону -perp)
        ctx.beginPath();
        ctx.moveTo(beamStartX - perpX * offset, beamStartY - perpY * offset);
        ctx.lineTo(beamEndX - perpX * offset, beamEndY - perpY * offset);
        ctx.stroke();

        // Правая линия (смещена в сторону +perp)
        ctx.beginPath();
        ctx.moveTo(beamStartX + perpX * offset, beamStartY + perpY * offset);
        ctx.lineTo(beamEndX + perpX * offset, beamEndY + perpY * offset);
        ctx.stroke();
        ctx.restore();
      }
      if (psiBlastWave) {
        ctx.save();
        // Плавное исчезновение: альфа уменьшается от 1 до 0
        let alpha = 1 - (psiBlastWave.elapsed / psiBlastWave.duration);
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = "rgba(0,255,255,1)"; // цвет волны (например, циановый)
        ctx.lineWidth = 8 * uiScale;
        ctx.beginPath();
        ctx.arc(psiBlastWave.x, psiBlastWave.y, psiBlastWave.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
      drawLevelProgressBar();
      if (!isMobile) drawMouseIndicator();
      else drawMobileCursor();
    }

    // =================== Game Start ===================
    function startGame() {
      if (currentMusicTrack === "phonk") {
        phonkIndex = Math.floor(Math.random() * phonkTracks.length);
      } else if (currentMusicTrack === "calm") {
        calmIndex = Math.floor(Math.random() * calmTracks.length);
      } else if (currentMusicTrack === "custom" && customTracks.length > 0) {
        customIndex = Math.floor(Math.random() * customTracks.length);
      }
      gameState = "playing";
      score = 0;
      currentLevel = 1;
      levelDuration = 30000;
      levelTimer = levelDuration;
      permanentUpgrades.damage = 1;
      permanentUpgrades.speed = 1;
      permanentUpgrades.fireRate = 1;
      permanentUpgrades.health = 0;
      permanentUpgrades.damageReduction = 0;
      comboCounter = 0;
      enemySpawnTimer = 0;
      fireCooldown = 0;
      powerMeter = 0;
      bosses.length = 0;
      enemies.length = 0;
      bullets.length = 0;
      miniWaves.length = 0;
      collectibles.length = 0;
      particles.length = 0;
      damageTexts = []; // сброс отображаемых чисел урона
      // *** NEW: Очистка объектов Friend при старте игры ***
      friends.length = 0;
      player = new Player(width/2, height/2);
      player.maxHP = 100 + permanentUpgrades.health;  // *** NEW: учитываем перманентное здоровье
      player.currentHP = player.maxHP;
      
      // Start music if enabled
      if (soundEnabled) {
        playCurrentMusic();
      }
      document.getElementById("overlay").classList.add("hidden");
    }
    
    mainMenu();
    requestAnimationFrame(gameLoop);
    window.playCurrentMusic = playCurrentMusic;
    window.nextTrack = nextTrack;
    window.getActiveMusic = getActiveMusic;
  })();
  </script>
</body>
</html>
