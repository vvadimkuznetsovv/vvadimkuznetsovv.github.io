<!DOCTYPE html>
<!--
    Лицензия на данный код:

    Авторский код разработан и предоставлен:
      - Кузнецов Вадим Алексеевич (ООО НейроБизнес Солюшнс)
      - Басма Нассиф Хуссейн (ООО Интеллектуальные Технологии Будущего Образования)

    Использование, распространение и модификация данного кода допускаются только при соблюдении
    условий лицензионного соглашения. При использовании данного кода, пожалуйста, сохраняйте
    данный блок с указанием авторства.
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Neon Nexus: Ultimate Gauntlet – Levels Edition (Expanded)</title>
  <style>
    :root {
      --ui-scale: 1;
    }
    /* Reset and full‑screen canvas */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
    /* Overlay for menus, transitions, power‑up selection, pause, game over, etc. */
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.85);
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      text-align: center;
      user-select: none;
      font-size: calc(16px * var(--ui-scale));
    }
    #overlay.hidden {
      display: none;
    }
    .button {
      margin: calc(10px * var(--ui-scale));
      padding: calc(10px * var(--ui-scale)) calc(20px * var(--ui-scale));
      background: #222;
      border: calc(2px * var(--ui-scale)) solid #0ff;
      color: #0ff;
      font-size: calc(18px * var(--ui-scale));
      box-shadow: 0px 0px 10px 2px #0ff;
      border-radius: 10px;
      cursor: pointer;
    }
    .cyan_color {
      color: #0ff;
      text-shadow: 0px 0px 10px #0ff;
    }
    .button:hover {
      background: #0ff;
      color: #000;
    }
    /* Mobile Joysticks & Pause Button */
    #leftJoystick, #rightJoystick {
      position: absolute;
      bottom: 20px;
      width: calc(200px * var(--ui-scale));;
      height: calc(200px * var(--ui-scale));
      background: rgba(255,255,255,0.1);
      border-radius: 50%;
      z-index: 50;
      touch-action: none;
      display: none;
    }
    #leftJoystick { left: 20px; }
    #rightJoystick { right: 20px; }
    .joystick-thumb {
      position: absolute;
      width: calc(80px * var(--ui-scale));
      height: calc(80px * var(--ui-scale));
      background: rgba(0,255,255,0.4);
      border-radius: 50%;
      top: calc(60px * var(--ui-scale));
      left: calc(60px * var(--ui-scale));
      transition: transform 0.1s ease;
    }
    #mobilePauseButton {
      position: absolute;
      top: calc(110px * var(--ui-scale));
      right: calc(20px * var(--ui-scale));
      z-index: 50;
      margin: calc(10px * var(--ui-scale));
      padding: calc(10px * var(--ui-scale)) calc(20px * var(--ui-scale));
      background: rgba(0,0,0,0.5);
      border: calc(2px * var(--ui-scale)) solid #0ff;
      color: #0ff;
      box-shadow: 0px 0px 10px 2px #0ff;
      border-radius: 10px;
      font-size: calc(20px * var(--ui-scale));
      display: none;
    }
    
    @media only screen and (max-width: 768px) {
      /* Increase overlay font sizes */
      #overlay h1 {
        font-size: calc(42px * var(--ui-scale));
      }
      #overlay p {
        font-size: calc(24px * var(--ui-scale));
      }
      .button {
        font-size: calc(24px * var(--ui-scale));
        padding: calc(15px * var(--ui-scale)) calc(30px * var(--ui-scale));
      }
    }
    
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <!-- Overlay for menus, transitions, power‑up selection, pause, game over -->
  <div id="overlay">
    <h1>Neon Nexus: Ultimate Gauntlet</h1>
    <p id="overlayText">
      Move with WASD, aim with your mouse and auto‑fire.<br>
      Collect glowing orbs to fill your power meter.<br>
      When full, choose one of three temporary power‑ups to help you survive.
    </p>
    <p id="startHint">Press <strong>SPACE</strong> to begin</p>
    <div id="overlayButtons"></div>
  </div>

  <!-- Mobile controls -->
  <div id="leftJoystick">
    <div class="joystick-thumb"></div>
  </div>
  <div id="rightJoystick">
    <div class="joystick-thumb"></div>
  </div>
  <button id="mobilePauseButton">Pause</button>

  <script>
  (function(){
    // =================== Canvas & Initialization ===================
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    
      
      // Обработчик нажатия клавиш
      document.addEventListener("keydown", function(e) {
        // ************************************
        // **  BUTTONS for Cheats  **
        // ************************************
        /*
        if(e.key.toLowerCase() === "p") {
          spawnTwoBosses();
        }
        if(e.key.toLowerCase() === "n") {
          nextLevel();
        }
        if(e.key.toLowerCase() === "m") {
          showPowerUpMenu();
        }
        if(e.key.toLowerCase() === "k") {
          givePlayerMagnetEffect();
        }*/
        // Если нажата клавиша "c" (без учета регистра)
        if (e.key.toLowerCase() === "x") {
          // Переключаем состояние видимости курсора
          cursorVisible = !cursorVisible;
          canvas.style.cursor = cursorVisible ? "default" : "none";
          console.log("Cursor visible:", cursorVisible);
        }
      });

    let cursorVisible = true; // изначально курсор видим
    // ======== Обрезка для портретного режима
    function getBottomCropHeight() {
      // Получаем высоту джойстика (например, левый джойстик)
      const joystick = document.getElementById("leftJoystick");
      // Если по какой-то причине элемент ещё не измерен, задаём значение по умолчанию
      const joystickHeight = joystick ? joystick.offsetHeight : 200;
      const margin = 30; // отступ сверху джойстика (как в CSS: bottom: 20px)
      return joystickHeight + margin;
    }

    // We will store width/height in these, but NOT assign them to canvas yet.
    let width, height;
    let dpr = window.devicePixelRatio || 1;
    const isMobile = ("ontouchstart" in window) || (navigator.maxTouchPoints > 0);
    let cssGridSize = (isMobile) ? (50 * (1 / dpr)) : 50;
    let cssGridSize2 = (isMobile) ? (60 * (1 / dpr)) : 60;
    let cssGridSize40 = (isMobile) ? (40 * (1 / dpr)) : 40;
    let actualGridSize = cssGridSize;
    let actualGridSize2 = cssGridSize2;
    let actualGridSize40 = cssGridSize40; 




    // Задаём интервалы обновления (в мс)
    const BIOME_STATIC_UPDATE_INTERVAL = 50; // статическая часть обновляется каждые    5 секунд

    let lastBiomeStaticUpdate = 0;

    // Создаем два offscreen canvas для статического фона и для моргающего оверлея
    const cachedBiomeStaticCanvas = document.createElement('canvas');
    const cachedBiomeStaticCtx = cachedBiomeStaticCanvas.getContext('2d');

    // Не забудьте при ресайзе обновлять размеры этих canvas:
    // Например, внутри вашей функции onResize:
    function updateCachedCanvasSizes() {
      cachedBiomeStaticCanvas.width = width;
      cachedBiomeStaticCanvas.height = height;
    }
    window.addEventListener("resize", () => {
      onResize();
      updateCachedCanvasSizes();
      // Можно также сбросить время обновления, чтобы фон сразу перерисовался
      lastBiomeStaticUpdate = 0;
    });

    // Функция обновления кэша биома; вызываем ее в каждом кадре, перед отрисовкой
    function updateBiomeCache(timestamp) {
      // Обновляем статический фон, если прошло больше BIOME_STATIC_UPDATE_INTERVAL
      if (timestamp - lastBiomeStaticUpdate > BIOME_STATIC_UPDATE_INTERVAL) {
        // Очищаем кэш и отрисовываем текущий биом (используйте вашу функцию, например,     getCurrentBiome().drawBackground)
        cachedBiomeStaticCtx.clearRect(0, 0, width, height);

        cachedBiomeStaticCtx.fillStyle = "red"; // замените на яркий цвет
        cachedBiomeStaticCtx.fillRect(0, 0, width, height);
        const currentBiome = getCurrentBiome();
        currentBiome.drawBackground(cachedBiomeStaticCtx);
        lastBiomeStaticUpdate = timestamp;
      }
    }


    // Глобальная переменная для таймера спавна специальных collectible
    let specialCollectibleSpawnTimer = 0;
    function spawnSpecialCollectibleRandom() {
      // Проверяем условия: уровень >= 5 и наличие босса
      if (currentLevel < 4 || bosses.length === 0) return;
      
      const maxStage = ((currentLevel - 1) % 5) + 1;
      // Например, шанс спавна можно задать как: maxStage * 0.1 (от 0.1 до 0.5)
      const specialProbability = maxStage * 0.1;
      
      if (Math.random() < specialProbability) {
        // Выбираем случайные координаты внутри экрана
        const x = Math.random() * width;
        const y = Math.random() * height;
        // Добавляем специальный collectible в массив collectibles
        collectibles.push(new SpecialCollectible(x, y));
      }
    }
    
    //========== Combo переменные и func для комбо-системы

    let comboCounter = 0;
    let comboTimer = 0;
    const COMBO_RESET_TIME = 6666; // 7 секунд
    // Функция увеличения комбо при убийстве врага
    function increaseCombo() {
      comboCounter++;
      comboTimer = COMBO_RESET_TIME;
      // Пример: активация бонусов
      if (comboCounter === 5) {
        applyPowerUp("Damage Boost");
      } else if (comboCounter === 30) {
        applyPowerUp("Bullet Time");
      } else if (comboCounter === 70) {
        applyPowerUp("Power Meter Boost");
      } else if (comboCounter === 100) {
        applyPowerUp("Friend");
      }else if (comboCounter === 150) {
        applyPowerUp("Restore Health");
      }else if (comboCounter === 200) {
        applyPowerUp("Neon Overdrive");
        applyPowerUp("Shield");
      }else if (comboCounter === 400) {
        showPermanentUpgradeMenu();
        resetCombo();
      }
    }
    // Функция сброса комбо (например, при получении урона)
    function resetCombo() {
      comboCounter = 0;
      comboTimer = 0;
    }
    // Функция, вызываемая в update(deltaTime)
    function updateCombo(deltaTime) {
      if (comboTimer > 0) {
        comboTimer -= deltaTime;
        if (comboTimer <= 0) {
          comboCounter = 0;
        }
      }
    }
    // В функции, где обрабатывается убийство врага:
    function onEnemyKilled(enemy) {
      // Добавляем эффекты уничтожения, начисление очков и т.д.
      increaseCombo();
      // Другие действия: spawnCollectible, particles, score += и т.п.
    }

    //================== конец Combo functions

    function onResize() {
      // 1) Use CSS pixel dimensions for your game logic:
      width = window.innerWidth;
      height = window.innerHeight;
      
      // 2) Device pixel ratio (high‑DPI “retina” scaling factor)
      dpr = window.devicePixelRatio || 1;

      // 3) Visually, the canvas should fill the screen in CSS pixels:
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      
      // 4) Internally, give the canvas more pixels (for crispness):
      canvas.width = Math.floor(width * dpr);
      canvas.height = Math.floor(height * dpr);
      
      // Обновляем размеры offscreen‑canvas:
      updateCachedCanvasSizes();
      // Сброс кэша, чтобы сразу перерисовать фон на новом размере
      lastBiomeStaticUpdate = 0;
      // 5) Make 1 “unit” in your drawing code == 1 CSS pixel:
      // If browser supports resetTransform():
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // Attach it:
    window.addEventListener("resize", onResize);
    // Call once on load:
    onResize();

    // =================== Device Detection & UI Setup ===================
    const leftJoystickElem = document.getElementById("leftJoystick");
    const rightJoystickElem = document.getElementById("rightJoystick");
    const mobilePauseButton = document.getElementById("mobilePauseButton");
    let scaleFactor = (isMobile) ? (1 / dpr) : 1;
    if(isMobile) {
      leftJoystickElem.style.display = "block";
      rightJoystickElem.style.display = "block";
      mobilePauseButton.style.display = "block";
      document.getElementById("startHint").innerHTML = "Tap anywhere to begin";
    }
    let uiScale = isMobile ? 1.6 : 1; // Increase scale on mobile

    
    // =================== Update Scale Function ===================
    function updateScale() {
      if (isMobile) {
        // On mobile, use landscape or portrait-specific scales.
        if (window.innerWidth > window.innerHeight) {
          uiScale = 1.6 / dpr;    // mobile landscape
        } else {
          uiScale = 1.6 / dpr;  // mobile portrait
        }
      } else {
        // On desktop, always use scale 1.
        uiScale = 1;
      }
      // Update CSS custom property so that DOM elements also scale accordingly.
      document.documentElement.style.setProperty('--ui-scale', uiScale);
    }
    

    // Call updateScale initially
    updateScale();

    // Add resize listener to update canvas dimensions and scale on orientation change
    window.addEventListener("resize", () => {
      onResize();
      updateScale();
    });

    // =================== Game States & Global Variables ===================
    // States: "menu", "playing", "transition", "powerup", "pause", "gameover"
    let gameState = "menu";
    let score = 0;
    let currentLevel = 1;
    let levelDuration = 30000; // 30 sec per wave
    let levelTimer = levelDuration;
    let maxLevelDuration = 60000;
    // Permanent upgrades (affect damage, speed, fire rate)
    const permanentUpgrades = {
      damage: 1,
      speed: 1,
      fireRate: 1,
      health: 0            // *** NEW: добавлено для перманентного увеличения здоровья ***
    };
    // Power meter for temporary power‑ups
    let powerMeter = 0;
    //const POWER_METER_MAX = 100;
    function getPowerMeterMax() {
      return 100 + Math.floor((currentLevel - 1) / 2) * 80;  //Harm-mode
    }
    // Spawn & firing timers
    let enemySpawnTimer = 0;
    let enemySpawnInterval = 1500;
    let fireCooldown = 0;
    const BASE_FIRE_RATE = 200;

    // =================== Global Arrays for Game Objects ===================
    let player;
    let bullets = [];
    let enemies = [];
    const collectibles = [];
    const particles = [];
    // Вместо одиночного босса используем массив
    let bosses = [];
    // --- Новый массив для отображения урона (плавающие красные числа) ---
    let damageTexts = [];
    // *** NEW: Массив для объектов-друзей (Friend) ***
    let friends = [];

    // =================== Input Handling ===================
    const keys = {};
    const mouse = { x: width/2, y: height/2, down: false };
    window.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
      if((gameState === "menu" || gameState === "gameover") && (e.key === " " || e.code === "Space")) {
        startGame();
      }
      if(e.key === "Escape") {
        if(gameState === "playing") pauseGame();
        else if(gameState === "pause") resumeGame();
      }
    });
    window.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener("mousedown", () => { mouse.down = true; });
    canvas.addEventListener("mouseup", () => { mouse.down = false; });
    mobilePauseButton.addEventListener("click", () => {
      if(gameState === "playing") pauseGame();
    });
    document.addEventListener("pointerdown", (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') {
        return;
      }
      if (gameState === "menu" || gameState === "gameover") {
        startGame();
      }
    });
    

    // =================== Virtual Joysticks (Mobile) ===================
    const leftJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
    const rightJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0, angle: 0 };
    function setupJoystick(joystickElem, joystickObj) {
      // Get the thumb element from the joystick container
      const thumb = joystickElem.querySelector('.joystick-thumb');
    
      // Touch Start: store the active touch and reset offsets
      joystickElem.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (!joystickObj.active) {
          const touch = e.changedTouches[0];
          joystickObj.active = true;
          joystickObj.activeTouchId = touch.identifier; // Save the unique touch id
          const rect = joystickElem.getBoundingClientRect();
          joystickObj.startX = touch.clientX - rect.left;
          joystickObj.startY = touch.clientY - rect.top;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          // Ensure the thumb starts centered
          thumb.style.transform = 'translate(0px, 0px)';
        }
      });
    
      // Touch Move: update the joystick offset and move the thumb visually
      joystickElem.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if (!joystickObj.active) return;
    
        // Find the touch that corresponds to this joystick
        let relevantTouch = null;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joystickObj.activeTouchId) {
            relevantTouch = e.changedTouches[i];
            break;
          }
        }
        if (!relevantTouch) return; // No matching touch
    
        const rect = joystickElem.getBoundingClientRect();
        const x = relevantTouch.clientX - rect.left;
        const y = relevantTouch.clientY - rect.top;
        let dx = x - joystickObj.startX;
        let dy = y - joystickObj.startY;
        const maxDist = 80 * uiScale; // Adjust according to your new joystick size
        const dist = Math.hypot(dx, dy);
        if (dist > maxDist) {
          dx = (dx / dist) * maxDist;
          dy = (dy / dist) * maxDist;
        }
        joystickObj.dx = dx;
        joystickObj.dy = dy;
        
        // Update the thumb's position for visual feedback:
        thumb.style.transform = 'translate(' + dx + 'px, ' + dy + 'px)';
    
        // If this is the right joystick, update the aiming angle as well
        if (joystickObj === rightJoystick) {
          joystickObj.angle = Math.atan2(dy, dx);
        }
      });
    
      // Touch End: reset the joystick state and thumb position
      joystickElem.addEventListener("touchend", (e) => {
        let touchEnded = false;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joystickObj.activeTouchId) {
            touchEnded = true;
            break;
          }
        }
        if (touchEnded) {
          joystickObj.active = false;
          joystickObj.activeTouchId = null;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          // Reset thumb to center
          thumb.style.transform = 'translate(0px, 0px)';
        }
      });
    
      // Handle touch cancel events similarly to touch end
      joystickElem.addEventListener("touchcancel", (e) => {
        let touchCanceled = false;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joystickObj.activeTouchId) {
            touchCanceled = true;
            break;
          }
        }
        if (touchCanceled) {
          joystickObj.active = false;
          joystickObj.activeTouchId = null;
          joystickObj.dx = 0;
          joystickObj.dy = 0;
          thumb.style.transform = 'translate(0px, 0px)';
        }
      });
    }
    
    
    if(isMobile) {
      setupJoystick(leftJoystickElem, leftJoystick);
      setupJoystick(rightJoystickElem, rightJoystick);
    }
    // =================== Drawing Enemies ===================
    // Спайковый круг – для базовых врагов
    function drawSpikyCircle(ctx, radius, spikes, spikeFactor) {
      const step = (Math.PI * 2) / (spikes * 2);
      ctx.beginPath();
      for (let i = 0; i < spikes * 2; i++) {
        // Чередуем радиус: обычный и увеличенный на spikeFactor
        const r = i % 2 === 0 ? radius : radius * (1 + spikeFactor);
        const angle = i * step;
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }
    
    // Функция отрисовки многоугольника (например, для элитных врагов)
    function drawPolygon(ctx, sides, radius) {
      const step = (Math.PI * 2) / sides;
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const angle = i * step;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }
    
    // Функция отрисовки снежинки – для врагов типа "freeze"
    function drawSnowflake(ctx, radius) {
      ctx.save();
      ctx.lineWidth = 2;
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI) / 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
        // Добавляем небольшие "ветви"
        let branchAngle = angle + Math.PI / 12;
        ctx.moveTo(radius * 0.7 * Math.cos(angle), radius * 0.7 * Math.sin(angle));
        ctx.lineTo(
          radius * 0.9 * Math.cos(branchAngle),
          radius * 0.9 * Math.sin(branchAngle)
        );
        ctx.stroke();
      }
      ctx.restore();
    }
    
    // Функция отрисовки турели – для врагов типа "shooter"
    function drawTurret(ctx, radius) {
      // Основа – круг
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.fill();
      // "Ствол" – прямоугольник, направленный вправо
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.rect(0, -radius * 0.2, radius, radius * 0.4);
      ctx.fill();
    }
    
    // Функция отрисовки эллипса – для врагов типа "parasite"
    function drawEllipse(ctx, rx, ry) {
      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Функция отрисовки зазубренной фигуры – для врагов типа "emp"
    function drawJaggedShape(ctx, radius) {
      const points = 8;
      ctx.beginPath();
      for (let i = 0; i < points; i++) {
        const angle = (i * Math.PI * 2) / points;
        // Немного случайного колебания радиуса для зазубренности
        const r = radius * (0.7 + Math.random() * 0.6);
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }
    
    // Функция отрисовки треугольника – для врагов типа "sharpshooter"
    function drawTriangle(ctx, radius) {
      ctx.beginPath();
      ctx.moveTo(0, -radius);
      ctx.lineTo(radius, radius);
      ctx.lineTo(-radius, radius);
      ctx.closePath();
      ctx.fill();
    }
    
    // Функция отрисовки "бомбы" – для врагов типа "exploder"
    function drawBomb(ctx, radius) {
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.fill();
      // Фьюз
      ctx.beginPath();
      ctx.moveTo(radius * 0.5, -radius * 0.5);
      ctx.lineTo(radius * 0.8, -radius * 0.8);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    // Функция отрисовки сегментированной фигуры – для врагов типа "splitter"
    function drawSegmentedShape(ctx, radius) {
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      // Разделительные линии
      for (let i = 0; i < 4; i++) {
        const angle = (i * Math.PI) / 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
        ctx.stroke();
      }
    }
    
    // Для боссов можно добавить функцию звёздной фигуры – например, для титула "Emperor"
    function drawStar(ctx, outerRadius, points, insetFactor) {
      const step = Math.PI / points;
      ctx.beginPath();
      for (let i = 0; i < 2 * points; i++) {
        const r = i % 2 === 0 ? outerRadius : outerRadius * insetFactor;
        const angle = i * step;
        const x = r * Math.cos(angle);
        const y = r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
    }

    // =================== Biomes / Backgrounds ===================
   
    const biomes = [
      {
        name: "Neon Arena",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#111";
          context.fillRect(0,0,width,height);
          const gridSize = 50;
          context.strokeStyle = "#222";
          context.lineWidth = 1 * scaleFactor;
          for(let x = 0; x < width; x += actualGridSize){
            context.beginPath();
            context.moveTo(x,0);
            context.lineTo(x,height);
            context.stroke();
          }
          for(let y = 0; y < height; y += actualGridSize){
            context.beginPath();
            context.moveTo(0,y);
            context.lineTo(width,y);
            context.stroke();
          }
        }
      },
      {
        name: "Galactic Nebula",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Создаём эффект туманной галактики с помощью радиального градиента
          let grad = context.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height) / 2);
          grad.addColorStop(0, "#2a2a72");   // тёмно-синий/фиолетовый
          grad.addColorStop(0.5, "#9c27b0");   // яркий пурпурный
          grad.addColorStop(1, "#0d0d0d");     // почти чёрный
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          
          // Добавляем "туманные облака" – полупрозрачные круги
          for (let i = 0; i < 50; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            let radius = Math.random() * 50 + 20;
            context.beginPath();
            context.arc(x, y, radius, 0, Math.PI * 2);
            context.fillStyle = "rgba(156,39,176,0.1)";
            context.fill();
          }
          
          // Рассыпка случайных звёзд
          for (let i = 0; i < 200; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            context.fillStyle = "rgba(255,255,255," + (Math.random() * 0.8) + ")";
            context.fillRect(x, y, 2, 2);
          }
        }
      },
      {
        name: "Neon Abyss",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Радиационный градиент от темно-синего к чёрному
          let grad = context.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height)/2);
          grad.addColorStop(0, "#000033");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          // Рисуем «неоновые пузыри»
          for (let i = 0; i < 50; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            let r = Math.random() * 30 + 10;
            context.beginPath();
            context.arc(x, y, r, 0, Math.PI * 2);
            context.strokeStyle = "rgba(0,255,255,0.3)";
            context.lineWidth = 4 * scaleFactor;
            context.shadowColor = "rgba(0,255,255,0.8)";
            context.shadowBlur = 15 * scaleFactor;
            context.stroke();
            context.shadowBlur = 0;
          }
        }
      },
      {
        name: "Pixelated Matrix",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Чёрный фон
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          // Рисуем случайные «биты» в стиле матрицы
          context.fillStyle = "rgba(0,255,0,0.2)";
          const fontSize = 44 * scaleFactor;
          context.font = fontSize + "px monospace";
          if (!isMobile) {
            for (let i = 0; i < 100; i++) {
              let x = Math.random() * width;
              let y = Math.random() * height;
              context.fillText(Math.random() > 0.5 ? "0" : "1", x, y);
            }
          } else {
            // Mobile: only update glitch e.g. once every 10 frames
            glitchFrameCounter++;
            if (glitchFrameCounter % 10 === 0) {
              for (let i = 0; i < 100; i++) {
                let x = Math.random() * width;
                let y = Math.random() * height;
                context.fillText(Math.random() > 0.5 ? "0" : "1", x, y);
              }
            }
          }
        }
      },
      {
        name: "Retro Wave",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Градиент от пурпурного к оранжевому
          let grad = context.createLinearGradient(0, 0, 0, height);
          grad.addColorStop(0, "rgba(128,0,128,0.5)");
          grad.addColorStop(1, "rgba(255,140,0,0.5)");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          // Лёгкая сетка
          context.strokeStyle = "rgba(255,255,255,0.1)";
          context.lineWidth = 1 * scaleFactor;
          for (let x = 0; x < width; x += 50 * scaleFactor) {
            context.beginPath();
            context.moveTo(x, 0);
            context.lineTo(x, height);
            context.stroke();
          }
          for (let y = 0; y < height; y += 50 * scaleFactor) {
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(width, y);
            context.stroke();
          }
        }
      },
      {
        name: "Cyber Circuit",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          // Рисуем «схемные» линии и узлы
          context.strokeStyle = "#00f";
          context.lineWidth = 2 * scaleFactor;
          if (!isMobile) {
            // Desktop: re-generate glitch EVERY frame
            for (let i = 0; i < 20; i++) {
              let x = Math.random() * width;
              let y = Math.random() * height;
              context.beginPath();
              context.moveTo(x, y);
              context.lineTo(x + (Math.random() - 0.5) * 100, y + (Math.random() - 0.5) * 100);
              context.stroke();
            }
            for (let i = 0; i < 10; i++) {
              let x = Math.random() * width;
              let y = Math.random() * height;
              context.beginPath();
              context.arc(x, y, Math.random() * 20, 0, Math.PI * 2);
              context.stroke();
            }
          } else {
            // Mobile: only update glitch e.g. once every 10 frames
            glitchFrameCounter++;
            if (glitchFrameCounter % 10 === 0) {
              for (let i = 0; i < 20; i++) {
                let x = Math.random() * width;
                let y = Math.random() * height;
                context.beginPath();
                context.moveTo(x, y);
                context.lineTo(x + (Math.random() - 0.5) * 100, y + (Math.random() - 0.5) * 100);
                context.stroke();
              }
              for (let i = 0; i < 10; i++) {
                let x = Math.random() * width;
                let y = Math.random() * height;
                context.beginPath();
                context.arc(x, y, Math.random() * 20, 0, Math.PI * 2);
                context.stroke();
              }
            }
          }
        }
      },
      {
        name: "Digital Dystopia",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Градиент тёмно-красного к чёрному
          let grad = context.createLinearGradient(0, 0, width, height);
          grad.addColorStop(0, "#330000");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          if (!isMobile) {
            // Desktop: re-generate glitch EVERY frame
            for (let i = 0; i < 40; i++) {
              context.fillStyle = "rgba(0,255,0,0.1)";
              let x = Math.random() * width;
              let y = Math.random() * height;
              let w = Math.random() * 80;
              let h = Math.random() * 20;
              context.fillRect(x, y, w, h);
            }
          } else {
            // Mobile: only update glitch e.g. once every 10 frames
            glitchFrameCounter++;
            if (glitchFrameCounter % 10 === 0) {
              for (let i = 0; i < 40; i++) {
                context.fillStyle = "rgba(0,255,0,0.1)";
                let x = Math.random() * width;
                let y = Math.random() * height;
                let w = Math.random() * 80;
                let h = Math.random() * 20;
                context.fillRect(x, y, w, h);
              }
            }
          }
        }
      },
      {
        name: "Holographic Grid",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Фон с затемнённым градиентом
          let grad = context.createLinearGradient(0, 0, 0, height);
          grad.addColorStop(0, "#111");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          // Наложение полупрозрачной сетки
          context.strokeStyle = "rgba(0,255,255,0.15)";
          context.lineWidth = 1 * scaleFactor;
          let gridSize = 40 * scaleFactor;
          for (let x = 0; x < width; x += gridSize) {
            context.beginPath();
            context.moveTo(x, 0);
            context.lineTo(x, height);
            context.stroke();
          }
          for (let y = 0; y < height; y += gridSize) {
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(width, y);
            context.stroke();
          }
        }
      },
      {
        name: "Laser Lair",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          if (!isMobile) {
            // Desktop: re-generate glitch EVERY frame
            for (let i = 0; i < 15; i++) {
              context.beginPath();
              let startX = Math.random() * width;
              let startY = Math.random() * height;
              let angle = Math.random() * Math.PI * 2;
              let length = Math.random() * 200 + 100;
              context.moveTo(startX, startY);
              context.lineTo(startX + Math.cos(angle) * length, startY + Math.sin(angle) * length);
              context.strokeStyle = "rgba(255,0,0,0.5)";
              context.lineWidth = 4 * scaleFactor;
              context.shadowColor = "rgba(255,0,0,1)";
              context.shadowBlur = 10 * scaleFactor;
              context.stroke();
              context.shadowBlur = 0;
            }
          } else {
            // Mobile: only update glitch e.g. once every 10 frames
            glitchFrameCounter++;
            if (glitchFrameCounter % 10 === 0) {
              for (let i = 0; i < 15; i++) {
                context.beginPath();
                let startX = Math.random() * width;
                let startY = Math.random() * height;
                let angle = Math.random() * Math.PI * 2;
                let length = Math.random() * 200 + 100;
                context.moveTo(startX, startY);
                context.lineTo(startX + Math.cos(angle) * length, startY + Math.sin(angle) * length);
                context.strokeStyle = "rgba(255,0,0,0.5)";
                context.lineWidth = 4 * scaleFactor;
                context.shadowColor = "rgba(255,0,0,1)";
                context.shadowBlur = 10 * scaleFactor;
                context.stroke();
                context.shadowBlur = 0;
              }
            }
          }
        }
      },
      {
        name: "Virtual Vortex",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          // Рисуем вихревые линии, создающие эффект воронки
          let centerX = width / 2;
          let centerY = height / 2;
          if (!isMobile) {
            // Desktop: re-generate glitch EVERY frame
            for (let i = 0; i < 30; i++) {
              context.beginPath();
              let radius = (i / 30) * Math.max(width, height) / 2;
              context.arc(centerX, centerY, radius, Math.PI * 0.5 + i * 0.2, Math.PI * 1.5 + i * 0.2);
              context.strokeStyle = "rgba(0,255,255," + (0.1 + i / 300) + ")";
              context.lineWidth = 3 * scaleFactor;
              context.stroke();
            }
          } else {
            // Mobile: only update glitch e.g. once every 10 frames
            glitchFrameCounter++;
            if (glitchFrameCounter % 10 === 0) {
              for (let i = 0; i < 30; i++) {
                context.beginPath();
                let radius = (i / 30) * Math.max(width, height) / 2;
                context.arc(centerX, centerY, radius, Math.PI * 0.5 + i * 0.2, Math.PI * 1.5 + i * 0.2);
                context.strokeStyle = "rgba(0,255,255," + (0.1 + i / 300) + ")";
                context.lineWidth = 3 * scaleFactor;
                context.stroke();
              }
            }
          }
        }
      },
      {
        name: "Cyber Grid",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          const grad = context.createLinearGradient(0,0,width,height);
          grad.addColorStop(0, "#001a00");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0,0,width,height);
          const gridSize = 60;
          context.strokeStyle = "rgba(0,255,100,0.2)";
          context.lineWidth = 1 * scaleFactor;
          for(let x = 0; x < width; x += actualGridSize2){
            context.beginPath();
            context.moveTo(x,0);
            context.lineTo(x,height);
            context.stroke();
          }
          for(let y = 0; y < height; y += actualGridSize2){
            context.beginPath();
            context.moveTo(0,y);
            context.lineTo(width,y);
            context.stroke();
          }
        }
      },
      {
        name: "Digital Void",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          context.fillStyle = "#000";
          context.fillRect(0,0,width,height);
          if (!isMobile) {
            // Desktop: re-generate glitch EVERY frame
            for(let i=0;i<150;i++){
              const x = Math.random()*width;
              const y = Math.random()*height;
              context.fillStyle = "#fff";
              context.fillRect(x,y,2,2);
            }
          } else {
            // Mobile: only update glitch e.g. once every 10 frames
            glitchFrameCounter++;
            if (glitchFrameCounter % 10 === 0) {
              for(let i=0;i<150;i++){
                const x = Math.random()*width;
                const y = Math.random()*height;
                context.fillStyle = "#fff";
                context.fillRect(x,y,2,2);
              }
            }
          }
        }
      },
      // Добавляем новые биомы:
      {
        name: "Cyber Grid Cyan",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          const grad = context.createLinearGradient(0,0,width,height);
          grad.addColorStop(0, "#001a00");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0,0,width,height);
          const gridSize = 60;
          context.strokeStyle = "rgba(0,255,255,0.2)";
          context.lineWidth = 1 * scaleFactor;
          for(let x = 0; x < width; x += actualGridSize2){
            context.beginPath();
            context.moveTo(x,0);
            context.lineTo(x,height);
            context.stroke();
          }
          for(let y = 0; y < height; y += actualGridSize2){
            context.beginPath();
            context.moveTo(0,y);
            context.lineTo(width,y);
            context.stroke();
          }
        }
      },
      {
        name: "Aurora Borealis",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Используем линейный градиент для имитации северного сияния
          let grad = context.createLinearGradient(0, 0, 0, height);
          grad.addColorStop(0, "#1a237e");
          grad.addColorStop(0.5, "#43a047");
          grad.addColorStop(1, "#fdd835");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          // Добавляем плавные линии, имитирующие сияние
          for (let i = 0; i < 10; i++) {
            context.beginPath();
            context.moveTo(0, Math.random() * height);
            context.bezierCurveTo(
              width * 0.3, Math.random() * height,
              width * 0.7, Math.random() * height,
              width, Math.random() * height
            );
            context.strokeStyle = "rgba(255, 255, 255, 0.1)";
            context.lineWidth = 2 * scaleFactor;
            context.stroke();
          }
        }
      },
      {
        name: "Cyber Grid Violet",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          const grad = context.createLinearGradient(0,0,width,height);
          grad.addColorStop(0, "#001a00");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0,0,width,height);
          const gridSize = 60;
          context.strokeStyle = "rgba(255,0,255,0.2)";
          context.lineWidth = 1 * scaleFactor;
          for(let x = 0; x < width; x += actualGridSize2){
            context.beginPath();
            context.moveTo(x,0);
            context.lineTo(x,height);
            context.stroke();
          }
          for(let y = 0; y < height; y += actualGridSize2){
            context.beginPath();
            context.moveTo(0,y);
            context.lineTo(width,y);
            context.stroke();
          }
        }
      },
      {
        name: "Glitch Zone",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Always draw the (current) glitchCanvas first.
          context.drawImage(glitchCanvas, 0, 0);
          
          if (!isMobile) {
            // Desktop: re-generate glitch EVERY frame
            generateGlitchPattern();
          } else {
            // Mobile: only update glitch e.g. once every 10 frames
            glitchFrameCounter++;
            if (glitchFrameCounter % 10 === 0) {
              generateGlitchPattern();
            }
          }
        }
      },
      {
        name: "Cosmic Rift",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Радиационный градиент, создающий космическое настроение
          let grad = context.createRadialGradient(width / 2, height / 2, 0, width / 2,    height / 2, Math.max(width, height) / 2);
          grad.addColorStop(0, "#0d0d0d");
          grad.addColorStop(0.5, "#1a1a1a");
          grad.addColorStop(1, "#000");
          context.fillStyle = grad;
          context.fillRect(0, 0, width, height);
          if (!isMobile) {
            // Desktop: re-generate glitch EVERY frame
            // Рисуем звёзды
            for (let i = 0; i < 100; i++) {
              context.fillStyle = "#fff";
              let x = Math.random() * width;
              let y = Math.random() * height;
              context.fillRect(x, y, 1.5 * scaleFactor, 1.5 * scaleFactor);
            }
            // Лёгкие круговые вспышки для эффекта космических рифтов
            for (let i = 0; i < 5; i++) {
              context.beginPath();
              context.arc(Math.random() * width, Math.random() * height, Math.random() * (100 * scaleFactor),     0, Math.PI * 2);
              context.strokeStyle = "rgba(255, 0, 255, 0.1)";
              context.lineWidth = 5 * scaleFactor;
              context.stroke();
            }
          } else {
            // Mobile: only update glitch e.g. once every 10 frames
            glitchFrameCounter++;
            if (glitchFrameCounter % 10 === 0) {
              // Рисуем звёзды
              for (let i = 0; i < 100; i++) {
                context.fillStyle = "#fff";
                let x = Math.random() * width;
                let y = Math.random() * height;
                context.fillRect(x, y, 1.5 * scaleFactor, 1.5 * scaleFactor);
              }
              // Лёгкие круговые вспышки для эффекта космических рифтов
              for (let i = 0; i < 5; i++) {
                context.beginPath();
                context.arc(Math.random() * width, Math.random() * height, Math.random() * (100 * scaleFactor),     0, Math.PI * 2);
                context.strokeStyle = "rgba(255, 0, 255, 0.1)";
                context.lineWidth = 5 * scaleFactor;
                context.stroke();
              }
            }
          }
          
        }
      },
      {
        name: "Retro Circuit",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Фон в стиле печатной платы
          context.fillStyle = "#001";
          context.fillRect(0, 0, width, height);
          context.strokeStyle = "#0f0";
          context.lineWidth = 2 * scaleFactor;
          // Вертикальные линии
          for (let x = 0; x < width; x += actualGridSize40) {
            context.beginPath();
            context.moveTo(x, 0);
            context.lineTo(x, height);
            context.stroke();
          }
          // Горизонтальные линии
          for (let y = 0; y < height; y += actualGridSize40) {
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(width, y);
            context.stroke();
          }
          // Рисуем случайные "узлы" для имитации контактов
          for (let i = 0; i < 20; i++) {
            let x = Math.random() * width;
            let y = Math.random() * height;
            context.beginPath();
            context.arc(x, y, 3 * scaleFactor, 0, Math.PI * 2);
            context.fillStyle = "#0f0";
            context.fill();
          }
        }
      },
      {
        name: "Neon Forest",
        drawBackground: function(ctxToUse) {
          let context = ctxToUse || ctx;
          // Тёмный фон с неоновыми "деревьями"
          context.fillStyle = "#000";
          context.fillRect(0, 0, width, height);
          // Рисуем неоновые столбы (как абстрактные деревья)
          for (let i = 0; i < 10; i++) {
            let x = Math.random() * width;
            let treeHeight = Math.random() * (height / 2) + height / 4;
            context.beginPath();
            context.moveTo(x, height);
            context.lineTo(x, height - treeHeight);
            context.strokeStyle = "rgba(0,255,150,0.7)";
            context.lineWidth = 4 * scaleFactor;
            context.shadowColor = "rgba(0,255,150,0.7)";
            context.shadowBlur = 10;
            context.stroke();
            context.shadowBlur = 0;
          }
        }
      }
    ];
    function getCurrentBiome() {
      return biomes[(currentLevel - 1) % biomes.length];
    }

    // Outside your draw function, create an offscreen canvas & context
    const glitchCanvas = document.createElement('canvas');
    const glitchCtx = glitchCanvas.getContext('2d');

    // We'll keep a frame counter so we can throttle updates on mobile
    let glitchFrameCounter = 0;

    // This function draws a new random glitch pattern onto glitchCanvas
    function generateGlitchPattern() {
      glitchCanvas.width = width;    // match your main canvas dimensions
      glitchCanvas.height = height;
      
      // 1) Solid black background
      glitchCtx.fillStyle = "#000";
      glitchCtx.fillRect(0, 0, width, height);
      
      // 2) Random color rectangles
      for (let i = 0; i < 30; i++) {
        glitchCtx.fillStyle = `rgba(
          ${Math.floor(Math.random() * 256)},
          ${Math.floor(Math.random() * 256)},
          ${Math.floor(Math.random() * 256)},
          0.2
        )`;
        let x = Math.random() * width;
        let y = Math.random() * height;
        let w = Math.random() * (50 * scaleFactor);
        let h = Math.random() * (20 * scaleFactor);
        glitchCtx.fillRect(x, y, w, h);
      }
      
      // 3) Random horizontal lines
      for (let i = 0; i < 10; i++) {
        glitchCtx.beginPath();
        let y = Math.random() * height;
        glitchCtx.moveTo(0, y);
        glitchCtx.lineTo(width, y);
        glitchCtx.strokeStyle = "rgba(255,255,255,0.1)";
        glitchCtx.lineWidth = (Math.random() * 3) * scaleFactor;
        glitchCtx.stroke();
      }
    }

    // =================== Classes ===================
    // --- Player ---
    class Player {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 15 * scaleFactor;
        this.maxHP = 100;
        this.currentHP = 100;
        this.baseSpeed = 3 * scaleFactor;
        this.speed = this.baseSpeed;
        // Temporary power‑ups (duration in ms)
        this.activePowerUps = {
          // Double Shot – позволяет одновременно выпускать две пули с небольшим угловым отклонением.
          doubleShot: { duration: 0, stacks: 0 },
          // Triple Shot – позволяет стрелять тремя пулями одновременно, повышая шанс попадания.
          tripleShot: { duration: 0, stacks: 0 },
          // Rapid Fire – ускоряет стрельбу, уменьшая интервал между выстрелами.
          rapidFire: { duration: 0, stacks: 0 },
          // Shield – создает временный защитный щит вокруг игрока, уменьшая получаемый урон
          // от боссов (только половина урона) и полностью блокируя урон от обычных врагов.
          shield: { duration: 0, stacks: 0 },
          // Speed Boost – временно увеличивает скорость передвижения игрока (×2).
          speedBoost: { duration: 0, stacks: 0 },
          // Damage Boost – повышает наносимый урон за счет увеличения силы выстрелов.
          damageBoost: { duration: 0, stacks: 0 },
          // Piercing – пули с этим эффектом могут пробивать нескольких врагов подряд.
          piercing: { duration: 0, stacks: 0 },
          // Homing – пули с автонаведением, корректирующие траекторию в сторону ближайшего врага.
          homing: { duration: 0, stacks: 0 },
          // Bomb – пули, взрывающиеся при попадании и наносящие урон в области взрыва.
          bomb: { duration: 0, stacks: 0 },
          // Freeze Blast – замораживает врагов, снижая их скорость или полностью останавливая их на время.
          freezeBlast: { duration: 0, stacks: 0 },
          // Reflective – пули, которые отскакивают от границ экрана, увеличивая вероятность попадания.
          reflective: { duration: 0, stacks: 0 },
          // Life Steal – при попадании пули возвращают часть здоровья игроку.
          lifeSteal: { duration: 0, stacks: 0 },
          // EMP Blast – пули, которые могут временно оглушать или замедлять врагов, воздействуя на их электронику.
          empBlast: { duration: 0, stacks: 0 },
          // Critical Strike – увеличивает шанс нанести критический урон (например, двойной урон).
          criticalStrike: { duration: 0, stacks: 0 },
          // Overcharge – увеличивает скорость пуль.
          overcharge: { duration: 0, stacks: 0 },
          // Scatter Shot – добавляет +4 пули за каждый стэк.
          scatterShot: { duration: 0, stacks: 0 },
          // *** NEW: временное увеличение здоровья (увеличивает maxHP на +20) ***
          healthBoost: { duration: 0, stacks: 0, bonus: 0 },
          // *** NEW: магнит очков (притягивает коллекционные объекты) ***
          scoreMagnet: { duration: 0, stacks: 0 },
          // *** NEW: Friend power‑up – при получении появляется друг рядом с игроком ***
          friend: { duration: 0, stacks: 0 },
          neonOverdrive: { duration: 0, stacks: 0 }, // Добавлено
          // удвоение прироста powerMeter
          powerMeterBoost: { duration: 0, stacks: 0 },
          // Пуль всем хватит:
          bulletTime: { duration: 0, stacks: 0 }
        };
        // Additional status effects (негативные эффекты)
        this.frozenTime = 0;
        this.shootingDisabled = 0;
        this.empSlowed = 0;
        this.angle = 0;
      }
      update(deltaTime) {
        // Обновление таймеров усилений: уменьшаем время и сбрасываем стеки, когда время истекает
        const nonDecayingEffects = ["friend", "scoreMagnet", "neonOverdrive", "powerMeterBoost", "damageBoost", "shield", "shielspeedBoostd"];
        const nonDecayingEffects2 = ["doubleShot", "tripleShot", "scatterShot"];
        for (let key in this.activePowerUps) {
          let pu = this.activePowerUps[key];
          if (pu.duration > 0) {
            if (
              this.activePowerUps.neonOverdrive &&
              this.activePowerUps.neonOverdrive.duration > 0 &&
              !nonDecayingEffects.includes(key)
            ){

            } else if (
              this.activePowerUps.bulletTime &&
              this.activePowerUps.bulletTime.duration > 0 &&
              nonDecayingEffects2.includes(key)
            ){

            } else {
              // Обновляем время действия эффекта
              pu.duration -= deltaTime;
              if (pu.duration < 0) pu.duration = 0;

            }


            // Сохраняем предыдущее количество стэков, чтобы понять, сколько стэков "упало" за этот кадр
            let previousStacks = pu.stacks || 0;
            
            // Получаем отображаемое имя для определения времени одного стэка
            let displayName = getPowerUpDisplayName(key);
            let timePerStack = powerUpDurations[displayName] || 30000;
            
            // Используем Math.ceil, чтобы при любом положительном оставшемся времени было минимум 1 стэк
            pu.stacks = pu.duration > 0 ? Math.ceil(pu.duration / timePerStack) : 0;
        
            // Если это Health Boost – снимаем бонус постепенно (по 50 за каждый потерянный стэк)
            if (key === "healthBoost") {
              const bonusPerStack = 50; // бонус, который даёт один стэк
              let expiredStacks = previousStacks - pu.stacks;
              if (expiredStacks > 0) {
                let bonusToRemove = bonusPerStack * expiredStacks;
                this.maxHP -= bonusToRemove;
                if (this.currentHP > this.maxHP) this.currentHP = this.maxHP;
                pu.bonus -= bonusToRemove;
                if (pu.bonus < 0) pu.bonus = 0;  // на всякий случай – не допускаем отрицательного бонуса
              }
            }
        
            // Если число стэков стало 0, обнуляем параметры эффекта
            if (pu.stacks <= 0) {
              pu.duration = 0;
              pu.stacks = 0;
              // На случай, если остаётся небольшой остаточный бонус для Health Boost – удаляем его полностью
              if (key === "healthBoost" && pu.bonus > 0) {
                this.maxHP -= pu.bonus;
                if (this.currentHP > this.maxHP) this.currentHP = this.maxHP;
                pu.bonus = 0;
              }
            }
          }
        }
        // Если игрок заморожен, полностью блокируем движение
        if (this.frozenTime > 0) {
          this.frozenTime -= deltaTime;
          return;  // ранний выход — никаких изменений позиции
        }
        // Вычисляем базовую скорость с учётом постоянного апгрейда и временного ускорения
        let effectiveSpeed = this.baseSpeed * permanentUpgrades.speed;
        if (this.activePowerUps.speedBoost.duration > 0) {
          effectiveSpeed *= 1.8;
        }
        // Если действует EMP замедление, скорость уменьшается (в 2 раза)
        if (this.empSlowed > 0) {
          effectiveSpeed *= 0.5;
          this.empSlowed -= deltaTime;
        }
        let dx = 0, dy = 0;
        if(!isMobile) {
          if(keys["w"]) dy -= 1;
          if(keys["s"]) dy += 1;
          if(keys["a"]) dx -= 1;
          if(keys["d"]) dx += 1;
        } else {
          dx = leftJoystick.dx/(80 * uiScale);
          dy = leftJoystick.dy/(80 * uiScale);
        }
        if(dx || dy) {
          const mag = Math.hypot(dx, dy);
          dx /= mag;
          dy /= mag;
          this.x += dx * effectiveSpeed;
          this.y += dy * effectiveSpeed;
        }
        
        const effectiveHeight = (isMobile && window.innerHeight > window.innerWidth)
            ? height - getBottomCropHeight()
            : height;

        // Constrain to canvas
        this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(effectiveHeight - this.radius, this.y));
        // Aiming: desktop uses mouse; mobile uses right joystick if active
        if (!isMobile) {
          // Desktop: aim with mouse
          this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
        } else {
          // Mobile: only use right joystick if active
          if (rightJoystick.active && (rightJoystick.dx || rightJoystick.dy)) {
            this.angle = rightJoystick.angle;
          }
        }
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        // Если активирован магнит, отрисовываем область его действия
        if (this.activePowerUps.scoreMagnet && this.activePowerUps.scoreMagnet.duration > 0) {
          let baseAttractionRange = 200 * scaleFactor; // базовая дистанция (в пикселях)
          let additionalRangePerStack = 100 * scaleFactor; // прибавка за каждый дополнительный стэк
          let magnetRange = (baseAttractionRange + additionalRangePerStack * (this.activePowerUps.scoreMagnet.stacks - 1));

          ctx.beginPath();
          ctx.arc(0, 0, magnetRange, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)'; // полупрозрачный зелёный цвет
          ctx.shadowColor = 'rgba(0, 255, 0, 0.5)';
          ctx.shadowBlur = 5;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        // Используем проверку длительности для щита:
        if(this.activePowerUps.shield.duration > 0) {
          ctx.beginPath();
          ctx.arc(0,0,this.radius+(8* scaleFactor),0,Math.PI*2);
          ctx.fillStyle = "rgba(0,200,255,0.3)";
          ctx.fill();
        }
        ctx.fillStyle = "#0ff";
        ctx.shadowColor = "#0ff";
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.moveTo( (20*scaleFactor), 0 );
        ctx.lineTo( (-10*scaleFactor),  (10*scaleFactor) );
        ctx.lineTo( (-10*scaleFactor), (-10*scaleFactor) );
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
    // Помогательная функция для нормализации угла в диапазоне [-π, π]
    function normalizeAngle(angle) {
      while (angle > Math.PI) { angle -= 2 * Math.PI; }
      while (angle < -Math.PI) { angle += 2 * Math.PI; }
      return angle;
    }

    // =================== Изменённый класс Friend ===================
    class Friend {
      constructor(offsetAngle) {
        this.offsetAngle = offsetAngle; // фиксированный угол смещения относительно игрока
        this.shootCooldown = 0;
        // Инициализируем позицию в текущем положении игрока (если он уже существует)
        this.x = player ? player.x : 0;
        this.y = player ? player.y : 0;
        // Инициализируем угол "друга" равным углу игрока
        this.angle = player ? player.angle : 0;
      }
      update(deltaTime) {
        if (!player) return;
      
        // Задаём желаемое расстояние от игрока
        const followDistance = 30 * scaleFactor; // можно менять по вкусу
        // Вычисляем желаемую позицию относительно игрока с учётом угла игрока и смещения
        const desiredX = player.x + Math.cos(player.angle + this.offsetAngle) * followDistance;
        const desiredY = player.y + Math.sin(player.angle + this.offsetAngle) * followDistance;


      
        // Перемещаем друга к желаемой позиции
        const diffX = (desiredX - this.x) * scaleFactor;
        const diffY = (desiredY - this.y) * scaleFactor;
        const dist = (Math.hypot(diffX, diffY));
        const catchUpSpeed = (0.4 * deltaTime) * scaleFactor;
        if (dist > 1) {
          const moveDist = Math.min(catchUpSpeed, dist);
          this.x += (diffX / dist) * moveDist * scaleFactor;
          this.y += (diffY / dist) * moveDist * scaleFactor;
        }
      
        // Автонаведение: ищем ближайшего врага для прицеливания
        let nearest = null;
        let minEnemyDist = Infinity;
        for (let enemy of enemies) {
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const d = Math.hypot(dx, dy);
          if (d < minEnemyDist) {
            minEnemyDist = d;
            nearest = enemy;
          }
        }
        // Если враг найден – целевой угол по направлению к нему, иначе используем угол игрока
        let targetAngle = player.angle;
        if (nearest) {
          targetAngle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
        }
      
        // Плавное поворот: постепенно приближаем this.angle к targetAngle
        let angleDiff = normalizeAngle(targetAngle - this.angle);
        const rotationSpeed = 0.010 * deltaTime * scaleFactor; // настройте скорость поворота по необходимости
        if (Math.abs(angleDiff) < rotationSpeed) {
          this.angle = targetAngle;
        } else {
          this.angle += Math.sign(angleDiff) * rotationSpeed;
        }
      
        // Логика стрельбы: стреляем только если угол почти совпадает с целевым (порог 0.1 радиана)
        this.shootCooldown -= deltaTime;
        let friendFireRate = 400; // базовый интервал в мс

        let friendStacks = player.activePowerUps.friend.stacks || 1;
        if (player.activePowerUps.friend && player.activePowerUps.friend.stacks >= 3) {
          friendFireRate = (400 / (1 + 0.5 * (friendStacks - 1))) * scaleFactor;  // при 3+ стэках – ускоряем стрельбу
        }
        if (this.shootCooldown <= 0 && Math.abs(normalizeAngle(targetAngle - this.angle)) < 0.1) {
          let bullet = new Bullet(this.x, this.y, this.angle);
          bullet.fromFriend = true;  // Помечаем пулю как выпущенную другом
          bullets.push(bullet);
          this.shootCooldown = friendFireRate;
        }        
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        // Используем угол, рассчитанный для объекта Friend
        ctx.rotate(this.angle);
        ctx.fillStyle = "#A31FA3"; // фиолетовый цвет
        ctx.shadowColor = "#A31FA3";
        ctx.shadowBlur = 20;
        ctx.beginPath();
        // Рисуем уменьшенную копию фигуры игрока (масштаб 0.5)
        ctx.moveTo((20 * 0.5) * scaleFactor, 0);
        ctx.lineTo((-10 * 0.5) * scaleFactor, (10 * 0.5) * scaleFactor);
        ctx.lineTo((-10 * 0.5) * scaleFactor, (-10 * 0.5) * scaleFactor);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = "#0ff";
        ctx.lineWidth = 2 * scaleFactor;
        ctx.stroke();

        ctx.restore();
      }
    }

    // --- Bullet ---
    class Bullet {
      constructor(x, y, angle, dmgFactor = 1) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 6 * scaleFactor;
        this.radius = 4 * scaleFactor;
        this.damage = 1 * permanentUpgrades.damage * dmgFactor;
        // Special properties (default off)
        this.piercing = false;
        this.piercingCount = 0;
        this.homing = false;
        this.bomb = false;
        this.freezeBlast = false;
        this.empBlast = false;
        this.reflective = false;
        this.critical = false;
        this.lifeSteal = false;
        this.fromBoss = false;
        this.dead = false;
        // --- Добавлен счётчик отскоков для reflective пуль ---
        this.bounceCount = 0;
      }
      update(deltaTime) {
        // Homing effect: adjust angle toward nearest enemy
        if(this.homing && enemies.length > 0) {
          let nearest = null, minDist = Infinity;
          for(let enemy of enemies) {
            const dx = enemy.x - this.x, dy = enemy.y - this.y;
            const d = Math.hypot(dx, dy);
            if(d < minDist) { minDist = d; nearest = enemy; }
          }
          if(nearest) {
            const desired = Math.atan2(nearest.y - this.y, nearest.x - this.x);
            this.angle += 0.1 * (desired - this.angle);
          }
        }
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        // --- Обработка отражения reflective пуль ---
        const effectiveHeight = (isMobile && window.innerHeight > window.innerWidth)
          ? height - getBottomCropHeight()
          : height;
        if(this.reflective) {
          let bounced = false;
          if(this.x < this.radius) {
            this.x = this.radius;
            this.angle = Math.PI - this.angle;
            bounced = true;
          } else if(this.x > width - this.radius) {
            this.x = width - this.radius;
            this.angle = Math.PI - this.angle;
            bounced = true;
          }
          if(this.y < this.radius) {
            this.y = this.radius;
            this.angle = -this.angle;
            bounced = true;
          } else if(this.y > effectiveHeight - this.radius) {
            this.y = effectiveHeight - this.radius;
            this.angle = -this.angle;
            bounced = true;
          }
          if(bounced) {
            this.bounceCount++;
            if(this.bounceCount >= 4) { // после 3 отскоков (на 4-ом исчезает)
              this.dead = true;
            }
          }
        }
      }
      draw() {
        ctx.save();
        if (this.fromFriend) {
          ctx.fillStyle = "rgba(163, 31, 163, 0.7)";  
          ctx.shadowColor = "rgba(163, 31, 163, 0.7)";
        } else if (this.fromBoss || this.fromEnemy) {
          ctx.fillStyle = "#f00";
          ctx.shadowColor = "#f00";
        } else {
          ctx.fillStyle = "#ff0";
          ctx.shadowColor = "#ff0";
        }
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // --- Enemy ---
    class Enemy {
      constructor(x, y, type="basic") {
        this.x = x;
        this.y = y;
        this.type = type;
        this.frozenTime = 0;
        this.empTime = 0;
        this.dead = false;
        // Set properties based on type
        switch(type) {
          case "basic":
            this.radius = 15 * scaleFactor;
            this.speed = 1.5 * scaleFactor;
            this.hp = 1;
            this.color = "#ff4444";
            break;
          case "elite":  // Танк
            this.radius = 20 * scaleFactor;
            this.speed = 0.5 * scaleFactor; // fixed slower speed
            this.hp = 5;
            this.color = "#ff8000";
            break;
          case "freeze":  //Замораживает
            this.radius = 15 * scaleFactor;
            this.speed = 2.0 * scaleFactor;
            this.hp = 1;
            this.color = "#00f";
            break;
          case "shooter": // Должен стрелять (исправлено)
            this.radius = 15 * scaleFactor;
            this.speed = 1.2 * scaleFactor;
            this.hp = 2;
            this.color = "#f0f";
            this.shootCooldown = 2000;
            this.bulletDamage = 15;  // Новый параметр: урон от пули врага
            break;
          case "parasite":  // Забирает возможность стрелять
            this.radius = 12 * scaleFactor;
            this.speed = 3.0 * scaleFactor;
            this.hp = 1;
            this.color = "#0f0";
            break;
          case "emp":
            this.radius = 18 * scaleFactor;
            this.speed = 1.5 * scaleFactor;
            this.hp = 2;
            this.color = "#ff0";
            this.shootCooldown = 2500;
            this.bulletDamage = 10;  // Урон от пули emp-врага
            break;
          case "shielded":
            this.radius = 20 * scaleFactor;
            this.speed = 1.5 * scaleFactor;
            this.hp = 3;
            this.color = "#0ff";
            this.shield = true;
            this.shieldHP = 5;
            break;
          case "sharpshooter":
            this.radius = 15 * scaleFactor;
            this.speed = 0.8 * scaleFactor;
            this.hp = 2;
            this.color = "#608"; // purple tone
            this.shootCooldown = 3000;
            this.bulletDamage = 35;  // Урон от пули sharpshooter
            break;
          case "exploder":
            this.radius = 15 * scaleFactor;
            this.speed = 1.2 * scaleFactor;
            this.hp = 1;
            this.color = "#fa0"; // orange
            break;
          case "splitter":
            this.radius = 18 * scaleFactor;
            this.speed = 1.0 * scaleFactor;
            this.hp = 3;
            this.color = "#0a0"; // dark green            
            break;
          default:
            this.radius = 15 * scaleFactor;
            this.speed = 1.5 * scaleFactor;
            this.hp = 1;
            this.color = "#ff4444";
        }
        // Добавляем усложнение: каждые 3 уровня враги получают +1 к HP
        this.hp += Math.floor(currentLevel / 3);
      }
      update(deltaTime) {
        // If frozen, do not move
        if(this.frozenTime > 0) {
          this.frozenTime -= deltaTime;
          return;
        }
        // Slow down if under EMP effect
        let effSpeed = this.speed;
        if(this.empTime > 0) {
          effSpeed *= 0.5;
          this.empTime -= deltaTime;
        }
        if(this.type === "shooter") {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.hypot(dx, dy);
          const preferredDistance = 250 * scaleFactor;
          if(dist > preferredDistance) {
            this.shootCooldown -= deltaTime;
            this.x += (dx/dist) * this.speed * (deltaTime/16);
            this.y += (dy/dist) * this.speed * (deltaTime/16);
          } else {
            this.shootCooldown -= deltaTime;
            if(this.shootCooldown <= 0) {
              const angle = Math.atan2(dy, dx);
              let spawnX = this.x + Math.cos(angle) * (this.radius + 5);
              let spawnY = this.y + Math.sin(angle) * (this.radius + 5);
              let b = new Bullet(spawnX, spawnY, angle);
              b.fromEnemy = true;         // Помечаем как пуля врага
              b.speed = 6 * scaleFactor;
              b.damage = this.bulletDamage; // Урон берётся из врага
              bullets.push(b);
              this.shootCooldown = 2000;
            }
          }
        }
        if(this.type === "emp") {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.hypot(dx, dy);
          const preferredDistance = 150 * scaleFactor;
          if(dist > preferredDistance) {
            this.shootCooldown -= deltaTime;
            this.x += (dx/dist) * this.speed * (deltaTime/16);
            this.y += (dy/dist) * this.speed * (deltaTime/16);
          } else {
          this.shootCooldown -= deltaTime;
          if(this.shootCooldown <= 0) {
              let angle = Math.atan2(player.y - this.y, player.x - this.x);
              let b = new Bullet(this.x, this.y, angle);
              b.empBlast = true;
              b.speed = 4 * scaleFactor;
              b.damage = this.bulletDamage;
              b.fromEnemy = true;  // Помечаем как пуля врага
              bullets.push(b);
              this.shootCooldown = 2500;
            }
          }
        }
        if(this.type === "sharpshooter") {
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const dist = Math.hypot(dx, dy);
          const preferredDistance = 550 * scaleFactor;
          if(dist > preferredDistance) {
            this.shootCooldown -= deltaTime;
            this.x += (dx/dist) * this.speed * (deltaTime/16);
            this.y += (dy/dist) * this.speed * (deltaTime/16);
          } else {
            this.shootCooldown -= deltaTime;
            if(this.shootCooldown <= 0) {
              const angle = Math.atan2(dy, dx);
              let spawnX = this.x + Math.cos(angle) * this.radius;
              let spawnY = this.y + Math.sin(angle) * this.radius;
              let b = new Bullet(spawnX, spawnY, angle);
              b.fromEnemy = true;        // Помечаем как пуля врага
              b.radius = 8 * scaleFactor;
              b.speed = 7 * scaleFactor;
              b.damage = this.bulletDamage;
              bullets.push(b);
              this.shootCooldown = 3000;
            }
          }
        }
        // Для остальных врагов – стандартное движение (как было)
        if(this.type !== "shooter" && this.type !== "sharpshooter") {
          const dx = player.x - this.x, dy = player.y - this.y;
          const dist = Math.hypot(dx,dy);
          if(dist !== 0) {
            this.x += (dx/dist) * effSpeed;
            this.y += (dy/dist) * effSpeed;
          }
        }
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        ctx.fillStyle = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
          
        switch (this.type) {
          case "basic":
            // Простой спайковый круг (6 спайков, spikeFactor = 0.2)
            drawSpikyCircle(ctx, this.radius, 6, 0.2);
            break;
          case "elite":
            // Рисуем шестиугольник
            drawPolygon(ctx, 6, this.radius);
            break;
          case "freeze":
            // Снежинка – для врагов, замораживающих игрока
            drawSnowflake(ctx, this.radius);
            break;
          case "shooter":
            // Турель – для врагов, которые стреляют
            drawTurret(ctx, this.radius);
            break;
          case "parasite":
            // Эллипс – для тонких, быстрых врагов
            drawEllipse(ctx, 1.2 * this.radius, 0.6 * this.radius);
            break;
          case "emp":
            // Зазубренная фигура – для врагов, применяющих EMP
            drawJaggedShape(ctx, this.radius);
            break;
          case "shielded":
            // Отрисовываем круг и затем добавляем защитный контур
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.save();
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
            break;
          case "sharpshooter":
            // Треугольник – символизирует меткость
            drawTriangle(ctx, this.radius);
            break;
          case "exploder":
            // Форма "бомбы"
            drawBomb(ctx, this.radius);
            break;
          case "splitter":
            // Сегментированная фигура
            drawSegmentedShape(ctx, this.radius);
            break;
          default:
            // Если тип не распознан – стандартный круг
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Если враг заморожен, накладываем прозрачный синий слой
        if (this.frozenTime > 0) {
          ctx.fillStyle = "rgba(0,200,255,0.5)";
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }
    }

    // --- Boss ---
    class Boss {
      // Добавляем параметры x и y, чтобы можно было задавать позицию спавна
      constructor(x, y) {
        // Если координаты заданы, используем их, иначе стандартно центр по горизонтали и y = 100
        this.x = (typeof x === 'number') ? x : width / 2;
        this.y = (typeof y === 'number') ? y : 100;
        
        // Базовый размер босса
        const minBossSize = 20;
        this.baseRadius = Math.max(60 / Math.pow(2, Math.floor((currentLevel - 1) / 5)), minBossSize);
        this.radius = this.baseRadius * scaleFactor;
        
        // Базовые HP и скорость
        this.bossBaseHP = 50;
        let bossDifficulty = currentLevel < 4 ? 0.6 : 1;
        this.maxHP = Math.floor((this.bossBaseHP + currentLevel * 25 * 1.5) * bossDifficulty);  //Hard-mode
        this.hp = this.maxHP;
        const MAX_BOSS_SPEED = 5 * scaleFactor;
        this.speed = Math.min(((1 + currentLevel * 0.1) * bossDifficulty) * scaleFactor, MAX_BOSS_SPEED);
        
        // Определяем титул босса
        if (currentLevel % 15 === 0) this.tier = "Emperor";
        else if (currentLevel % 10 === 0) this.tier = "Champion";
        else if (currentLevel % 5 === 0) this.tier = "Elite";
        else this.tier = "Easy";
        
        // Вместо одного shootCooldown используем массив для всех 5 паттернов
        this.shootCooldown = 3000;
        // --- Добавлен параметр для замедления от Freeze Blast ---
        this.freezeSlow = 0;
      }

      update(deltaTime) {
        // Определяем максимальную стадию, доступную на текущем уровне:
        const maxStage = ((currentLevel - 1) % 5) + 1;
        // Вычисляем соотношение оставшегося здоровья:
        const hpRatio = this.hp / this.maxHP;
        // По умолчанию boss находится на самой "низкой" стадии (максимальное число)
        let stage = maxStage;
        // Для maxStage=5 пороговые значения: >0.8 → stage 1, >0.6 → stage 2, >0.4 → stage 3, >0.2 → stage 4, иначе 5.
        // Для меньшего maxStage масштабируем пороги пропорционально.
        for (let s = 1; s < maxStage; s++) {
          if (hpRatio > (maxStage - s) / maxStage) {
            stage = s;
            break;
          }
        }
        // Теперь stage изменяется от 1 (при почти полном HP) до maxStage (при критически малом HP).
      
        // --- Шаг 1: Определяем эффективную скорость с учётом эффекта Freeze Blast ---
        let effectiveSpeed = this.speed;
        if(this.freezeSlow > 0) {
          effectiveSpeed *= 0.5;
          this.freezeSlow -= deltaTime;
        }
      
        // --- Движение босса ---
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist !== 0) {
          let currentSpeed = effectiveSpeed;
          if (stage >= 4) currentSpeed *= 1.2;
          this.x += (dx / dist) * currentSpeed;
          this.y += (dy / dist) * currentSpeed;
        }
        // Добавляем небольшое колебание: если достигнута максимальная (самая "низкая") стадия и она равна 5,
        // добавляем дрожание, иначе — небольшое косинусоидальное смещение.
        if (stage === 5) {
          this.x += (Math.random() - 0.5) * 5;
          this.y += (Math.random() - 0.5) * 5;
        } else {
          this.x += Math.cos(performance.now() / 500) * 0.5;
        }
      
        // --- Шаблоны стрельбы в зависимости от стадии ---
        this.shootCooldown -= deltaTime;
        if (this.shootCooldown <= 0) {
          if (stage === 1) {
            const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
            for (let offset of [-0.1, 0, 0.1]) {
              let b = new Bullet(this.x, this.y, baseAngle + offset);
              b.fromBoss = true;
              b.speed = 5 * scaleFactor;
              b.damage = 20;
              bullets.push(b);
            }
            this.shootCooldown = 3000;
          } else if (stage === 2) {
            const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
            for (let offset of [-0.2, -0.1, 0, 0.1, 0.2]) {
              let b = new Bullet(this.x, this.y, baseAngle + offset);
              b.fromBoss = true;
              b.speed = 6 * scaleFactor;
              b.damage = 25;
              bullets.push(b);
            }
            this.shootCooldown = 2000;
          } else if (stage === 3) {
            const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
            for (let offset of [-0.1, 0, 0.1]) {
              let b = new Bullet(this.x, this.y, baseAngle + offset);
              b.fromBoss = true;
              b.speed = 6 * scaleFactor;
              b.damage = 30;
              b.homing = true;
              bullets.push(b);
            }
            this.shootCooldown = 1000;
          } else if (stage === 4) {
            for (let i = 0; i < 8; i++) {
              let angle = i * (Math.PI * 2 / 8);
              let b = new Bullet(this.x, this.y, angle);
              b.fromBoss = true;
              b.speed = 7 * scaleFactor;
              b.damage = 20;
              bullets.push(b);
            }
            this.shootCooldown = 500;
          } else if (stage === 5) {
            const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
            for (let offset of [-0.3, -0.15, 0, 0.15, 0.3]) {
              let b = new Bullet(this.x, this.y, baseAngle + offset);
              b.fromBoss = true;
              b.speed = 8 * scaleFactor;
              b.damage = 35;
              bullets.push(b);
            }
            this.shootCooldown = 150;
          }
        }
      }
      
      draw() {
        // --- Определяем цвет босса в зависимости от оставшегося HP ---
        let bossColor = "#ff0"; // по умолчанию – желтый
        if (this.hp < this.maxHP * 0.7) bossColor = "#ff6600"; // оранжевый при потере 30% HP
        if (this.hp < this.maxHP * 0.4) bossColor = "#f00";    // красный при критически малом HP

        // --- Отрисовка босса с выбранной формой ---
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = bossColor;
        ctx.strokeStyle = bossColor;
        ctx.lineWidth = 2;

        // Выбираем форму отрисовки в зависимости от титула (tier)
        switch (this.tier) {
          case "Emperor":
            // Звёздная фигура – символ величия
            drawStar(ctx, this.radius, 8, 0.5);
            break;
          case "Champion":
            // Многоугольник (например, с 8 сторонами)
            drawPolygon(ctx, 8, this.radius);
            break;
          case "Elite":
            // Спайковый круг с большим числом "шипов"
            drawSpikyCircle(ctx, this.radius, 12, 0.3);
            break;
          case "Easy":
          default:
            // Стандартный круг
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
        
        // Отрисовка полосы HP босса.
        // Если босс один – стандартное положение (y = 20).
        // Если боссов несколько – для босса с индексом i полоса смещается на i*30 пикселей вниз.

        // Отрисовка полосы HP босса
        // Получаем индекс босса в массиве bosses
        let index = bosses.indexOf(this);
        let barWidth, barHeight, barX, barY;
        barHeight = 20;        // высота полосы (в пикселях)
        const spacing = 47;    // вертикальное расстояние между полосами
        const gap = 10;        // горизонтальный зазор между столбцами

        // Если боссов 5 или больше – делим на два столбца
        if (bosses.length >= 5) {
          barWidth = (300 / 2) *scaleFactor; // ширина полосы уменьшается вдвое
          if (index < 4) {
            // Для босса с индексами 0–3 – левый столбец
            barX = width / 2 - (barWidth + gap);
            barY = 20 + index * spacing;
          } else {
            // Для босса с индексами 4–7 – правый столбец
            barX = width / 2 + gap;
            barY = 20 + (index - 4) * spacing;
          }
        } else {
          // Если боссов 4 или меньше – рисуем по центру
          barWidth = 300;
          barX = width / 2 - barWidth * uiScale / 2;
          barY = 20 + index * spacing;
        }
        // Отрисовка фона полосы
        ctx.fillStyle = "#222";
        ctx.fillRect(barX, barY * uiScale, barWidth * uiScale, barHeight * uiScale);
        // Отрисовка заполненной части (с учетом оставшегося здоровья)
        ctx.fillStyle = bossColor;
        const hpWidth = barWidth * (this.hp / this.maxHP);
        ctx.fillRect(barX, barY * uiScale, hpWidth * uiScale, barHeight * uiScale);
        // Рамка полосы
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(barX, barY * uiScale, barWidth * uiScale, barHeight * uiScale);
        
        /*
        let index = bosses.indexOf(this);
        const barWidth = 300, barHeight = 20;
        let barY = 20 + index * 47;
        
        ctx.fillStyle = "#222";
        ctx.fillRect(width / 2 - (barWidth * uiScale) / 2, barY * uiScale, barWidth * uiScale, barHeight * uiScale);
        ctx.fillStyle = bossColor;
        const hpWidth = barWidth * (this.hp / this.maxHP);
        ctx.fillRect(width / 2 - (barWidth * uiScale) / 2, barY * uiScale, hpWidth * uiScale, barHeight * uiScale);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(width / 2 - (barWidth * uiScale) / 2, barY * uiScale, barWidth * uiScale, barHeight * uiScale);

        // Отрисовка имени босса над полосой здоровья.
        // Вычисляем горизонтальный центр полосы:
        let resultWidth = (bosses.length >= 5) ? barWidth : (width / 2)*uiScale;
        const nameX = barX * uiScale + resultWidth;
        //const nameX = barX * uiScale + resultWidth * uiScale / 2;
        const nameY = (barY - 5) * uiScale; // имя немного выше полосы
        ctx.save();
        ctx.fillStyle = "#fff";
        ctx.font = (18 * uiScale) + "px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.tier + " Boss", nameX, nameY);
        ctx.restore();
        */
        
        ctx.save();
        ctx.fillStyle = "#fff";
        ctx.font = (18 * uiScale) + "px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.tier + " Boss", width / 2, (barY - 5) * uiScale);
        ctx.restore();
        
        
      }
    }

    // --- Collectible ---
    class Collectible {
      constructor(x,y) {
        this.x = x;
        this.y = y;
        this.radius = 8 * scaleFactor;
        this.angle = Math.random()*Math.PI*2;
      }
      update(deltaTime) {
        // *** Измененный механизм притягивания коллекционных предметов ***
        if (
          player &&
          player.activePowerUps.scoreMagnet &&
          player.activePowerUps.scoreMagnet.duration > 0
        ) {
          let dx = player.x - this.x;
          let dy = player.y - this.y;
          let dist = Math.hypot(dx, dy);
    
          // Параметры притяжения: базовая дистанция и прирост дистанции с каждым стэком
          let baseAttractionRange = 200 * scaleFactor; // базовая дистанция притяжения (в пикселях)
          let additionalRangePerStack = 100 * scaleFactor; // прибавка к дистанции за каждый дополнительный стэк
          // Вычисляем общую дистанцию притяжения в зависимости от количества стэков
          let attractionRange =
            baseAttractionRange +
            additionalRangePerStack * (player.activePowerUps.scoreMagnet.stacks - 1);
    
          // Если объект находится в пределах дистанции притяжения, притягиваем его
          if (dist < attractionRange) {
            let baseAttractSpeed = 1 * scaleFactor; // базовая скорость притяжения
            // Увеличиваем скорость притяжения пропорционально количеству стэков
            let attractSpeed = baseAttractSpeed * player.activePowerUps.scoreMagnet.stacks * deltaTime;
            this.x += (dx / dist) * attractSpeed;
            this.y += (dy / dist) * attractSpeed;
          }
        }
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        let r = this.radius;
        ctx.beginPath();
        // Начинаем с верхней центральной точки сердца
        ctx.moveTo(0, -r / 2);
        // Правая половина сердца
        ctx.bezierCurveTo(r, -r * 1.3, r * 1.3, r / 3, 0, r * 1.5);
        // Левая половина сердца
        ctx.bezierCurveTo(-r * 1.3, r / 3, -r, -r * 1.3, 0, -r / 2);
        ctx.closePath();
        ctx.fillStyle = "#0f0"; // зеленый цвет для обычного collectible
        ctx.shadowColor = "#0f0";
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.restore();
      }
    }
    // --- SpecialCollectible: красный круг с зелёным контуром, дающий двойное вознаграждение ---
    class SpecialCollectible {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 8 * scaleFactor; // тот же размер, что и у обычного
        this.angle = Math.random() * Math.PI * 2;
      }
      update(deltaTime) {
        // *** Измененный механизм притягивания коллекционных предметов ***
        if (
          player &&
          player.activePowerUps.scoreMagnet &&
          player.activePowerUps.scoreMagnet.duration > 0
        ) {
          let dx = player.x - this.x;
          let dy = player.y - this.y;
          let dist = Math.hypot(dx, dy);
    
          // Параметры притяжения: базовая дистанция и прирост дистанции с каждым стэком
          let baseAttractionRange = 200 * scaleFactor; // базовая дистанция притяжения (в пикселях)
          let additionalRangePerStack = 100 * scaleFactor; // прибавка к дистанции за каждый дополнительный стэк
          // Вычисляем общую дистанцию притяжения в зависимости от количества стэков
          let attractionRange =
            baseAttractionRange +
            additionalRangePerStack * (player.activePowerUps.scoreMagnet.stacks - 1);
    
          // Если объект находится в пределах дистанции притяжения, притягиваем его
          if (dist < attractionRange) {
            let baseAttractSpeed = 1 * scaleFactor; // базовая скорость притяжения
            // Увеличиваем скорость притяжения пропорционально количеству стэков
            let attractSpeed = baseAttractSpeed * player.activePowerUps.scoreMagnet.stacks * deltaTime;
            this.x += (dx / dist) * attractSpeed;
            this.y += (dy / dist) * attractSpeed;
          }
        }
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        let r = this.radius;
        ctx.beginPath();
        ctx.moveTo(0, -r / 2);
        ctx.bezierCurveTo(r, -r * 1.3, r * 1.3, r / 3, 0, r * 1.5);
        ctx.bezierCurveTo(-r * 1.3, r / 3, -r, -r * 1.3, 0, -r / 2);
        ctx.closePath();
        ctx.fillStyle = "#f00"; // красный цвет для специального collectible
        ctx.shadowColor = "#0f0";
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.lineWidth = 3 * scaleFactor;
        ctx.strokeStyle = "#0f0";
        ctx.stroke();
        ctx.restore();
      }
    }


    // --- Particle ---
    class Particle {
      constructor(x,y,color) {
        this.x = x;
        this.y = y;
        this.radius = (Math.random()*3 + 2) * scaleFactor;
        this.angle = Math.random()*Math.PI*2;
        this.speed = (Math.random()*2 + 1) * scaleFactor;
        this.life = 100;
        this.color = color;
      }
      update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life -= 2;
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = Math.max(this.life/100,0);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    // =================== Global Objects & Arrays ===================
    // (Массивы и переменные уже объявлены выше)

    // =================== Utility Function ===================
    function circleCollision(a, b) {
      if (!a || !b) return false;
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx, dy) < a.radius + b.radius;
    }
    // Функция для вычисления расстояния от точки (px,py) до линии, задаваемой двумя точками (x1,y1) и (x2,y2)
    function distancePointToLine(px, py, x1, y1, x2, y2) {
      let A = px - x1;
      let B = py - y1;
      let C = x2 - x1;
      let D = y2 - y1;

      let dot = A * C + B * D;
      let len_sq = C * C + D * D;
      let param = (len_sq !== 0) ? (dot / len_sq) : -1;

      let xx, yy;
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }
      let dx = px - xx;
      let dy = py - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }


    // =================== Spawning Functions ===================
    function spawnEnemy() {
      let x, y;

      const effectiveHeight = (isMobile && window.innerHeight > window.innerWidth)
          ? height - getBottomCropHeight()
          : height;

      const edge = Math.floor(Math.random() * 4);
      if (edge === 0) { x = Math.random() * width; y = -30; }
      else if (edge === 1) { x = width + 30; y = Math.random() * effectiveHeight; }
      else if (edge === 2) { x = Math.random() * width; y = effectiveHeight + 30; }
      else { x = -30; y = Math.random() * effectiveHeight; }
      let r = Math.random();
      let type = "basic";
      if(r < 0.35)          type = "basic";
      else if(r < 0.50)     type = "elite";
      else if(r < 0.60)     type = "freeze";
      else if(r < 0.70)     type = "shooter";
      else if(r < 0.75)     type = "sharpshooter";
      else if(r < 0.80)     type = "parasite";
      else if(r < 0.85)     type = "emp";
      else if(r < 0.92)     type = "exploder";
      else                   type = "splitter";
      enemies.push(new Enemy(x, y, type));
    }
    function spawnCollectible(x,y) {
      // Спавнить collectible только с вероятностью 50%
      if (Math.random() < 0.5) {
        collectibles.push(new Collectible(x, y));
      }
    }
    /******************************************
     **  BUTTON P: SPAWN 2 BOSSES (LEVEL 7)    **
     ******************************************/
    function spawnTwoBosses() {
      let bossCount = Math.pow(2, Math.floor((currentLevel - 1) / 5));
      bossCount = Math.min(bossCount, 8);
      if(bossCount>8)
      {
        bossCount=8;
      }
      bossCount=8; // -----------------   Временно
          
      // Если один босс – стандартный спавн
      if (bossCount === 1) {
        bosses.push(new Boss());
      } else {
        // Вычисляем базовый радиус, который уже учитывает уменьшение при currentLevel > 5
        let baseRadius = 60 * scaleFactor;
        if (currentLevel > 5) baseRadius *= 0.5;
        // Для равномерного расположения вычисляем радиус окружности так,
        // чтобы расстояние между центрами соседних боссов было равно 2 * baseRadius.
        let spawnCircleRadius = baseRadius / Math.sin(Math.PI / bossCount);
        
        // Центр спавна (можно изменить по желанию)
        let centerX = width / 2;
        let centerY = 100;
        
        for (let i = 0; i < bossCount; i++) {
          let angle = (2 * Math.PI * i) / bossCount;
          let bossX = centerX + spawnCircleRadius * Math.cos(angle);
          let bossY = centerY + spawnCircleRadius * Math.sin(angle);
          bosses.push(new Boss(bossX, bossY));
        }
      }
    }
    function givePlayerMagnetEffect() {
      applyPowerUp("Damage Boost");
      applyPowerUp("Friend");
      applyPowerUp("Health Boost");
      applyPowerUp("Critical Strike");
      applyPowerUp("Freeze Blast");
      applyPowerUp("Shield");
      applyPowerUp("Bomb");
      applyPowerUp("Rapid Fire");
      /*
      "Double Shot", "Triple Shot", "Rapid Fire", "Shield", "Speed Boost",
      "Damage Boost", "Piercing", "Homing", "Bomb", "Freeze Blast",
      "Reflective", "Life Steal", "EMP Blast", "Critical Strike", "Overcharge",
      "Scatter Shot",
      "Health Boost", "Restore Health", "Magnet", "Friend"
      */
    }
    function addFriendPowerUp() {
      if (!player) return;
      
      const key = "friend"; // Ключ для эффекта Friend в объекте activePowerUps
      // Используем длительность, заданную в словаре powerUpDurations (или 40000 мс по умолчанию)
      const friendDuration = powerUpDurations["Friend"] || 40000;
      
      // Если эффекта ещё нет (или его длительность равна 0)
      if (player.activePowerUps[key].duration <= 0) {
        player.activePowerUps[key].duration = friendDuration;
        player.activePowerUps[key].stacks = 1;
      } else {
        // Если эффект уже активен – увеличиваем длительность и число стэков
        player.activePowerUps[key].duration += friendDuration;
        player.activePowerUps[key].stacks += 1;
      }
      
      console.log(`Friend power-up applied. Current stacks: ${player.activePowerUps[key].stacks}`);
    }

    // =================== Power‑Up Mapping ===================
    // This mapping ensures that "Double Shot" becomes the property "doubleShot" etc.
    const powerUpMap = {
      "Double Shot": "doubleShot",
      "Triple Shot": "tripleShot",
      "Rapid Fire": "rapidFire",
      "Shield": "shield",
      "Speed Boost": "speedBoost",
      "Damage Boost": "damageBoost",
      "Piercing": "piercing",
      "Homing": "homing",
      "Bomb": "bomb",
      "Freeze Blast": "freezeBlast",
      "Reflective": "reflective",
      "Life Steal": "lifeSteal",
      "EMP Blast": "empBlast",
      "Critical Strike": "criticalStrike",
      "Overcharge": "overcharge",
      "Scatter Shot": "scatterShot",
      "Health Boost": "healthBoost",          // *** NEW: временное увеличение здоровья (увеличивает maxHP на +20) ***
      "Restore Health": "healthRestore",       // *** NEW: мгновенное Restore Health
      "Magnet": "scoreMagnet",            // *** NEW: притягивает коллекционные объекты (25с)
      "Friend": "friend",
      "Neon Overdrive": "neonOverdrive",   // ← новая запись
      "Power Meter Boost": "powerMeterBoost",
      "Bullet Time": "bulletTime"
    };
    
    // =================== Temporary Power‑Up Pool & Durations ===================
    const powerUpPool = [
      "Double Shot", "Triple Shot", "Rapid Fire", "Shield", "Speed Boost",
      "Damage Boost", "Piercing", "Homing", "Bomb", "Freeze Blast",
      "Reflective", "Life Steal", "EMP Blast", "Critical Strike", "Overcharge",
      "Scatter Shot", "Health Boost", "Restore Health", "Magnet", "Friend", "Neon Overdrive", "Power Meter Boost", "Bullet Time"
    ];
    const powerUpDurations = {
      "Reflective": 10000, // 10 секунд для Reflective
      "Triple Shot": 28000,
      "Double Shot": 35000,
      "Shield": 25000,
      "EMP Blast": 40000,
      "Health Boost": 25000,         // *** NEW: 25 секунд
      "Magnet": 25000,          // *** NEW: 25 секунд
      "Friend": 40000,
      "Neon Overdrive": 10000,
      "Power Meter Boost": 15000, // 15 секунд
      "Bullet Time": 15000  // 15 секунд   
    };

    // =================== Temporary Power‑Up Selection ===================
    function showPowerUpMenu() {
      gameState = "powerup";
      const overlay = document.getElementById("overlay");
      const case_to_much_bullets = (player.activePowerUps.tripleShot.stacks >= 2 || player.activePowerUps.doubleShot.stacks >= 3 || player.activePowerUps.scatterShot.stacks >= 3);
      const case_to_much_bullets2 = (player.activePowerUps.tripleShot.stacks >= 1 && player.activePowerUps.doubleShot.stacks >= 1 || player.activePowerUps.scatterShot.stacks >= 1);
      const case_to_much_magnet = (player.activePowerUps.scoreMagnet.stacks >= 3)
      const case_to_much_bullet_time2 = (player.activePowerUps.bulletTime.stacks >= 2)
      const case_to_much_bullet_time = (player.activePowerUps.bulletTime.stacks >= 2)
      const case_to_much_powerMeterBoost = (player.activePowerUps.powerMeterBoost.stacks >= 4) && currentLevel<30
      const case_to_much_neonOverDrive = (player.activePowerUps.neonOverdrive.stacks >= 2)
      // Фильтруем pool: исключаем усиления, у которых игрок уже достиг максимума стаков
      const availablePool = powerUpPool.filter(choice => {
        if (!player) return true; // на всякий случай
        if (choice === "Triple Shot" && case_to_much_bullets) return false;
        if (choice === "Double Shot" && case_to_much_bullets) return false;
        if (choice === "Scatter Shot" && case_to_much_bullets) return false;
        if (choice === "Magnet" && case_to_much_magnet) return false;
        if (choice === "Reflective" && case_to_much_bullet_time) return false;
        if (choice === "Bullet Time" && case_to_much_bullet_time2) return false;
        if (choice === "Rapid Fire" && (case_to_much_bullets||case_to_much_bullets2)) return false;
        if (choice === "Power Meter Boost" && case_to_much_powerMeterBoost) return false;
        if (choice === "Neon Overdrive" && case_to_much_neonOverDrive) return false;
        return true;
      });

      let options = [];
      while (options.length < 3 && availablePool.length > 0) {
        let randomIndex = Math.floor(Math.random() * availablePool.length);
        let choice = availablePool[randomIndex];
        if (!options.includes(choice)) {
          options.push(choice);
        }
      }

      // Если по каким-то причинам список пустой – можно сразу возобновить игру
      if(options.length === 0) {
        resumeGame();
        return;
      }

      overlay.innerHTML = `<h1>Power-Up Ready!</h1>
        <p>Choose one temporary power-up:</p>
        <div>
          ${options.map((option, index) => `<button class="button" id="pu${index+1}">${option}</button>`).join("")}
        </div>`;
      overlay.classList.remove("hidden");
      options.forEach((option, index) => {
        document.getElementById("pu" + (index + 1))
          .addEventListener("click", () => applyPowerUp(option));
      });
    }
    // =================== Функция применения усиления ===================
    function applyPowerUp(choice) {
      // *** NEW: При выборе "Restore Health" – мгновенное восстановление 30 HP (учитывая текущий maxHP) ***
      const key = powerUpMap[choice];
      if (choice === "Restore Health") {
          // Пример мгновенного эффекта
          player.currentHP = Math.min(player.maxHP, player.currentHP + 30);
          powerMeter = Math.max(0, powerMeter - getPowerMeterMax());
          resumeGame();
          return;
      } else if (choice === "Health Boost") {
          // Изменено: теперь Health Boost даёт бонус +50 к maxHP и +50 к текущему здоровью
          let bonusHealth = 50;
          const timePerStack = powerUpDurations[choice] || 30000;
          if (player.activePowerUps[key].duration <= 0) {
            // если эффекта не было
            player.activePowerUps[key].duration = timePerStack;
            player.activePowerUps[key].bonus = 50; // например, +50 к макс.хп
          } else {
            // если эффект активен
            player.activePowerUps[key].duration += timePerStack;
            // бонус накапливаем, если хотите, чтобы каждый стэк HealthBoost ещё и +50 HP давал
            player.activePowerUps[key].bonus += 50; 
          }
          // сразу же увеличим HP игрока
          player.maxHP += 50;
          player.currentHP += 50;
          powerMeter = 0;
          resumeGame();
          return;
      } else {
        if (key && player) {
          const timePerStack = powerUpDurations[choice] || 30000;

          // если эффект не активен (duration ≤ 0)
          if (player.activePowerUps[key].duration <= 0) {
            player.activePowerUps[key].duration = timePerStack;
          } else {
            // увеличиваем время
            player.activePowerUps[key].duration += timePerStack;
          }
        }
      }
      powerMeter = 0;
      resumeGame();
    }

    // =================== Permanent Upgrade (Show menu) ===================

    function showHTMLMenu(version){
      const overlay = document.getElementById("overlay");
      // Определяем список возможных перманентных улучшений с их весами (относительные вероятности)
      const upgrades = [
        { id: "upgDamage", name: "Damage Up", weight: 40 },
        { id: "upgSpeed", name: "Speed Up", weight: 30 },
        { id: "upgFireRate", name: "Fire Rate Up", weight: 20 },
        { id: "upgHealth", name: "Health Up", weight: 10 }
      ];
      // Выбираем 3 уникальных улучшения с учётом их весов
      const chosenUpgrades = [];
      const availableUpgrades = [...upgrades]; // создаём копию массива, чтобы не менять исходный список
      for (let i = 0; i < 3; i++) {
        // Вычисляем суммарный вес для оставшихся улучшений
        const totalWeight = availableUpgrades.reduce((sum, upg) => sum + upg.weight, 0);
        let random = Math.random() * totalWeight;
        let selectedIndex = 0;
        // Ищем случайное улучшение согласно весам
        for (let j = 0; j < availableUpgrades.length; j++) {
          random -= availableUpgrades[j].weight;
          if (random < 0) {
            selectedIndex = j;
            break;
          }
        }
        chosenUpgrades.push(availableUpgrades[selectedIndex]);
        availableUpgrades.splice(selectedIndex, 1); // удаляем выбранное, чтобы избежать повторения
      }
      // Формируем HTML с кнопками для выбранных улучшений
      const buttonsHTML = chosenUpgrades
        .map(upg => `<button class="button" id="${upg.id}">${upg.name}</button>`)
        .join("");
        if(version===1){ //resumeGame()
          overlay.innerHTML = `<h1>YOU ARE MONSTER!!!</h1>
          <p>Choose your permanent upgrade:</p>
          <div>${buttonsHTML}</div>`
        } else { // nextLevel()
          overlay.innerHTML = `<h1>Level ${currentLevel} Complete!</h1>
          <p>Choose your permanent upgrade:</p>
          <div>${buttonsHTML}</div>`
        } 
      ;
      overlay.classList.remove("hidden");
      // Назначаем обработчики событий для каждой кнопки
      chosenUpgrades.forEach(upg => {
        document.getElementById(upg.id).addEventListener("click", () => {
          switch (upg.name) {
            case "Damage Up":
              permanentUpgrades.damage += 0.5;
              break;
            case "Speed Up":
              permanentUpgrades.speed += 0.2;
              break;
            case "Fire Rate Up":
              permanentUpgrades.fireRate += 0.5;
              break;
            case "Health Up":
              permanentUpgrades.health += 15;
              if (player) {
                player.maxHP += 15;
                player.currentHP += 15;
              }
              break;
          }
          version===1? resumeGame(): nextLevel();
        });
      });
    }

    // =================== Permanent Upgrade ===================

    function showPermanentUpgradeMenu() {
      gameState = "transition";
      showHTMLMenu(1);
    }

    // =================== Permanent Upgrade (Level Transition) ===================

    function showTransitionMenu() {
      gameState = "transition";
      showHTMLMenu(2);
    }

    function nextLevel() {
      currentLevel++;
      if (currentLevel > 5) {
        levelDuration = Math.min(levelDuration + 2000, maxLevelDuration);
      }
      levelTimer = levelDuration;
      enemySpawnTimer = 0;
      // Очищаем массивы
      enemies.length = 0;
      bullets.length = 0;
      //collectibles.length = 0;   //Hard-mode
      particles.length = 0;
      bosses.length = 0;
      resumeGame();
    }

    // =================== Pause & Game Over ===================
    function pauseGame() {
      if(gameState === "playing") {
        gameState = "pause";
        const overlay = document.getElementById("overlay");
        overlay.innerHTML = `<h1>Paused</h1>
          <div>
            <button class="button" id="resumeBtn">Resume</button>
            <button class="button" id="restartBtn">Restart</button>
            <button class="button" id="menuBtn">Main Menu</button>
          </div>`;
        overlay.classList.remove("hidden");
        document.getElementById("resumeBtn").addEventListener("click", resumeGame);
        document.getElementById("restartBtn").addEventListener("click", restartGame);
        document.getElementById("menuBtn").addEventListener("click", mainMenu);
      }
    }
    function resumeGame() {
      if(gameState !== "playing") {
        gameState = "playing";
        document.getElementById("overlay").classList.add("hidden");
      }
    }
    function restartGame() {
      score = 0;
      currentLevel = 1;
      levelDuration = 30000;
      comboCounter = 0;
      levelTimer = levelDuration;
      permanentUpgrades.damage = 1;
      permanentUpgrades.speed = 1;
      permanentUpgrades.fireRate = 1;
      permanentUpgrades.health = 0;   // *** NEW: сброс здоровья ***
      powerMeter = 0;
      enemySpawnTimer = 0;
      fireCooldown = 0;
      enemies.length = 0;
      bullets.length = 0;
      collectibles.length = 0;
      particles.length = 0;
      bosses.length = 0;
      player = new Player(width/2, height/2);
      player.maxHP = 100 + permanentUpgrades.health;  // *** NEW: учитываем перманентное здоровье
      player.currentHP = player.maxHP;
      resumeGame();
    }
    function mainMenu() {
      gameState = "menu";
      document.getElementById("overlay").innerHTML = `<h1 class="cyan_color" >Neon Nexus: Ultimate Gauntlet</h1>
      <p id="overlayText">Move with WASD, aim with your mouse (or use on‑screen joysticks on mobile),</br> and auto‑fire is enabled.<br>
         Fill your power meter by defeating enemies and choose temporary power‑ups.<br>
         Survive waves and defeat bosses to earn permanent upgrades!</p>
      <p id="startHint">${isMobile ? "Tap anywhere" : "Press SPACE"} to begin</p>
      <p class="cyan_color" >The game was made by the developers</br>of the game "Fearful Obscured Grounds"</p>`;
      document.getElementById("overlay").classList.remove("hidden");
    }
    function showGameOver() {
      gameState = "gameover";
      const overlay = document.getElementById("overlay");
      overlay.innerHTML = `<h1 class="cyan_color" >Game Over</h1>
        <p>Your Score: ${Math.floor(score)}</p>
        <p>Enter your name: <input type="text" id="playerName" placeholder="Your Name"></p>
        <button class="button" id="saveScoreBtn">Save Score</button>
        <button class="button" id="scoreboardBtn">ScoreBoard</button>
        <p>${isMobile ? "Tap anywhere" : "Press SPACE"} to restart</p>
        <p class="cyan_color" >The game was made by the developers</br> of the game "Fearful Obscured Grounds"</p>`;
      overlay.classList.remove("hidden");

      document.getElementById("saveScoreBtn").addEventListener("click", async () => {
        const name = document.getElementById("playerName").value || "Anonymous";
        await appendScore(name, Math.floor(score));
      });
      document.getElementById("scoreboardBtn").addEventListener("click", () => {
        window.location.href = "scoreboard.html";
      });
    }

    // Функция для записи (дописывания) результатов в файл с использованием File System Access API
    async function appendScore(name, score) {
      if (!window.showOpenFilePicker) {
        alert("Ваш браузер не поддерживает File System Access API.");
        return;
      }
      try {
        // Предлагаем пользователю выбрать существующий файл (например, scores.txt)
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'Text Files',
            accept: { 'text/plain': ['.txt'] }
          }]
        });
        // Читаем существующие данные
        const file = await handle.getFile();
        let contents = await file.text();
        // Добавляем новую запись (имя и счёт, разделённые запятой)
        contents += name + "," + score + "\n";
        // Открываем файл для записи и перезаписываем его содержимое
        const writable = await handle.createWritable();
        await writable.write(contents);
        await writable.close();
        alert("Score saved!");
      } catch (e) {
        console.error(e);
      }
    }
    // =================== Main Game Loop ===================
    let lastTime = performance.now();
    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      update(deltaTime);
      draw();
      requestAnimationFrame(gameLoop);
    }

    // =================== Main Update Function ===================
    function update(deltaTime) {
      if(gameState !== "playing") return;
      score += deltaTime * 0.05;
      // Спавн босса (или боссов) после истечения таймера
      if (bosses.length === 0) {
        levelTimer -= deltaTime;
        if (levelTimer <= 0) {
          // Определяем количество боссов:
          // Если уровень <= 5 – один босс, а дальше удачи
          let bossCount = Math.pow(2, Math.floor((currentLevel - 1) / 5));
          bossCount = Math.min(bossCount, 8); // Ограничиваем максимум 8 боссов
          if(bossCount>8)
          {
            bossCount=8;
          }
         
          // Если один босс – стандартный спавн
          if (bossCount === 1) {
            bosses.push(new Boss());
          } else {
            // Вычисляем базовый радиус, который уже учитывает уменьшение при currentLevel > 5
            let baseRadius = 60 * scaleFactor;
            if (currentLevel > 5) baseRadius *= 0.5;
            // Для равномерного расположения вычисляем радиус окружности так,
            // чтобы расстояние между центрами соседних боссов было равно 2 * baseRadius.
            let spawnCircleRadius = baseRadius / Math.sin(Math.PI / bossCount);
            
            // Центр спавна (можно изменить по желанию)
            let centerX = width / 2;
            let centerY = 100;
            
            for (let i = 0; i < bossCount; i++) {
              let angle = (2 * Math.PI * i) / bossCount;
              let bossX = centerX + spawnCircleRadius * Math.cos(angle);
              let bossY = centerY + spawnCircleRadius * Math.sin(angle);
              bosses.push(new Boss(bossX, bossY));
            }
          }
        }
      }
      if(player) {
        if(player.shootingDisabled > 0) player.shootingDisabled -= deltaTime;
        player.update(deltaTime);
      }
      // Adjust fire rate (rapid fire and EMP effects)
      let effectiveFireRate = BASE_FIRE_RATE / permanentUpgrades.fireRate;
      if(player.activePowerUps.rapidFire.duration > 0) effectiveFireRate /= 2;
      if(player.empSlowed > 0) {
        effectiveFireRate *= 1.5;
        player.empSlowed -= deltaTime;
      }
      // Изменённая логика автострельбы с учётом стэков усилений
      if (player && player.shootingDisabled <= 0&& !(player.activePowerUps.neonOverdrive && player.activePowerUps.neonOverdrive.duration > 0)) {
        fireCooldown -= deltaTime;
        if (fireCooldown <= 0) {
          fireCooldown = effectiveFireRate;
          const bulletOffset = player.radius;
          const bx = player.x + Math.cos(player.angle) * bulletOffset;
          const by = player.y + Math.sin(player.angle) * bulletOffset;
          // Вычисляем коэффициент урона: damageBoost увеличивает урон на +1 за каждый стэк
          let dmgFactor = 1;
          if (player.activePowerUps.damageBoost.duration > 0) {
            dmgFactor = 1 + player.activePowerUps.damageBoost.stacks;
          }
          // Новая логика для подсчёта количества пуль:
          // Базово 1 пуля, но если активны усиления Double Shot и/или Triple Shot – применяем мультипликативный эффект
          let bulletCount = 1;
          let totalSpread = 0;
          // Если Double Shot активен, умножаем количество пуль на 2 для каждого стэка
          if (player.activePowerUps.doubleShot.duration > 0) {
            bulletCount *= Math.pow(2, player.activePowerUps.doubleShot.stacks);
            totalSpread += 0.1 * player.activePowerUps.doubleShot.stacks;
          }
          // Если Triple Shot активен, умножаем количество пуль на 3 для каждого стэка
          if (player.activePowerUps.tripleShot.duration > 0) {
            bulletCount *= Math.pow(3, player.activePowerUps.tripleShot.stacks);
            totalSpread += 0.15 * player.activePowerUps.tripleShot.stacks;
          }
          // Scatter Shot теперь добавляет +4 пули за каждый стэк
          if (player.activePowerUps.scatterShot.duration > 0) {
            bulletCount += 4 * player.activePowerUps.scatterShot.stacks;
            totalSpread += 0.3 * player.activePowerUps.scatterShot.stacks;
          }
          if (player.activePowerUps.bulletTime.duration > 0) {
            // Если исходное число пуль ≤ 8, прибавляем 8; иначе ставим 16 (максимум)
            bulletCount = (bulletCount <= 10) ? (bulletCount + 10) : 10 * player.activePowerUps.bulletTime.stacks;
            // При этом задаём разброс на 360 градусов (2π радиан)
            totalSpread = Math.PI * 2;
          }
          // Overcharge теперь не влияет на число пуль, а ускоряет их – поэтому здесь не модифицируем bulletCount
          let newBullets = [];
          if (bulletCount > 1) {
            let startAngle = player.angle - totalSpread / 2;
            let angleStep = bulletCount > 1 ? totalSpread / (bulletCount - 1) : 0;
            for (let i = 0; i < bulletCount; i++) {
              let angle = startAngle + i * angleStep;
              let b = new Bullet(bx, by, angle, dmgFactor);
              // Применяем остальные свойства пули в зависимости от активных усилений
              if (player.activePowerUps.piercing.duration > 0) {
                b.piercing = true;
                b.piercingCount = 3 * player.activePowerUps.piercing.stacks;
              }
              if (player.activePowerUps.homing.duration > 0) {
                b.homing = true;
              }
              if (player.activePowerUps.bomb.duration > 0) {
                b.bomb = true;
              }
              if (player.activePowerUps.freezeBlast.duration > 0) {
                b.freezeBlast = true;
              }
              if (player.activePowerUps.empBlast.duration > 0) {
                b.empBlast = true;
              }
              if (player.activePowerUps.reflective.duration > 0) {
                b.reflective = true;
              }
              if (player.activePowerUps.criticalStrike.duration > 0) {
                b.critical = true;
                if (Math.random() < 0.2 * player.activePowerUps.criticalStrike.stacks) {
                  if (player.activePowerUps.criticalStrike.stacks>3)
                  {
                    b.damage *= 3 + player.activePowerUps.criticalStrike.stacks-3;
                  }else{
                    b.damage *= 3;
                  }
                }
              }
              if (player.activePowerUps.lifeSteal.duration > 0) {
                b.lifeSteal = true;
              }
              if (player.activePowerUps.overcharge.duration > 0) {
                  b.speed *= (1 + 0.5 * player.activePowerUps.overcharge.stacks);
              }
              newBullets.push(b);
            }
          } else {
            let b = new Bullet(bx, by, player.angle, dmgFactor);
            if (player.activePowerUps.piercing.duration > 0) {
              b.piercing = true;
              b.piercingCount = 3 * player.activePowerUps.piercing.stacks;
            }
            if (player.activePowerUps.homing.duration > 0) {
              b.homing = true;
            }
            if (player.activePowerUps.bomb.duration > 0) {
              b.bomb = true;
            }
            if (player.activePowerUps.freezeBlast.duration > 0) {
              b.freezeBlast = true;
            }
            if (player.activePowerUps.empBlast.duration > 0) {
              b.empBlast = true;
            }
            if (player.activePowerUps.reflective.duration > 0) {
              b.reflective = true;
            }
            if (player.activePowerUps.criticalStrike.duration > 0) {
              b.critical = true;
              if (Math.random() < 0.2 * player.activePowerUps.criticalStrike.stacks) {
                b.damage *= 2;
              }
            }
            if (player.activePowerUps.lifeSteal.duration > 0) {
              b.lifeSteal = true;
            }
            if (player.activePowerUps.overcharge.duration > 0) {
                b.speed *= (1 + 0.5 * player.activePowerUps.overcharge.stacks);
            }
            newBullets.push(b);
          }
          newBullets.forEach(b => bullets.push(b));
        }
      }

      // Обновляем пули
      const effectiveHeight = (isMobile && window.innerHeight > window.innerWidth)
          ? height - getBottomCropHeight()
          : height;
      for(let i = bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        b.update(deltaTime);
        if(!b.reflective && (b.x < -10 || b.x > width+10 || b.y < -10 || b.y > effectiveHeight+10)) {
          b.dead = true;
        }
      }
      // Если активен Neon Overdrive – стреляем лазером вместо обычных пуль
      if (player.activePowerUps.neonOverdrive.duration > 0) {
        // Определяем начало луча с учётом scaleFactor:
        let beamStartX = player.x + Math.cos(player.angle) * (player.radius * scaleFactor);
        let beamStartY = player.y + Math.sin(player.angle) * (player.radius * scaleFactor);
        
        // Вычисляем конец луча
        let beamLength = Math.sqrt(width * width + height * height);
        let beamEndX = beamStartX + Math.cos(player.angle) * beamLength;
        let beamEndY = beamStartY + Math.sin(player.angle) * beamLength;
        
        // Урон в секунду с учётом улучшений
        let beamDamage = 10 * permanentUpgrades.damage * player.activePowerUps.neonOverdrive.stacks;
        
        // Проверка коллизий с врагами
        enemies.forEach(enemy => {
            let dist = distancePointToLine(enemy.x, enemy.y, beamStartX, beamStartY, beamEndX, beamEndY);
            if (dist < enemy.radius) {
                enemy.hp -= beamDamage;
                // Эффект попадания
                if(enemy.hp <= 0) {
                  if(enemy.type === "exploder") {
                    // When an exploder dies, it explodes—damaging nearby enemies.
                    for(let k=0; k<enemies.length; k++){
                      const dx = enemy.x - enemy.x;
                      const dy = enemy.y - enemy.y;
                      if(Math.hypot(dx,dy) < 50) {
                        enemy.hp -= 5;
                      }
                    }
                  }
                  if(enemy.type === "splitter") {
                    // Splitter splits into two basic enemies when killed.
                    enemies.push(new Enemy(enemy.x, enemy.y, "basic"));
                    enemies.push(new Enemy(enemy.x, enemy.y, "basic"));
                  }
                  for(let k=0; k<20; k++){
                    particles.push(new Particle(enemy.x, enemy.y, enemy.color));
                  }
                  spawnCollectible(enemy.x, enemy.y);
                  score += (enemy.type==="elite")?200:100;
                  enemy.dead = true;
                  onEnemyKilled(enemy);
                }
                else{
                  for (let blood = 0; blood < 8; blood++) {
                    particles.push(new Particle(enemy.x, enemy.y, enemy.color));
                  }
                }
            }
        });
        
        // Проверка коллизий с боссами
        bosses.forEach(boss => {
            let dist = distancePointToLine(boss.x, boss.y, beamStartX, beamStartY, beamEndX, beamEndY);
            if (dist < boss.radius) {
                boss.hp -= beamDamage;
                for (let blood = 0; blood < 8; blood++) {
                  particles.push(new Particle(boss.x, boss.y, "#f00"));
                }
            }
        });

        // *** Новый блок: уничтожение пуль врагов при столкновении с лучом ***
        bullets.forEach(b => {
            // Рассматриваем только пули, выпущенные врагами или боссами
            if (b.fromEnemy || b.fromBoss) {
                let dist = distancePointToLine(b.x, b.y, beamStartX, beamStartY, beamEndX, beamEndY);
                // Если использовать для отрисовки луча lineWidth = 8*scaleFactor, то его "половина" равна 4*scaleFactor.
                // Добавляем также радиус пули для более корректного расчёта.
                if (dist < (b.radius + 4 * scaleFactor)) {
                    b.dead = true;
                    // Можно добавить эффекты уничтожения пули (например, вспышку или частицы)
                }
            }
        });
      }

      // Спавн врагов (если не идёт бой с боссом)
      if(bosses.length === 0) {
          // Уменьшаем таймер уровня (до спавна босса)
          levelTimer -= deltaTime;

          // Вычисляем отношение прошедшего времени (0 в начале, 1 в конце)
          let elapsedRatio = 1 - (levelTimer / levelDuration);
          // Здесь задаём динамический интервал спавна:
          // В начале (elapsedRatio ~ 0) интервал будет около 1500 мс,
          // а к концу (elapsedRatio ~ 1) – около 500 мс.
          let dynamicSpawnInterval = Math.max(500, 1500 - elapsedRatio * 1000);


        enemySpawnTimer += deltaTime;
        if(enemySpawnTimer > dynamicSpawnInterval) {
          enemySpawnTimer = 0;
          // Определяем число врагов для спавна, например, от 1 до 5 в зависимости от уровня:
          let spawnCount = Math.min(5, Math.floor(currentLevel / 2) + 1);
          for (let i = 0; i < spawnCount; i++) {
            spawnEnemy();
          }
        }
        enemySpawnInterval = Math.max(500, 1500 - score/10);
      }
      // Обновляем врагов
      for(let i = enemies.length-1; i>=0; i--) {
        enemies[i].update(deltaTime);
        if(circleCollision(enemies[i], player)) {
          // --- Изменено: если щит активен, урон от обычных врагов блокируется полностью ---
          if(player.activePowerUps.shield.duration > 0) {
            enemies[i].dead = true;
            onEnemyKilled(enemies[i]);
          } else {
            let damage = 20;
            if(enemies[i].type === "freeze") { player.frozenTime = 2000; damage = 10; }
            else if(enemies[i].type === "parasite") { player.shootingDisabled = 2000; damage = 10; }
            else if(enemies[i].type === "emp") { player.empSlowed = 2000; damage = 15; }
            player.currentHP -= damage;
            // --- Добавлено: отображение полученного урона красным цветом ---
            damageTexts.push({ x: player.x, y: player.y, damage: damage, alpha: 1, lifetime: 1000 });
            if(player.currentHP <= 0) { gameState = "gameover"; showGameOver(); }
            enemies[i].dead = true;
            onEnemyKilled(enemies[i]);
          }
        }
      }
      // Обновляем боссов
      for(let i = bosses.length - 1; i >= 0; i--) {
        bosses[i].update(deltaTime);
        // --- Изменено: при столкновении с боссом проверяем наличие щита.
        if(circleCollision(bosses[i], player)) {
          // Вычисляем вектор от босса к игроку
          let dx = player.x - bosses[i].x;
          let dy = player.y - bosses[i].y;
          let dist = Math.hypot(dx, dy);
          // Если расстояние оказалось нулевым (на всякий случай)
          if (dist === 0) { dx = 1; dy = 0; dist = 1; }
          // Определяем расстояние отбрасывания: 5 клеток
          let knockBackDistance = 5 * actualGridSize; // например, 5 * 50 = 250 пикселей
          // Сдвигаем позицию игрока по направлению от босса
          player.x += (dx / dist) * knockBackDistance;
          player.y += (dy / dist) * knockBackDistance;
          // (Опционально) Ограничиваем позицию игрока границами канвы:
          player.x = Math.max(player.radius, Math.min(width - player.radius, player.x));
          player.y = Math.max(player.radius, Math.min(effectiveHeight - player.radius, player.y));
          if (player.activePowerUps.shield.duration > 0) {
            // Если щит активен – уменьшаем его оставшееся время на 1 секунду (1000 мс)
            player.activePowerUps.shield.duration = Math.max(0, player.activePowerUps.shield.duration - 100);
            // Можно отобразить специальное сообщение об уменьшении времени щита:
            damageTexts.push({ x: player.x, y: player.y, damage: "Shield -0.1s", alpha: 1, lifetime: 1000 });
          } else {
            // Если щита нет – наносим обычный урон от босса (30 единиц)
            let bossDamage = 30;
            player.currentHP -= bossDamage;
            damageTexts.push({ x: player.x, y: player.y, damage: bossDamage, alpha: 1, lifetime: 1000 });
            if (player.currentHP <= 0) {
              gameState = "gameover";
              showGameOver();
            }
          }
        }
        if(bosses[i].hp <= 0) {
          score += 1000;
          bosses.splice(i, 1);
          if(bosses.length === 0) {
            showTransitionMenu();
          }
        }
      }
      // Обновляем коллекционные предметы
      for(let i = collectibles.length-1; i>=0; i--) {
        collectibles[i].update(deltaTime);
        if(circleCollision(collectibles[i], player)) {
          let addValue = 20;
          // Если собран специальный collectible, даем в 2 раза больше
          if (collectibles[i] instanceof SpecialCollectible) {
            addValue *= 2;
          }
          if (player.activePowerUps.powerMeterBoost && player.activePowerUps.powerMeterBoost.duration > 0) {
            addValue *= (1+player.activePowerUps.powerMeterBoost.stacks); 
          }
          powerMeter = Math.min(getPowerMeterMax(), powerMeter+addValue);
          collectibles.splice(i,1);
        }
      }
      // Спавним специальный collectible в случайном месте, если условия выполнены
      if (currentLevel >= 5 && bosses.length > 0) {
        specialCollectibleSpawnTimer += deltaTime;
        // Каждые 5000 мс (5 секунд) пробуем заспавнить специальный объект
        if (specialCollectibleSpawnTimer >= 1000) {
          spawnSpecialCollectibleRandom();
          specialCollectibleSpawnTimer = 0;
        }
      }
      // Обновляем частицы
      for(let i = particles.length-1; i>=0; i--) {
        particles[i].update();
        if(particles[i].life <= 0) { particles.splice(i,1); }
      }
      // Обработка столкновений пуль с врагами
      for(let i = enemies.length-1; i>=0; i--) {
        for(let j = bullets.length-1; j>=0; j--) {
          let b = bullets[j];
          if(b.fromEnemy || b.fromBoss) continue;  // только пули игрока
          if(circleCollision(enemies[i], b)) {
            // Если пуля с бомбой – наносим урон всем врагам в радиусе
            if(b.bomb) {
              const bombRadius = 80 * scaleFactor;
              for(let k = enemies.length - 1; k >= 0; k--){
                const dx = enemies[k].x - b.x;
                const dy = enemies[k].y - b.y;
                if(Math.hypot(dx,dy) < bombRadius) {
                  enemies[k].hp -= b.damage + player.activePowerUps.bomb.stacks;
                  const pushStrength = 8;
                  const impactAngle = Math.atan2(enemies[k].y - b.y, enemies[k].x - b.x);
                  enemies[k].x += Math.cos(impactAngle) * pushStrength;
                  enemies[k].y += Math.sin(impactAngle) * pushStrength;
                  if(enemies[k].hp <= 0) {
                    if(enemies[k].type === "exploder") {
                      for(let m = enemies.length - 1; m >= 0; m--){
                        const dx2 = enemies[m].x - enemies[k].x;
                        const dy2 = enemies[m].y - enemies[k].y;
                        if(Math.hypot(dx2,dy2) < 50) {
                           enemies[m].hp -= 5;
                        }
                      }
                      for(let m = 0; m < 20; m++){
                        particles.push(new Particle(enemies[k].x, enemies[k].y, "#fa0"));
                      }
                    }
                    if(enemies[k].type === "splitter") {
                      enemies.push(new Enemy(enemies[k].x, enemies[k].y, "basic"));
                      enemies.push(new Enemy(enemies[k].x, enemies[k].y, "basic"));
                    }
                    spawnCollectible(enemies[k].x, enemies[k].y);
                    score += (enemies[k].type==="elite")?200:100;
                    enemies.splice(k,1);
                  }
                }
              }
              for(let k = 0; k < 20; k++){
                particles.push(new Particle(b.x, b.y, "#f00"));
              }
              b.dead = true;
              continue;
            }
            if(enemies[i].type === "shielded" && enemies[i].shield && enemies[i].shieldHP > 0) {
                // Shielded enemy: subtract damage from shield first.
                enemies[i].shieldHP -= b.damage;
            } else {
                enemies[i].hp -= b.damage;
            }
            // Push enemy away from impact
             let pushStrength = 10; // adjust as needed
             let impactAngle = Math.atan2(enemies[i].y - b.y, enemies[i].x - b.x);
             enemies[i].x += Math.cos(impactAngle) * pushStrength;
             enemies[i].y += Math.sin(impactAngle) * pushStrength;
             // Spawn blood particles effect for enemy hit
             for (let blood = 0; blood < 8; blood++) {
               particles.push(new Particle(b.x, b.y, enemies[i].color));
             }
            if(b.freezeBlast) { 
                enemies[i].frozenTime = Math.max(enemies[i].frozenTime, 3000);
            }
            if(b.empBlast) { enemies[i].empTime = Math.max(enemies[i].empTime, 3000 * player.activePowerUps.empBlast.stacks); }
            if(b.lifeSteal) { player.currentHP = Math.min(player.maxHP, player.currentHP + b.damage * player.activePowerUps.lifeSteal.stacks); }
            if(b.piercing) {
              b.piercingCount--;
              if(b.piercingCount <= 0) { b.dead = true; }
            } else { b.dead = true; }
            if(enemies[i].hp <= 0) {
              if(enemies[i].type === "exploder") {
                // When an exploder dies, it explodes—damaging nearby enemies.
                for(let k=0; k<enemies.length; k++){
                  const dx = enemies[k].x - enemies[i].x;
                  const dy = enemies[k].y - enemies[i].y;
                  if(Math.hypot(dx,dy) < 50) {
                     enemies[k].hp -= 5;
                  }
                }
                for(let k=0; k<20; k++){
                  particles.push(new Particle(enemies[i].x, enemies[i].y, "#fa0"));
                }
              }
              if(enemies[i].type === "splitter") {
                // Splitter splits into two basic enemies when killed.
                enemies.push(new Enemy(enemies[i].x, enemies[i].y, "basic"));
                enemies.push(new Enemy(enemies[i].x, enemies[i].y, "basic"));
              }
              spawnCollectible(enemies[i].x, enemies[i].y);
              score += (enemies[i].type==="elite")?200:100;
              enemies[i].dead = true;
              onEnemyKilled(enemies[i]);
              break;
            }
          }
        }
      }
      // Столкновение пуль боссов с игроком
      for(let i = bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        if((b.fromBoss || b.fromEnemy) && circleCollision(b, player)) {
          if (player.activePowerUps.shield.duration > 0) {
            // Если щит активен, пуля просто уничтожается (можно добавить визуальный эффект)
            b.dead = true;
            // Дополнительно: создаём несколько частиц для эффекта удара по щиту
            for (let k = 0; k < 3; k++) {
              particles.push(new Particle(b.x, b.y, "rgba(0,200,255,0.5)"));
            }
          } else {
            player.currentHP -= b.damage;
            // Отображение нанесённого урона
            damageTexts.push({ x: player.x, y: player.y, damage: b.damage, alpha: 1, lifetime: 1000 });
            for (let k = 0; k < 5; k++) {
              particles.push(new Particle(b.x, b.y, "#f00"));
            }
            b.dead = true;
            if (player.currentHP <= 0) { gameState = "gameover"; showGameOver(); }
          }
        }
      }
      // Столкновение пуль игрока с пулями врагов
      for (let i = 0; i < bullets.length; i++) {
        let playerBullet = bullets[i];
        if(playerBullet.fromEnemy || playerBullet.fromBoss) continue; // рассматриваем только пули игрока
        for (let j = 0; j < bullets.length; j++) {
          let enemyBullet = bullets[j];
          if(!(enemyBullet.fromEnemy || enemyBullet.fromBoss)) continue; // рассматриваем только пули врагов
          if(circleCollision(playerBullet, enemyBullet)) {
            playerBullet.dead = true;
            enemyBullet.dead = true;
          }
        }
      }

      // Столкновение пуль с боссами (не боссовых пуль)
      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        if (!b.fromBoss) {
          for(let j = bosses.length - 1; j >= 0; j--) {
            if(circleCollision(b, bosses[j])) {
              bosses[j].hp -= b.damage;
              // --- Если пуля имеет Freeze Blast, то замедляем босса ---
              if(b.freezeBlast) {
                bosses[j].freezeSlow = Math.max(bosses[j].freezeSlow, 3000);
              }
              for(let blood = 0; blood < 5; blood++){
                particles.push(new Particle(b.x, b.y, "#800000"));
              }
              b.dead = true;
              break;
            }
          }
        }
      }
      if(powerMeter >= getPowerMeterMax() && gameState==="playing") {
        showPowerUpMenu();
      }

      // --- Обновление массива damageTexts (плавающие красные числа урона) ---
      for (let i = damageTexts.length - 1; i >= 0; i--) {
        let dt = damageTexts[i];
        dt.lifetime -= deltaTime;
        dt.y -= 0.05 * deltaTime; // поднимаемся вверх
        dt.alpha = dt.lifetime / 1000;
        if (dt.lifetime <= 0) {
          damageTexts.splice(i, 1);
        }
      }
      // *** Обновление объектов Friend на основе эффекта "Friend" ***
      if (player && player.activePowerUps && player.activePowerUps.friend) {
        let friendStacks = player.activePowerUps.friend.stacks;
        // Если стэков 1 – создаём 1 друга, если стэков 2 или больше – 2 друга
        let desiredFriendCount = 0;
        if (friendStacks >= 2) {
          desiredFriendCount = 2;
        } else if (friendStacks === 1) {
          desiredFriendCount = 1;
        }
        while (friends.length < desiredFriendCount) {
          if (desiredFriendCount === 1) {
            friends.push(new Friend(Math.PI / 2));
          } else if (desiredFriendCount === 2) {
            if (friends.length === 0) friends.push(new Friend(Math.PI / 2));
            else if (friends.length === 1) friends.push(new Friend(-Math.PI / 2));
          }
        }
        while (friends.length > desiredFriendCount) {
          friends.pop();
        }
        friends.forEach(friend => friend.update(deltaTime));
      }
      // === combo timer
      updateCombo(deltaTime);

      enemies = enemies.filter(enemy => !enemy.dead);
      bullets = bullets.filter(bullet => !bullet.dead);
    }

    // progress bar
    // progress bar
    function drawLevelProgressBar() {
      ctx.save();
      if (isMobile) {
        ctx.globalAlpha = 0.7;
        if (window.innerWidth > window.innerHeight) {
          // Mobile Landscape → horizontal progress bar at the bottom
          const barWidth = 300 * uiScale;
          const barHeight = 25 * uiScale;
          const x = (width - barWidth) / 2;
          const y = height - barHeight - (20 * uiScale);
          
          // Draw background
          ctx.fillStyle = "#333";
          ctx.fillRect(x, y, barWidth, barHeight);
          
          if (bosses.length === 0) {
            let progress = (levelDuration - levelTimer) / levelDuration;
            progress = Math.max(0, Math.min(1, progress));
            const grad = ctx.createLinearGradient(x, y, x + barWidth, y);
            grad.addColorStop(0, "#0f0");
            grad.addColorStop(1, "#ff0");
            ctx.fillStyle = grad;
            ctx.fillRect(x, y, barWidth * progress, barHeight);
            
            ctx.fillStyle = "#fff";
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.fillText("Boss fight in " + Math.ceil(levelTimer / 1000) + "s!!", 
                         x + barWidth / 2, 
                         y + barHeight - (5 * uiScale));
          } else {
            ctx.fillStyle = "#f00";
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.fillText("FIGHT!", x + barWidth / 2, y + barHeight - (5 * uiScale));
          }
          
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, barWidth, barHeight);
        } else {
          // Mobile Portrait → vertical progress bar on the right
          const barWidth = 25 * uiScale;
          const barHeight = 300 * uiScale;
          const x = width - barWidth - (20 * uiScale);
          const y = (height - barHeight) / 2;
          
          // Draw background
          ctx.fillStyle = "#333";
          ctx.fillRect(x, y, barWidth, barHeight);

          if (bosses.length === 0) {
            let progress = (levelDuration - levelTimer) / levelDuration;
            progress = Math.max(0, Math.min(1, progress));
            const grad = ctx.createLinearGradient(x, y + barHeight, x, y);
            grad.addColorStop(0, "#0f0");
            grad.addColorStop(1, "#ff0");
            ctx.fillStyle = grad;
            ctx.fillRect(x, y + barHeight - (barHeight * progress), barWidth, barHeight * progress);
            
            ctx.fillStyle = "#fff";
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.translate(x + barWidth / 2, y + barHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText("Boss fight in " + Math.ceil(levelTimer / 1000) + "s!!", 0, 0);
          } else {
            ctx.save();
            ctx.fillStyle = "#f00";
            ctx.font = (18 * uiScale) + "px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.translate(x + barWidth / 2, y + barHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText("FIGHT!", 0, 0);
          }          
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, barWidth, barHeight);
        }
      } else {
        // --- Horizontal Progress Bar for Desktop ---
        const barWidth = 300 * uiScale;
        const barHeight = 25 * uiScale;
        const x = (width - barWidth) / 2;
        const y = height - barHeight - (20 * uiScale);
        
        // Draw background
        ctx.fillStyle = "#333";
        ctx.fillRect(x, y, barWidth, barHeight);
        
        if (bosses.length === 0) {
          let progress = (levelDuration - levelTimer) / levelDuration;
          progress = Math.max(0, Math.min(1, progress));
          const grad = ctx.createLinearGradient(x, y, x + barWidth, y);
          grad.addColorStop(0, "#0f0");
          grad.addColorStop(1, "#ff0");
          ctx.fillStyle = grad;
          ctx.fillRect(x, y, barWidth * progress, barHeight);
          
          ctx.fillStyle = "#fff";
          ctx.font = (18 * uiScale) + "px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Boss fight in " + Math.ceil(levelTimer / 1000) + "s!!", x + barWidth / 2, y + barHeight - (5 * uiScale));
        } else {
          ctx.fillStyle = "#f00";
          ctx.font = (18 * uiScale) + "px Arial";
          ctx.textAlign = "center";
          ctx.fillText("FIGHT!", x + barWidth / 2, y + barHeight - (5 * uiScale));
        }
        
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, barWidth, barHeight);
      }
      
      ctx.restore();
    }
    // Функция, которая по ключу из activePowerUps ищет читаемое название в powerUpMap
    function getPowerUpDisplayName(key) {
      for (let displayName in powerUpMap) {
        if (powerUpMap[displayName] === key) {
          return displayName;
        }
      }
      return key; // если не найдено, возвращаем исходное значение
    }

    // =================== Main Draw Function ===================
    function draw() {
      // Полная очистка канвы
      ctx.clearRect(0, 0, width, height);
      const now = performance.now();
      updateBiomeCache(now);


      ctx.save();
      // Вычисляем, сколько пикселей нужно обрезать снизу
      const cropHeight = (isMobile && window.innerHeight > window.innerWidth) ?     getBottomCropHeight() : 0;
      // Задаём область отрисовки – от (0,0) до (width, height - cropHeight)
      ctx.beginPath();
      ctx.rect(0, 0, width, height - cropHeight);
      ctx.clip();

      // ===== Модифицированная отрисовка фона (биома) =====

      ctx.drawImage(cachedBiomeStaticCanvas, 0, 0);
      ctx.restore();
      //getCurrentBiome().drawBackground(ctx);

      // ====================================================
      

      collectibles.forEach(c => c.draw());
      // *** NEW: Отрисовка объектов Friend ***
      friends.forEach(friend => friend.draw());
      if(player) player.draw();
      bullets.forEach(b => b.draw());
      enemies.forEach(e => e.draw());
      // Отрисовка босса (или боссов)
      bosses.forEach(b => b.draw());
      particles.forEach(p => p.draw());

      if (isMobile && window.innerHeight > window.innerWidth) {
        const effectiveHeight = height - getBottomCropHeight();
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(0, effectiveHeight);
        ctx.lineTo(width, effectiveHeight);
        // Настройка толщины линии (можно скорректировать под ваш uiScale)
        ctx.lineWidth = 8 * uiScale;
        // Устанавливаем бирюзовый цвет и неоновое свечение
        ctx.strokeStyle = "rgba(0,255,255,0.8)";
        ctx.shadowColor = "rgba(0,255,255,1)";
        ctx.shadowBlur = 20 * uiScale;
        ctx.stroke();
        ctx.restore();
      }

      // HUD 
      ctx.save();              // сохраняем текущее состояние контекста
      if (isMobile) ctx.globalAlpha = 0.7;

      ctx.fillStyle = "#fff";
      ctx.font = (20 * uiScale) + "px Arial";
      ctx.fillText("Score: " + Math.floor(score), 10, 30 * uiScale);
      ctx.fillText("Level: " + currentLevel, 10, 55 * uiScale);
      // Power Meter Bar
      ctx.fillStyle = "#222";
      ctx.fillRect(10 * uiScale,65 * uiScale,120 * uiScale,15 * uiScale);
      ctx.fillStyle = "#0f0";
      ctx.fillRect(10 * uiScale,65 * uiScale,(120*(powerMeter/getPowerMeterMax())) * uiScale,15 * uiScale);
      ctx.strokeStyle = "#fff";
      ctx.strokeRect(10 * uiScale,65 * uiScale,120 * uiScale,15 * uiScale);
      // Health Bar
      if(player) {
        const grad = ctx.createLinearGradient(10 * uiScale,80 * uiScale,130 * uiScale,80 * uiScale);
        grad.addColorStop(0, "#f00");
        grad.addColorStop(1, "rgba(0,255,0,0.5)");
        ctx.fillStyle = "#222";
        ctx.fillRect(10 * uiScale,80 * uiScale,120 * uiScale,15 * uiScale);
        ctx.fillStyle = grad;
        ctx.fillRect(10 * uiScale,80 * uiScale,(120*(player.currentHP/player.maxHP)) * uiScale,15 * uiScale);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(10 * uiScale,80 * uiScale,120 * uiScale,15 * uiScale);
      }
      
      // Отрисовка перманентных бонусов в правом верхнем углу
      ctx.textAlign = "right";  // Выравнивание текста по правому краю
      ctx.fillStyle = "#fff";
      ctx.font = (20 * uiScale) + "px Arial";
      ctx.fillText("Damage: " + permanentUpgrades.damage, (width - 10), 30 * uiScale);
      ctx.fillText("Speed: " + permanentUpgrades.speed, (width - 10), 55 * uiScale);
      ctx.fillText("Fire Rate: " + permanentUpgrades.fireRate, (width - 10), 80 * uiScale);
      ctx.fillText("Health: " + (100 + permanentUpgrades.health), (width - 10), 105 * uiScale);  // *** NEW: отображение здоровья
      ctx.textAlign = "left";  // Сброс выравнивания для дальнейшей отрисовки
      // =================== Отрисовка активных усилений и негативных эффектов (HUD) ===================
      if (player) {
        let yOffset = 120;
        // Сначала выводим активные (положительные) усиления белым цветом
        if (player.activePowerUps) {
          for (let key in player.activePowerUps) {
            if (player.activePowerUps[key].duration > 0) {
              const displayName = getPowerUpDisplayName(key);
              ctx.fillStyle = "#fff";
              ctx.fillText(displayName + " (" + Math.ceil(player.activePowerUps[key].duration / 1000) + "s, stacks: " + player.activePowerUps[key].stacks + ")", 10 * uiScale, yOffset * uiScale);
              yOffset += 25;
            }
          }
        }
        // Затем выводим негативные эффекты красным цветом
        if (player.frozenTime > 0) {
           ctx.fillStyle = "#f00";
           ctx.fillText("Frozen (" + Math.ceil(player.frozenTime / 1000) + "s)", 10 * uiScale, yOffset * uiScale);
           yOffset += 25;
        }
        if (player.shootingDisabled > 0) {
           ctx.fillStyle = "#f00";
           ctx.fillText("Shooting Disabled (" + Math.ceil(player.shootingDisabled / 1000) + "s)", 10 * uiScale, yOffset * uiScale);
           yOffset += 25;
        }
        if (player.empSlowed > 0) {
           ctx.fillStyle = "#f00";
           ctx.fillText("EMP Slowed (" + Math.ceil(player.empSlowed / 1000) + "s)", 10 * uiScale, yOffset * uiScale);
           yOffset += 25;
        }
      }
      ctx.restore(); 
      // === Отрисовка комбо-счетчика
      ctx.save();
      if (isMobile) ctx.globalAlpha = 0.7;
      
      ctx.textBaseline = "middle"; // выравниваем по вертикальному центру
      let comboColor = "#fff";
      if (comboCounter >= 30) comboColor = "#0ff";
      if (comboCounter >= 70) comboColor = "#ff0";
      if (comboCounter >= 100) comboColor = "#f00";
      if (comboCounter >= 150) comboColor = "rgba(138,43,226,1)";
      ctx.shadowColor = comboColor;    // подсветка
      ctx.shadowBlur = 10 * uiScale;     // радиус свечения
      if (comboCounter >= 200) {
        comboColor = "#000";
        ctx.shadowColor= "#fff"
        ctx.shadowBlur = 5 * uiScale;
      }
      ctx.fillStyle = comboColor;
      ctx.font = (24 * uiScale) + "px Arial";
      // рассчитываем позицию: health bar начинается в 10, ширина 120, добавляем отступ 10
      let comboX = (10 + 120 + 10) * uiScale;
      // вертикальное положение – центр health bar (80 + 15/2)
      let comboY = 80 * uiScale + (15 * uiScale) / 2;
      ctx.fillText("Kills: " + comboCounter, comboX, comboY);
      //ctx.fillText("Combo: " + comboCounter, 10 * uiScale, 140 * uiScale);
      ctx.restore();

      // Отрисовка плавающих красных чисел урона
      damageTexts.forEach(dt => {
        ctx.save();
        ctx.globalAlpha = dt.alpha;
        ctx.fillStyle = "#f00";
        ctx.font = (24 * uiScale) + "px Arial";
        // Если dt.damage является числом – добавляем минус, иначе выводим как есть
        const text = (typeof dt.damage === "number") ? "-" + dt.damage : dt.damage;
        ctx.fillText(text, dt.x, dt.y);
        ctx.restore();
      });
      if (player && player.activePowerUps.neonOverdrive && player.activePowerUps.neonOverdrive.duration > 0) {
        let beamStartX = player.x + Math.cos(player.angle) * (player.radius * scaleFactor);
        let beamStartY = player.y + Math.sin(player.angle) * (player.radius * scaleFactor);
        let beamLength = Math.sqrt(width * width + height * height);
        let beamEndX = beamStartX + Math.cos(player.angle) * beamLength;
        let beamEndY = beamStartY + Math.sin(player.angle) * beamLength;
        
        ctx.save();
        // Настройка стиля для неонового эффекта
        ctx.lineWidth = 8 * scaleFactor;
        ctx.strokeStyle = "rgba(0,255,255,0.7)";  // неоновый цвет (циановый)
        ctx.shadowColor = "rgba(0,255,255,0.9)";
        ctx.shadowBlur = 20 * scaleFactor;;
        ctx.beginPath();
        ctx.moveTo(beamStartX, beamStartY);
        ctx.lineTo(beamEndX, beamEndY);
        ctx.stroke();
        ctx.restore();
        // --- Дополнительные фиолетовые неоновые линии ---
        // Параметр осцилляции (пульсация) рассчитывается на основе времени
        let oscillation = Math.sin(performance.now() / 100) * (3 * scaleFactor); //       изменяется от -3*scaleFactor до +3*scaleFactor
        let offsetBase = 10 * scaleFactor; // базовый отступ от основного луча
        let offset = offsetBase + oscillation; // суммарный отступ

        // Вычисляем перпендикуляр к направлению луча
        let perpX = -Math.sin(player.angle);
        let perpY = Math.cos(player.angle);

        ctx.save();
        ctx.lineWidth = 4 * scaleFactor; // более тонкие линии
        ctx.strokeStyle = "rgba(138,43,226,0.8)"; // фиолетовый (цвет BlueViolet)
        ctx.shadowColor = "rgba(138,43,226,1)";
        ctx.shadowBlur = 15 * scaleFactor;

        // Левая линия (смещена в сторону -perp)
        ctx.beginPath();
        ctx.moveTo(beamStartX - perpX * offset, beamStartY - perpY * offset);
        ctx.lineTo(beamEndX - perpX * offset, beamEndY - perpY * offset);
        ctx.stroke();

        // Правая линия (смещена в сторону +perp)
        ctx.beginPath();
        ctx.moveTo(beamStartX + perpX * offset, beamStartY + perpY * offset);
        ctx.lineTo(beamEndX + perpX * offset, beamEndY + perpY * offset);
        ctx.stroke();
        ctx.restore();
      }
      drawLevelProgressBar();
    }

    // =================== Game Start ===================
    function startGame() {
      gameState = "playing";
      score = 0;
      currentLevel = 1;
      levelDuration = 30000;
      levelTimer = levelDuration;
      permanentUpgrades.damage = 1;
      permanentUpgrades.speed = 1;
      permanentUpgrades.fireRate = 1;
      permanentUpgrades.health = 0;
      comboCounter = 0;
      enemySpawnTimer = 0;
      fireCooldown = 0;
      powerMeter = 0;
      bosses.length = 0;
      enemies.length = 0;
      bullets.length = 0;
      collectibles.length = 0;
      particles.length = 0;
      damageTexts = []; // сброс отображаемых чисел урона
      // *** NEW: Очистка объектов Friend при старте игры ***
      friends.length = 0;
      player = new Player(width/2, height/2);
      player.maxHP = 100 + permanentUpgrades.health;  // *** NEW: учитываем перманентное здоровье
      player.currentHP = player.maxHP;
      document.getElementById("overlay").classList.add("hidden");
    }
    
    mainMenu();
    requestAnimationFrame(gameLoop);
  })();
  </script>
</body>
</html>
